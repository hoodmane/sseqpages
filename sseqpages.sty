\ProvidesPackage{sseqpages}
\RequirePackage{tikz}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usepackage{trace}

% Ensure \@xp and \@nx have the correct values in the (unlikely) case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords


%% Declarations
\newif\ifsseq@errorchecking
\newif\ifsseq@needstikz
\sseq@errorcheckingtrue

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@thepermcyclestyle
\newtoks\sseq@thetranscyclestyle

\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@featurecount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempx
\newcount\sseq@tempy
\newdimen\sseq@tempxdim
\newdimen\sseq@tempydim
\sseq@context@depth\z@
\sseq@context@tempcount\z@
\sseq@featurecount\z@
\sseq@x\z@ \sseq@y\z@
\sseq@tempcount\z@


\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii



%% \sseq@--@--addto@macro and friends.
% My own variants of \pgfutil@g@addto@macro.
% \sseq@x@addto@macro recursively expands the argument and then adds it.
% \sseq@g/x@deforaddto@macro checks first whether the macro is defined or not, if not it used \gdef or \xdef, else it uses \sseq@g/x@addto@macro
% The "ctx" variants are \let equal to the foreach versions when inside of \foreach or when the context command (not named yet) is used
% They also add saved state information to the macro the first time they add data to that macro
\def\sseq@g@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1#2}\xdef#1{\the\pgfutil@toks@}\endgroup} % copy of \pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} % let #2 be expanded

\let\sseq@g@addto@macro@ctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@ctx\sseq@x@addto@macro
\let\sseq@g@addto@macro@noctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@noctx\sseq@x@addto@macro


\def\sseq@g@deforaddto@macro#1{\@ifundefined{#1}{\@xp\gdef\csname#1\endcsname}{\@xp\sseq@g@addto@macro@noctx\csname#1\endcsname}}
\def\sseq@x@deforaddto@macro#1{\@ifundefined{#1}{\@xp\xdef\csname#1\endcsname}{\@xp\sseq@x@addto@macro@noctx\csname#1\endcsname}}

\let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro
\let\sseq@g@deforaddto@macro@noctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@noctx\sseq@x@deforaddto@macro


\def\sseq@g@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1
    \sseq@g@addto@macro@noctx#1%
}

\def\sseq@x@addto@macro@foreach#1{
    \sseq@gx@addto@macro@foreach@#1
    \sseq@x@addto@macro@noctx#1%
}

\def\sseq@g@deforaddto@macro@foreach#1{
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@g@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@x@deforaddto@macro@foreach#1{
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@x@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@gx@addto@macro@foreach@#1{%
    \@ifundefined{sseq@context@\sseq@macroname#1}
        {\sseq@context@tempcount=0\relax}
        {\sseq@context@tempcount=\csname sseq@context@\sseq@macroname#1\endcsname\relax}%
    \ifnum\sseq@context@tempcount<\sseq@context@depth\relax %
        \loop %
            \advance\sseq@context@tempcount1\relax%
            \sseq@for@addsavedtoksntomacro{\the\sseq@context@tempcount}{#1}%
        \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
        \@xp\edef\csname sseq@context@\sseq@macroname#1\endcsname{\the\sseq@context@depth}%
    \fi %
}



%%%% Set up keys

\pgfkeys{
    tikz/sseqpages/.is family,
    tikz/sseqpages/.unknown/.code={\sseq@passoptionto{/tikz}},
    % \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    % TODO: fix global so that unknown options cause errors at the begining of the environment
    % It should check that the option is defined somewhere before deferring it.
    tikz/sseqpages/global/.unknown/.code={
        \let\tempa\pgfkeyscurrentname
        \let\tempb\pgfkeyscurrentvalue
        \pgfkeysalso{\sseq@currentoptionpath options/.append style/.expand twice={\@xp\tempa\@xp=\@xp{\tempb}}}
    },
    tikz/sseqpages/first pass/.unknown/.code={},
    tikz/sseqpages/first pass/class/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    tikz/sseqpages/first pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    tikz/sseqpages/first pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    tikz/sseqpages/second pass/.is family,
    /tikz/sseqpages/second pass/differential/.is family,
    tikz/sseqpages/second pass/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages}},
    tikz/sseqpages/second pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}}
}

\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\edef\temp{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname=\the\sseq@temptoks}}\temp}
\def\sseqset{\pgfqkeys{/tikz/sseqpages}}

%% Quote handling
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\def\sseq@removequotes"#1"{#1}
\def\sseq@classnodetext{}

\pgfkeys{
    /tikz/sseqpages/first pass/handle quote/.code={},
    /tikz/sseqpages/first pass/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /tikz/sseqpages/first pass/class/handle quote/.code={\@xp\def\@xp\sseq@classnodetext\@xp{\sseq@removequotes#1}},
    /tikz/sseqpages/first pass/differential/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/second pass/handle quote/.code={},
    /tikz/sseqpages/second pass/differential/handle quote/.code={\tikzset{every to/.append style={#1}}},
    /tikz/sseqpages/handle quote/.code={\tikzset{every to/.append style={#1}}}% Should we use this? (probably?)
}

%% Parsing and context
\sseqset{
    standard parse/.code={
        \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@old
        \let\sseq@transform\sseq@okaytransform % Allow all coordinate transformations
        \let\sseq@shifttransform\sseq@okaytransform
    }
}

\pgfqkeys{/tikz/sseqpages/first pass}{
    use context/.code={%\def rather than \let because until a \foreach loop occurs, \sseq@g@addto@macro@ctx is vanilla variant
        \def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}
        \def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}
        \def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}
        \def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}
    },
    needs tikz/.code=\sseq@needstikztrue,
    shade/.code=\sseq@needstikztrue, % TODO: shading?
    blend mode/.code=\sseq@needstikztrue,
    pattern/.code=\sseq@needstikztrue,
    path picture/.code=\sseq@needstikztrue,
    path fading/.code=\sseq@needstikztrue,
    decorate/.code=\sseq@needstikztrue,
    pin/.code=\sseq@needstikztrue,
    label/.code=\sseq@needstikztrue,
}

\pgfqkeys{/tikz/sseqpages/second pass}{
    standard parse/.code={},
    use context/.code={},
    needs tikz/.code={}
}

%% Force multipart nodes to be drawn with tikz
% Drawing with tikz is slower, but I don't want to reimplement these features
\pgfqkeys{/tikz/sseqpages/first pass/class}{
    circle split/.code=\sseq@needstikztrue,
    circle solidus/.code=\sseq@needstikztrue,
    ellipse split/.code=\sseq@needstikztrue,
    rectangle split/.code=\sseq@needstikztrue,
    align/.code=\sseq@needstikztrue,
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\place' command. You should use 'alias' instead}{}}
}


%% Force differential to be drawn with tikz if it is bent
% Drawing with tikz is slower, but I don't want to reimplement these features
\pgfqkeys{/tikz/sseqpages/first pass/differential}{
    bend left/.code=\sseq@needstikztrue,
    bend right/.code=\sseq@needstikztrue,
    in/.code=\sseq@needstikztrue,
    out/.code=\sseq@needstikztrue,
    controls/.code=\sseq@needstikztrue,
    in control/.code=\sseq@needstikztrue,
    out control/.code=\sseq@needstikztrue,
    loop/.code=\sseq@needstikztrue,
    loop above/.code=\sseq@needstikztrue,
    loop below/.code=\sseq@needstikztrue,
    loop left/.code=\sseq@needstikztrue,
    loop right/.code=\sseq@needstikztrue
}


%% Style options
\sseqset{
    every sseq/.code={},
    every page/.code={},
    every differential/.code={},
    every class/.code={},
    every label/.style={
        /tikz/auto,
        /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},
        /tikz/inner sep=+0.5ex
    },
    sseqs/.code=           {\pgfkeysalso{every sseq/.append style={#1}}},
    pages/.code=           {\pgfkeysalso{every page/.append style={#1}}},
    differentials/.code=   {\pgfkeysalso{every differential/.append style={#1}}},
    classes/.code=         {\pgfkeysalso{every class/.append style={#1}}},
    labels/.code=          {\pgfkeysalso{every label/.append style={#1}}},
    permanent cycle style/.code={\sseq@thepermcyclestyle={#1}},
    transient cycle style/.code={\sseq@thetranscyclestyle={#1}}
}

%% Global options
\def\sseq@xlabelstep{1}
\def\sseq@ylabelstep{1}

\pgfqkeys{/tikz/sseqpages/global}{
    name/.code={\name{#1}},
    page/.code={\page{#1}},
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
    grid/.code={},
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    label step/.code={\def\sseq@xlabelstep{#1}\def\sseq@ylabelstep{#1}},
    x label step/.store in=\sseq@xlabelstep,
    y label step/.store in=\sseq@ylabelstep
}

\sseqset{
    grid/.code={\sseq@error@optionglobalonly{grid}},
    labels/.code={\sseq@error@optionglobalonly{labels}},
    xlabels/.code={\sseq@error@optionglobalonly{xlabels}},
    ylabels/.code={\sseq@error@optionglobalonly{ylabels}},
    labelstep/.code={\sseq@error@optionglobalonly{labelstep}},
    xlabelstep/.code={\sseq@error@optionglobalonly{xlabelstep}},
    ylabelstep/.code={\sseq@error@optionglobalonly{ylabelstep}}
}


%% setup for coordinate transformation keys
\sseqset{
    x/.code={\sseq@transform{x}{#1}},
    y/.code={\sseq@transform{y}{#1}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{x}{#1}},
    yshift/.code={\sseq@shifttransform{y}{#1}},
    shift/.code={\sseq@transform{shift}{#1}},
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    yscale/.code={\sseq@transform{yscale}{#1}},
    scale/.code={\sseq@transform{scale}{#1}},
    scale around/.code={\sseq@transform{scale around}{#1}},
    xslant/.code={\sseq@transform{xslant}{#1}},
    yslant/.code={\sseq@transform{yslant}{#1}},
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    cm/.code={\sseq@transform{cm}{#1}},
    reset cm/.code={\sseq@transform{reset cm}{}},
    transform canvas/.code={\sseq@transform{transform canvas}{#1}}
}

\pgfqkeys{/tikz/sseqpages/first pass}{
    xshift/.code={\sseq@firstpass@checkshifttransform{x}{#1}},
    yshift/.code={\sseq@firstpass@checkshifttransform{y}{#1}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{
    xshift/.code={},
    yshift/.code={}
}

\def\sseq@error@optionillegal#1#2#3{
    \sseq@temptoks{#2}
    \sseq@error{
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}
}

\def\sseq@error@optionglobalonly#1{
    \sseq@error{
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]')%
    }{}
}

\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@error@illegaltransform#1#2{
    \sseq@temptoks{#2}
    \sseq@error{
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}
}

\def\sseq@firstpass@checkshifttransform#1#2{
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult
    }{\sseq@error@illegaltransform{#1shift}{#2}}
}

\def\sseq@checkshifttransform#1#2{
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult
        \edef\temp{\@nx\sseq@okaytransform{shift}{{(\pgfmathresult\csname pgf@#1x\endcsname,\pgfmathresult\csname pgf@#1y\endcsname)}}}
        \temp
    }{\sseq@error@illegaltransform{#1shift}{#2}}
}

\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%% (What should this section be titled?)
\def\sseq@iffullcoord(#1){\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){
    \@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}
        {\@firstoftwo}
        {\ifnum#3<\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}


%% Parsers

% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\conditionally@traceoff\pgfmathparse{#2}\conditionally@traceon\edef\temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax%
    \ifnum\sseq@commacount<4 %
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1%
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%% Command redefinition commands

% Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@ %
    \fi %
}

% Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@ %
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@modtikzcommands@defer{%
    \let\scope\sseq@scope                   %
    \let\endscope\sseq@endscope             %
    \sseq@modtikzcommands@defer@            %
        \clip\coordinate\draw\fill\filldraw %
        \graph\matrix\node\path\pattern     %
        \shade\shadedraw\useasboundingbox   %
    \sseq@nil                               %
}
\def\sseq@modtikzcommands@defer@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@defer@\fi}
\def\sseq@defer@tikzcommand@std#1;{\sseq@g@addto@macro@ctx\sseq@savedpaths{#1;}}
\let\sseq@defer@tikzcommand\sseq@defer@tikzcommand@std

\def\sseq@modtikzcommands@options{%
    \sseq@modtikzcommands@options@          %
        \clip\coordinate\draw\fill\filldraw %
        \graph\matrix\node\path\pattern     %
        \shade\shadedraw\useasboundingbox   %
    \sseq@nil                               %
}
\def\sseq@modtikzcommands@options@#1{
    \ifx#1\sseq@nil\else
        \@xp\let\csname sseq@\sseq@macroname#1@stored\endcsname#1
        \edef#1##1;{\@nx\sseq@changeoptiondirectory{\@xp\@nx\csname sseq@\sseq@macroname#1@stored\endcsname}##1;[\@nx\sseq@nil]}
        \@xp\sseq@modtikzcommands@options@
    \fi
}

% Ensure that \sseq@scopeoptions gets inserted exactly once, before all other options.
\def\sseq@changeoptiondirectory#1#2[#3]{
    \ifx\sseq@nil#3%
        #1[/tikz/sseqpages,\sseq@scopeoptions]#2%
    \else %
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages,\sseq@scopeoptions,#3]}}%
    \fi %
}
\def\sseq@changeoptiondirectory@#1#2[#3]{% same as the first part except no need to insert \sseq@scopeoptions
    \ifx\sseq@nil#3%
        #1#2
    \else %
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages,#3]}}%
    \fi %
}

% TODO: figure out how to respect the style "every scope"
\def\sseq@scopeoptions{}
\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{%
    \pgfqkeys{/tikz/sseqpages/first pass/scope}{#1}%
    \@xp\def\@xp\sseq@scopeoptions\@xp{\sseq@scopeoptions#1,}%
    \sseq@x@addto@macro\sseq@savedpaths{\@nx\begin{scope}[/tikz/sseqpages,#1]}%
}
\def\sseq@endscope{\sseq@g@addto@macro\sseq@savedpaths{\end{scope}}}

\def\sseq@defer@tikzcommand@scope#1;{%
    \let\sseq@defer@tikzcommand\sseq@defer@tikzcommand@std %
    \sseq@g@addto@macro\sseq@savedpaths{\begin{scope}[/tikz/sseqpages,\sseq@scopeoptions]}%
    \sseq@defer@tikzcommand#1;%
}

% transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@store#1{\edef\temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\temp}
\def\sseq@get#1{\ifx#1\sseq@novalue\edef\temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\temp\fi}


%% Environment definitions

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]#2{%
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
    \sseq@data@name{#2}%
    % the default option handler for /tikz/sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \pgfqkeys{/tikz/sseqpages/global}{#1}
    %To give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \edef\temp{\global\let\@xp\@nx\csname pgfk@/tikz/sseqpages/global/\sseq@thename options/.@cmd\endcsname\@xp\@nx\csname pgfk@/tikz/sseqpages/global/\sseq@thename options/.@cmd\endcsname}
    \temp
    \gdef\sseq@savedpaths{}%
    \gdef\sseq@compilesseq{}%
    %
    \@xp\gdef\csname sseq@savednodes@\sseq@thename infty\endcsname{}
    % Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \foreach\sseq@p in {1,...,12}{%
            \csname sseq@saveddiffs@\sseq@thename\sseq@p\endcsname %
        }%
    }%
    % These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    %
    % These are used to decide whether to add a certain node to savedpaths.
    % In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    % If the user doesn't specify a range, all nodes should be rendered
    % To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
%
    % copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\d\degree %
        \structline %
    }%
%
    \sseq@modtikzcommands@defer % Defer evaluation of tikz primitives
    \sseq@patchfor % patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} % install quotes parsing
    \selectfont\nullfont
}

% Store the savedpaths and ranges
\def\endsseqdata{
    %\@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
    \sseq@compilesseq
%
    \sseq@store\sseq@savedpaths %
    \sseq@store\sseq@thepermcyclestyle\sseq@store\sseq@thetranscyclestyle %
    \sseq@store\sseq@xlabelstep
    \sseq@store\sseq@ylabelstep
    \sseq@store\sseq@xmin\sseq@store\sseq@xmax %
    \sseq@store\sseq@ymin\sseq@store\sseq@ymax %
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{
    \let\sseq@savedpaths\sseq@novalue
    \let\sseq@xlabelstep\sseq@novalue
    \let\sseq@ylabelstep\sseq@novalue
    \let\sseq@xmin\sseq@novalue\let\sseq@xmax\sseq@novalue
    \let\sseq@ymin\sseq@novalue\let\sseq@ymax\sseq@novalue
    % Copy commands into user namespace
    \sseq@copypagecommands{\name\page\doptions\xrange\yrange}%
%
    \gdef\sseqpage@cleanup{} % For undoing local option settings
    \def\sseq@currentoptionpath{this page}
    \pgfqkeys{/tikz/sseqpages/global}{#1}
    %
    % Defer evaluation of all tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}%
    \sseq@patchfor %
    \selectfont\nullfont
}

\def\endsseqpage{%
    % Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \pgfkeys{
      /tikz/edge quotes mean={%
        edge node={node [execute at begin node=$,%$
                         execute at end node=$,%$
                         auto=right,every label,##2]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \edef\temp{\@nx\begin{tikzpicture}[/tikz/every path/.style={/tikz/sseqpages},/tikz/sseqpages,every sseq,/tikz/sseqpages/global/\sseq@thename options,/tikz/sseqpages/global/this pageoptions]}%
    \temp
    %
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    % Axes -- eventually incorporate \axesstyle, label options, changing the increment between the numbers, etc
    \sseq@drawaxes
    \sseq@drawxlabels
    \sseq@drawylabels
    \sseq@clip
%
% TODO: add background savedpaths?
%
    % Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\tikz@@to@or@edge@@coordinate\sseq@tikz@@to@or@edge@@coordinate
%
    \csname sseq@savednodes@\sseq@thename infty\endcsname
    % Insert nodes from all pages on or after the current one
    \foreach\sseq@p in {\curpage,...,12,infty}{%
        \csname sseq@savednodes@\sseq@thename\sseq@p\endcsname %
    }%
%
    % Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    \csname sseq@saveddiffs@\sseq@thename\curpage\endcsname %
%
    % dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@modtikzcommands@options
    \sseq@savedpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup % blank any options special to this page
    \let\sseq@thename\relax %
}

\def\sseq@drawaxes{
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-1.5cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-0.5cm
    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmax cm
    \advance\sseq@tempxdim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.5cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-1.5cm
    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempydim=\sseq@ymax cm
    \advance\sseq@tempydim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \pgfusepath{stroke}
%   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}

\def\sseq@drawxlabels{
    \sseq@tempy=\sseq@ymin\relax
    \advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}
    \sseq@tempx=\sseq@xmin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftext[at=\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}]{$\the\sseq@tempx$}
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}

\def\sseq@drawylabels{
    \sseq@tempx=\sseq@xmin\relax
    \advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@temp{\the\sseq@tempy}
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftext[at=\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}]{$\the\sseq@tempy$}
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@temp\repeat

}

\def\sseq@clip{
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.4cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-0.4cm
    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmax cm
    \advance\sseq@tempxdim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempydim=\sseq@ymax cm
    \advance\sseq@tempydim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.4cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \pgfusepath{clip}
}

\def\printpage[#1]{
    \begin{sseqpage}[#1]
    \end{sseqpage}
}


%% Options and primitives for sseqdata and sseqpage
\def\sseq@data@name#1{\gdef\sseq@thename{#1}}
% When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@get\sseq@savedpaths %
    \sseq@get\sseq@xlabelstep
    \sseq@get\sseq@ylabelstep
    \sseq@get\sseq@xmin  \sseq@get\sseq@xmax %
    \sseq@get\sseq@ymin  \sseq@get\sseq@ymax %
}

\def\sseq@cyclestyles#1#2{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#2}}
\def\sseq@cyclestyle#1{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#1}}
\def\sseq@permanentcyclestyle#1{\sseq@thepermcyclestyle{#1}}
\def\sseq@transientcyclestyle#1{\sseq@thetranscyclestyle{#1}}

\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobble % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1{%
    %\show\sseq@xmin
    %\show\sseq@xminmm
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax@active#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

% Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\curpage}
\def\sseq@page@page@{\sseq@tempcount=\curpage\advance\sseq@tempcount-1\edef\curpagemm{\the\sseq@tempcount}}

\def\sseq@doptions#1(#2){
    \sseq@tempcount=#1%%
    \edef\temp{\@nx\sseq@doptions@{\the\sseq@tempcount}{#2}}\temp%
}

\def\sseq@doptions@#1#2#3{
    \def\temp{#2}
    \sseq@iffullcoord(#2){}{\edef\temp{\temp,1}}
%
    \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@dstyle#1(\temp)\endcsname{}}
    \sseq@g@deforaddto@macro{sseq@dstyle#1(\temp)}{#3,}
}


%% Placement

\def\sseq@place{\@ifnextchar[{\sseq@place@}{\sseq@place@[]}}%}

\def\sseq@place@[#1](#2,#3){
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}
    \edef\next{\@nx\sseq@place@@(\temp){\the\sseq@temptoks}}%
    \next{#1} %
}

\def\sseq@place@@(#1,#2)#3#4{
    \sseq@xminmax{#1}\sseq@yminmax{#2}
    \sseq@tempcount=\@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodespp}{1}{\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname}
    \edef\tempnodenum{\the\sseq@tempcount}
    \@xp\xdef\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname{\the\sseq@tempcount}
    \advance\sseq@tempcount1
    \@xp\xdef\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname{\the\sseq@tempcount}
%
    \sseq@temptoks{#3}% node text
    \sseq@temptoks@ii\@xp{\sseq@scopeoptions}%
    \sseq@temptoks@iii{#4}% local options
    % Classes that eventually die
    \@xp\xdef\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{#1}{#2}{\tempnodenum}{\the\sseq@temptoks}{\the\sseq@thetranscyclestyle,\the\sseq@temptoks@ii}{\the\sseq@temptoks@iii}%
        \endgroup
    }
%
    % Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{#1}{#2}{\tempnodenum}{\the\sseq@temptoks}{\the\sseq@thepermcyclestyle,\the\sseq@temptoks@ii}{\the\sseq@temptoks@iii}%
        \endgroup
    }
    \sseq@x@deforaddto@macro{sseq@clearinfty\sseq@thename(#1,#2,\tempnodenum)}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax}%
%
    \sseq@g@addto@macro\sseq@compilesseq{\sseq@setoffsets{#1}{#2}}%
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname}}
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname}}
    %\tikzset{every path/.show code}
    \ifnum#1<\sseq@xmaxpp\ifnum#1>\sseq@xminmm\ifnum#2<\sseq@ymaxpp\ifnum#2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{% no need for defor since infty page initialized at begin{sseqdata}
%            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
%                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
%            \@nx\fi %
            \@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
        }%
    \fi\fi\fi\fi %
    \endgroup
}

% #1 -- x
% #2 -- y
% #3 -- n
% #4 -- node text
% #5 -- perm/trans cycle style and scopeoptions
% #6 -- local options
\def\sseq@place@drawnode#1#2#3#4#5#6{
    \ifsseq@needstikz
        \sseq@temptoks{#4}
        \sseq@temptoks@ii{#5,every class,#6}
        %\let\tikz@quote@parser\sseq@handlequote
        \edef\temp{
            \@nx\node[
                /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote,
                /tikz/sseqpages/second pass,\the\sseq@temptoks@ii
            ] (sseq@{#1,#2,#3})
            at (#1\@xp\@nx\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\endcsname,#2\@xp\@nx\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\endcsname){\the\sseq@temptoks};
        }
        \temp
    \else
        \begingroup
        \pgfscope
        \let\tikz@options\pgfutil@empty
        \let\tikz@alias=\pgfutil@empty
        \pgfqkeys{/tikz/sseqpages/second pass}{#5}
        \tikzset{every path/.try, every node/.try} % TODO: rework these to not depend on changes issued after using \place
        \pgfqkeys{/tikz/sseqpages/second pass}{every class,#6}
        \tikzset{every \tikz@shape\space node/.try}
        \pgftransformshift{\pgfpoint{#1 cm}{#2 cm}}%
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\endcsname cm}{0\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\endcsname cm}}}
        \temp
        \tikz@options
        \tikz@node@textfont
        \sseq@setnodetext{#4}
        \def\tikz@fig@name{sseq@{#1,#2,#3}}
        \iftikz@fullytransformed\else\pgftransformresetnontranslations\fi
        \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}
        \tikz@alias
        \endpgfscope
        \endgroup
    \fi
}

\def\sseq@setnodetext#1{
    \setbox\pgfnodeparttextbox=\hbox{
        \pgfscope%
        \tikzset{every text node part/.try}%
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        %\show\tikz@textcolor
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          #1%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
      \endpgfscope%
    }
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

% TODO: shading?
\def\sseq@drawnode{
  \pgfutil@tempdima=\pgflinewidth%
  {
    \tikz@mode%
    \iftikz@mode@clip \sseq@error{Clip shouldn't happen here, but this error should be caught earlier}{}\fi % TODO: catch this and similar errors?
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \edef\temp{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}\temp%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%% Offsets TODO: This section is pretty unfinished
\def\sseq@setoffsets#1#2{
    \@ifundefined{sseq@xoffset@\sseq@thename(#1,#2,1)}{\sseq@setoffsets@{#1}{#2}}{\sseq@checkoffsets{#1}{#2}}
}
\def\sseq@setoffsets@#1#2{
    \sseq@tempcount=\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname\relax
    \ifcase\sseq@tempcount\relax
        \sseq@error{Internal error. This should never happen}{}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{1}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{2}
        \sseq@usestdoffsets{#1}{#2}{2}{2}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{3}
        \sseq@usestdoffsets{#1}{#2}{2}{3}
        \sseq@usestdoffsets{#1}{#2}{3}{3}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{4}
        \sseq@usestdoffsets{#1}{#2}{2}{4}
        \sseq@usestdoffsets{#1}{#2}{3}{4}
        \sseq@usestdoffsets{#1}{#2}{4}{4}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{5}
        \sseq@usestdoffsets{#1}{#2}{2}{5}
        \sseq@usestdoffsets{#1}{#2}{3}{5}
        \sseq@usestdoffsets{#1}{#2}{4}{5}
        \sseq@usestdoffsets{#1}{#2}{5}{5}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{6}
        \sseq@usestdoffsets{#1}{#2}{2}{6}
        \sseq@usestdoffsets{#1}{#2}{3}{6}
        \sseq@usestdoffsets{#1}{#2}{4}{6}
        \sseq@usestdoffsets{#1}{#2}{5}{6}
        \sseq@usestdoffsets{#1}{#2}{6}{6}
    \else
        \sseq@error{Too many nodes in coordinate (#1,#2). Improve this error message}{}
    \fi
}

\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}
\def\sseq@checkoffsets#1#2{} %TODO: Implement this

\sseq@setstdoffsets11{}{}
\sseq@setstdoffsets12{-0.13}{}
\sseq@setstdoffsets22{+0.13}{}

\def\sseq@usestdoffsets#1#2#3#4{
    \@xp\global\@xp\let\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdxoffset#3/#4\endcsname
    \@xp\global\@xp\let\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdyoffset#3/#4\endcsname
}

% Not yet implemented
\def\sseq@replace(#1){%
    \sseq@ifundefcoord(#1){\sseq@error{There never was a class at (#1) so I can't replace it}{}}{}%
    \sseq@ifdead(#1){}{\sseq@error{I cannot replace the class at (#1) because it seems to be alive and well}{}}%
    \sseq@parsecommas(#1)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
}%


\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp(#3)%
}

\def\sseq@d@@#1#2(#3,#4){%
%
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/differential}{#1}
    \sseq@parsecommas(\the\sseq@x+#3,\the\sseq@y+#4)
    \edef\temp{\@nx\sseq@parsecommas(\the\sseq@x+#3,\the\sseq@y+#4)}%
    \temp
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \edef\sourcecoord{\sseq@arg1,\sseq@arg2}
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}
    \edef\source{(\sourcecoord,\sseq@optarg{1}3)}%
%
%
    \sseq@parsecoords\targetcoord{\sseq@arg1 + \sseq@targetx{#2},\sseq@arg2+\sseq@targety{#2}}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}
    \edef\target{(\targetcoord,\sseq@optarg{1}4)}%
%
%   Errors:
    \ifsseq@errorchecking
        \sseq@ifundefcoord\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't support
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifundefcoord\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't accept
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifdead\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't support
                a differential because it already perished on page \sseq@getdeathpage\source %
            }{}%
        }{}%
        \sseq@ifdead\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't accept
                a differential because it already perished on page \sseq@getdeathpage\target %
            }{}%
        }{}%
%
        \ifnum\csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg3}{}{\sseq@error{
                There is only one node in source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)'%
            }{}}
        \else
            \@ifundefined{sseq@arg3}{\sseq@error{
                There are multiple nodes in source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname\sseq@macroname\ nodes at (\sourcecoord) should be the source%
            }{}}{}
        \fi
        \ifnum\csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg4}{}{\sseq@error{
                There is only one node in target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)'%
            }{}}
        \else
            \@ifundefined{sseq@arg4}{\sseq@error{
                There are multiple nodes in target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname\sseq@macroname\ nodes at (\targetcoord) should be the target%
            }{}}{}
        \fi
    \fi
%
%
    \sseq@setdeathpage\source{#2}%
    \sseq@setdeathpage\target{#2}%
%
    %\sseq@temptoks\@xp{\sseq@scopeoptions,#1}
    %\sseq@x@deforaddto@macro{sseq@saveddiffs@\sseq@thename#2}{%
    %    \@nx\sseq@temptoks{\the\sseq@temptoks}%
    %    \@nx\edef\@nx\temp{\@nx\@nx\@nx\draw[/tikz/sseqpages/second pass/differential,every differential,\@nx\the\@nx\sseq@temptoks,\@xp\@nx\csname sseq@dstyle#2\source\endcsname] \source to \target;}%
    %    \@nx\temp %
    %}%

    \sseq@temptoks\@xp{\sseq@scopeoptions}
    \def\temp{#1,}
    \@xp\@xp\@xp\sseq@temptoks@ii\@xp\@xp\@xp{\@xp\temp\csname sseq@dstyle#2\source\endcsname}
    \sseq@x@deforaddto@macro{sseq@saveddiffs@\sseq@thename#2}{
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@d@drawedge\source\target{\the\sseq@temptoks}{\the\sseq@temptoks@ii}
        \endgroup
    }
%
    \@xp\gdef\csname sseq@dstyle#2\source\endcsname{}%
%
    % Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} % This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\source\endcsname%
    \csname sseq@clearinfty\sseq@thename\target\endcsname%
%
    % Add placement on appropriate page
    \sseq@x@deforaddto@macro{sseq@savednodes@\sseq@thename#2}{%
        \@xp\@nx\csname sseq@place\sseq@thename\source\endcsname %
        \@xp\@nx\csname sseq@place\sseq@thename\target\endcsname %
    }%
    \endgroup
}

% #1 -- source
% #2 -- target
% #3 -- scope options
% #4 -- local and late options
\def\sseq@d@drawedge(#1)(#2)#3#4{
    \ifsseq@needstikz
        \sseq@temptoks{#3,#4}
        \edef\temp{\@nx\draw[/tikz/sseqpages/second pass/differential,every differential,\the\sseq@temptoks] (#1) to (#2);}
        \temp
    \else
        \pgfscope
        \pgfqkeys{/tikz/sseqpages/second pass}{draw,#3}
        \tikzset{every path/.try}
        \pgfqkeys{/tikz/sseqpages/second pass}{every differential,#4}
        \tikz@options
        \tikz@mode
        \pgfpathmoveto{\pgfpointshapeborder{sseq@{#1}}{\pgfpointanchor{sseq@{#2}}{center}}}
        %\xdef\tikz@timer@start{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
        \pgfpathlineto{\pgfpointshapeborder{sseq@{#2}}{\pgfpointanchor{sseq@{#1}}{center}}}
        %\xdef\tikz@timer@end{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
        \edef\temp{\noexpand\pgfusepath{%
            \iftikz@mode@fill fill,\fi%
            \iftikz@mode@draw draw,\fi%
        }}\temp
        %\tikz@node@textfont
        %\def\tikz@time{0.5}
        %\tikz@do@auto@anchor%
        %\tikz@timer%
        %\tikz@timer@line
        %\tikz@transform
        %\pgfnode{rectangle}{\tikz@anchor}{hi}{}{\pgfusepath{draw}}
        \endpgfscope
    \fi
}

\def\sseq@addcontingentfeature#1#2{%
    \@xp\gdef\csname sseq@feature\the\sseq@featurecount\endcsname{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
        \@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
%        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
%            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
%        \@nx\fi %
    }%
    %
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        %\sseq@temppage is defined by \d before it calls this.
        \@nx\sseq@g@deforaddto@macro{sseq@savednodes@\sseq@thename\@nx\sseq@temppage}{% needs to be defor in case this is placed before the nodes it connects.
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname %
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax %
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil,)%
    \global\advance\sseq@featurecount1%
}

\def\sseq@addcontingentfeature@(#1,#2){
    \ifx\sseq@nil#1\else %
        \sseq@parsecoords\temp{\sseq@x+#1,\sseq@y+#2}%
        \@xp\sseq@iffullcoord\@xp(\temp){}{\edef\temp{\temp,1}}%
        \sseq@x@deforaddto@macro{sseq@clearinfty\sseq@thename(\temp)}{% should be deforaddto, so that it will work even if this is called before the node is placed
                \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname %
        }%
    %
        \@xp\sseq@addcontingentfeature@ %
    \fi
}

\def\sseq@structline(#1)(#2){\edef\temp{\@nx\sseq@structline@\sseq@anchorsplit{#1}\sseq@anchorsplit{#2}}\temp}
\def\sseq@structline@#1#2#3#4{
    \sseq@parsecoords\source{#1}%
    \sseq@parsecoords\target{#3}%
    \edef\temp{\@nx\sseq@structline@@{\source}{#2}{\target}{#4}}%
    \temp %
}
\def\sseq@structline@@#1#2#3#4{\edef\temp{\@nx\sseq@addcontingentfeature{(#1)(#3)}{\@nx\draw[/tikz/sseqpages,\sseq@scopeoptions] (#1#2) to (#3#4);}}\temp}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


%% Redo tikz parsing rules for interpreting coordinates
% We want to intepret (x,y) as the name of a node.		
%
% Original behavior:
% The original parsing rule said roughly:
%   if there's a cs: treat it like a coordinate shift
%     if there's the word intersection: treat it as an intersection
%       ...
%        if there's a comma treat it as a literal coordinate
%          else treat it as the name of a node
%
% We replace the second to last step with:
%    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%      if there is such a node, treat it as refering to sseq@{x,y}
%      else treat it as a literal coordinate
%
% Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}


\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}
    \@xp\sseq@iffullcoord\@xp(\temp){}{\@ifundefined{sseq@coord\sseq@thename(\temp)@numnodes}{}{\ifnum\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname=1\relax\edef\temp{\temp,1}\fi}}
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid % Check if a node with name sseq@{x,y} is defined in this picture
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}
    \else %( % No such node exists
        \ifx&#4& % make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3#4})} % Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor '\@gobble#4'. In order to accept an anchor, there must be a node at the given location}{}
        \fi
    \fi
    \next
}

\def\sseq@tikz@@to@or@edge@@coordinate(#1){%
  \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
    \def\tikztotarget{sseq@{#1}}
  \else
    \def\tikztotarget{#1}
  \fi
  \tikz@to@or@edge@function%
}


%% Patch \foreach to use sseq@context
% TODO: Add stuff for when this fails

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@addtosavedtoks{\@xp\sseq@g@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@xaddtosavedtoks{\@xp\sseq@x@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@addsavedtoksntomacro#1#2{\@xp\@xp\@xp\sseq@g@addto@macro@noctx\@xp\@xp\@xp#2\@xp\@xp\@xp{\csname sseq@for@savedtoks#1\endcsname}}

\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\patchcmd\sseq@pgffor@invokebody % store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % store setting before
    {\ifx\pgffor@assign@before@code}
    {\sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}%
     \ifx\pgffor@assign@before@code}
    {}{\no}
\patchcmd\sseq@pgffor@invokebody % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@addtosavedtoks{\def#2{#4}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}


\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@xaddtosavedtoks{\def\@nx#1{\the#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@xaddtosavedtoks\@xp{\@xp\def\@xp#1\@xp{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@xaddtosavedtoks{\def\@nx#2{#1}}}}
    {}{\no}


\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@currentvar{\pgffor@temp}}}
    {}{\no}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@once@expanded}}
    {}{\no}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@expanded}}
    {}{\no}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\no}
