\ProvidesPackage{sseqpages}
\RequirePackage{tikz}
\RequirePackage{environ}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usepackage{trace}

% Ensure \@xp and \@nx have the correct values in the (unlikely) case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords

% My own version of \pgfutil@g@addto@macro. Checks if the macro is undefined and handles that case correctly too.
\def\sseq@g@addto@macro#1{\@ifundefined{\sseq@macroname#1}{\gdef#1}{\sseq@g@addto@macro@#1}}
\let\sseq@g@addto@macro@\pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1{\@ifundefined{\sseq@macroname#1}{\xdef#1}{\sseq@x@addto@macro@#1}}
\def\sseq@x@addto@macro@#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup}


%% Declarations
\newif\ifsseq@errorchecking
\sseq@errorcheckingtrue
\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@thepermcyclestyle
\newtoks\sseq@thetranscyclestyle
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@featurecount
\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii

%% Set up keys

\pgfkeys{
    tikz/sseqpages/.is family,
    tikz/sseqpages/.search also={/tikz},
    tikz/sseqpages/internal/shifts only pass/.unknown/.code={},
    tikz/sseqpages/internal/no shifts pass/.is family,
    tikz/sseqpages/internal/no shifts pass/.search also={/tikz/sseqpages,/tikz}
}
\def\sseqset{\pgfqkeys{/tikz/sseqpages}}
\sseqset{
    every sseq/.style={},
    every page/.style={},
    every differential/.style={},
    every class/.style={},
    every label/.style={
        /tikz/auto,
        /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},
        /tikz/inner sep=+0.5ex
    },
    sseqs/.code=        {\sseqset{every sseq/.append style={#1}}},
    pages/.code=        {\sseqset{every page/.append style={#1}}},
    differentials/.code={\sseqset{every differential/.append style={#1}}},
    classes/.code=      {\sseqset{every class/.append style={#1}}},
    labels/.code=       {\sseqset{every label/.append style={#1}}}
}

\sseqset{ % coordinate transformations
    x/.code={\sseq@transform{x}{#1}},
    y/.code={\sseq@transform{y}{#1}},
    z/.code={\sseq@erroroptionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{x}{#1}},
    yshift/.code={\sseq@shifttransform{y}{#1}},
    shift/.code={\sseq@transform{shift}{#1}},
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    yscale/.code={\sseq@transform{yscale}{#1}},
    scale/.code={\sseq@transform{scale}{#1}},
    scale around/.code={\sseq@transform{scale around}{#1}},
    xslant/.code={\sseq@transform{xslant}{#1}},
    yslant/.code={\sseq@transform{yslant}{#1}},
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    cm/.code={\sseq@transform{cm}{#1}},
    reset cm/.code={\sseq@transform{reset cm}{}},
    transform canvas/.code={\sseq@transform{transform canvas}{#1}}
}

\pgfqkeys{/tikz/sseqpages/internal/shifts only pass}{
    xshift/.code={\sseq@ifp@checkshifttransform{x}{#1}},
    yshift/.code={\sseq@ifp@checkshifttransform{y}{#1}}
}

\pgfqkeys{/tikz/sseqpages/internal/no shifts pass}{
    xshift/.code={},
    yshift/.code={},
}

\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@errortransform#1#2{
    \sseq@temptoks{#2}
    \sseq@error{
        You said "#1\ifx&#2&\else=\the\sseq@temptoks\fi", but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option "standard parse"%
    }{}
}
\def\sseq@erroroptionillegal#1#2#3{
    \sseq@error{
        You said "#1\ifx&#2&\else=\the\sseq@temptoks\fi", but the option #1 is
        illegal in the sseqdata and sseqpage environments#3%
    }{}
}

\def\sseq@ifp@checkshifttransform#1#2{
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult
    }{\sseq@errortransform{#1shift}{#2}}
}

\def\sseq@checkshifttransform#1#2{
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult
        \edef\temp{\@nx\sseq@okaytransform{shift}{{(\pgfmathresult\csname pgf@#1x\endcsname,\pgfmathresult\csname pgf@#1y\endcsname)}}}
        \temp
    }{\sseq@errortransform{#1shift}{#2}}
}

\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared \@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0 \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}

%% (What should this section be titled?)
\def\sseq@iffullcoord(#1){\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){
    \@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}
        {\@firstoftwo}
        {\ifnum#3<\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}


%% Parsers

% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\conditionally@traceoff\pgfmathparse{#2}\conditionally@traceon\edef\temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \conditionally@traceoff %
    \advance\sseq@commacount1\relax%
    \ifnum\sseq@commacount<4 %
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1%
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}

\newcount\sseq@commacount


%% Command redefinition commands

% Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@ %
    \fi %
}

% Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@ %
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@modtikzcommands@defer{%
    \let\scope\sseq@scope                   %
    \let\endscope\sseq@endscope             %
    \sseq@modtikzcommands@defer@            %
        \clip\coordinate\draw\fill\filldraw %
        \graph\matrix\node\path\pattern     %
        \shade\shadedraw\useasboundingbox   %
    \sseq@nil                               %
}
\def\sseq@modtikzcommands@defer@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@defer@\fi}
\def\sseq@defer@tikzcommand@std#1;{\sseq@g@addto@macro\sseq@savedpaths{#1;}}
\let\sseq@defer@tikzcommand\sseq@defer@tikzcommand@std

\def\sseq@modtikzcommands@options{%
    \sseq@modtikzcommands@options@          %
        \clip\coordinate\draw\fill\filldraw %
        \graph\matrix\node\path\pattern     %
        \shade\shadedraw\useasboundingbox   %
    \sseq@nil                               %
}
\def\sseq@modtikzcommands@options@#1{
    \ifx#1\sseq@nil\else
        \@xp\let\csname sseq@\sseq@macroname#1@stored\endcsname#1
        \edef#1##1;{\@nx\sseq@changeoptiondirectory{\@xp\@nx\csname sseq@\sseq@macroname#1@stored\endcsname}##1;[\@nx\sseq@nil]}
        \@xp\sseq@modtikzcommands@options@
    \fi
}

% ensure that \sseq@scopeoptions gets inserted exactly once, before all other options.
\def\sseq@changeoptiondirectory#1#2[#3]{
    \ifx\sseq@nil#3%
        #1[/tikz/sseqpages,\sseq@scopeoptions]#2%
    \else %
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages,\sseq@scopeoptions,#3]}}%
    \fi %
}
\def\sseq@changeoptiondirectory@#1#2[#3]{% same as the firs part except no need to insert \sseq@scopeoptions
    \ifx\sseq@nil#3%
        #1#2
    \else %
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages,#3]}}%
    \fi %
}

\def\sseq@scopeoptions{}
\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{\pgfqkeys{/tikz/sseqpages/internal/shifts only pass}{#1}\@xp\def\@xp\sseq@scopeoptions\@xp{\sseq@scopeoptions#1,}\sseq@x@addto@macro\sseq@savedpaths{\@nx\begin{scope}[/tikz/sseqpages,#1]}}
\def\sseq@endscope{\sseq@g@addto@macro\sseq@savedpaths{\end{scope}}}

\def\sseq@defer@tikzcommand@scope#1;{%
    \let\sseq@defer@tikzcommand\sseq@defer@tikzcommand@std %
    \sseq@g@addto@macro\sseq@savedpaths{\begin{scope}[/tikz/sseqpages,\sseq@scopeoptions]}%
    \sseq@defer@tikzcommand#1;%
}

% transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@store#1{\edef\temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\temp}
\def\sseq@get#1{\edef\temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\temp}


%% Environment definitions

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]#2{%
    \def\sseq@savedpaths{}%
    \sseq@data@name{#2}%
    \@xp\gdef\csname sseq@options\sseq@thename\endcsname{#1}%
    %
    % Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \foreach\sseq@p in {1,...,12}{%
            \csname sseq@saveddiffs@\sseq@thename\sseq@p\endcsname %
        }%
    }%
    % These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    % These are used to decide whether to add a certain node to savedpaths.
    % In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    % If the user doesn't specify a range, all nodes should be rendered
    % To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
%
    % copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\d\degree %
        \structline %
    }%
%
    % Defer evaluation of tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\@gobble}%
}

% Store the savedpaths and ranges
\def\endsseqdata{
    \@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
    \sseq@compilesseq
    \global\let\sseq@compilesseq\relax
    \sseq@store\sseq@savedpaths %
    \sseq@store\sseq@thepermcyclestyle\sseq@store\sseq@thetranscyclestyle %
    \sseq@store\sseq@xmin\sseq@store\sseq@xmax %
    \sseq@store\sseq@ymin\sseq@store\sseq@ymax %
}
\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{
    \gdef\sseqpage@cleanup{} % For undoing local option settings
    \def\sseq@options{#1}%
    % Copy commands into user namespace
    \sseq@copypagecommands{\name\page\doptions\xrange\yrange}%
    %
    % Defer evaluation of all tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\@gobble}%
}
\def\endsseqpage{%
    % Copied from tikzcd code. Passes quotes forward to edge and format edge label appropriately
    \pgfkeys{% `quotes' library support,
      /handlers/first char syntax/the character "/.initial=\sseq@forward@quotes,%
      /tikz/edge quotes mean={%
        edge node={node [execute at begin node=$,%$
                         execute at end node=$,%$
                         auto=right,every label,##2]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \sseq@temptoks\@xp\@xp\@xp{\csname sseq@options\sseq@thename\endcsname}%
    \sseq@temptoks@ii\@xp{\sseq@options}%
    \edef\temp{\@nx\begin{tikzpicture}[/tikz/every path/.style={/tikz/sseqpages},/tikz/sseqpages,every sseq,\the\sseq@temptoks,\the\sseq@temptoks@ii]}%
    \temp
    %
    \let\sseq@transform\sseq@errortransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    % Axes -- eventually incorporate \axesstyle, label options, changing the increment between the numbers, etc
    \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
    \foreach \sseq@x in {\sseq@xmin,...,\sseq@xmax}%
        \node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
    \foreach \sseq@y in {\sseq@ymin,...,\sseq@ymax}%
        \node at (\sseq@xmin-1,\sseq@y) {\sseq@y};%
%
    % clip
    \clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
%
    % Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\tikz@@to@or@edge@@coordinate\sseq@tikz@@to@or@edge@@coordinate
%
%
    % Insert nodes from all pages after the current one
    \foreach\sseq@p in {\curpage,...,12,infty}{%
        \csname sseq@savednodes@\sseq@thename\sseq@p\endcsname %
    }%
%
    % Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    %\@xp\show\csname sseq@saveddiffs@\sseq@thename2\endcsname %
    %\tracingall
    \csname sseq@saveddiffs@\sseq@thename\curpage\endcsname %
%
    % dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@modtikzcommands@options
    \sseq@savedpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup % This blanks any options special to this page
    \let\sseq@thename\relax %
}

\def\printpage#1#2{
    \begin{sseqpage}
    \name{#1}
    \page{#2}
    \end{sseqpage}
}

% Copied from tikzcd code. Passes quotes forward to edge
\def\sseq@forward@quotes#1{\tikzset{every to/.append style={#1}}}


%% Options and primitives for sseqdata and sseqpage
\def\sseq@data@name#1{\gdef\sseq@thename{#1}}
% When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@get\sseq@savedpaths %
    \sseq@get\sseq@xmin  \sseq@get\sseq@xmax %
    \sseq@get\sseq@ymin  \sseq@get\sseq@ymax %
}

\def\sseq@cyclestyles#1#2{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#2}}
\def\sseq@cyclestyle#1{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#1}}
\def\sseq@permanentcyclestyle#1{\sseq@thepermcyclestyle{#1}}
\def\sseq@transientcyclestyle#1{\sseq@thetranscyclestyle{#1}}

\def\sseq@xrange#1#2{%
    \let\sseq@xminmax\@gobble % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\edef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\edef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\edef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\edef\sseq@ymaxpp{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax#1{%
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

% Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\curpage}
\def\sseq@page@page@{\sseq@tempcount=\curpage\advance\sseq@tempcount-1\edef\curpagemm{\the\sseq@tempcount}}

\def\sseq@doptions#1(#2){
    \sseq@tempcount=#1%%
    \edef\temp{\@nx\sseq@doptions@{\the\sseq@tempcount}{#2}}\temp%
}

\def\sseq@doptions@#1#2{
    \def\temp{#2}
    \sseq@iffullcoord(#2){}{\edef\temp{\temp,1}}
%
    %\@xp\sseq@g@addto@macro\csname sseq@dstyle#1(#2)\endcsname
    \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@dstyle#1(\temp)\endcsname{}}
    \@xp\def\csname sseq@dstyle#1(\temp)\endcsname
}


%% Placement

\def\sseq@place{\@ifnextchar[{\sseq@place@}{\sseq@place@[]}}%}

\def\sseq@place@[#1](#2,#3){
    \bgroup
    \pgfqkeys{/tikz/sseqpages/internal/shifts only pass}{#1}
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}%
    \edef\next{\@nx\sseq@place@@(\temp)}%
    \@xp\egroup
    \next{#1} %
}

\def\sseq@place@@(#1,#2)#3{
    \sseq@tempcount=\@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodespp}{1}{\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname}
    \edef\tempnodenum{\the\sseq@tempcount}
    \@xp\xdef\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname{\the\sseq@tempcount}
    \advance\sseq@tempcount1
    \@xp\xdef\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname{\the\sseq@tempcount}
%
    % Classes that eventually die
    %\def\temp{{sseq@{#1,#2,\tempnodenum}}{#1\@nx\sseq@xoffset{#1}{#2}{\tempnodenum},#2\@nx\sseq@yoffset{#1}{#2}{\tempnodenum}}}
    \edef\temp{\@nx\node[/tikz/sseqpages/internal/no shifts pass,every class,\the\sseq@thetranscyclestyle,\sseq@scopeoptions,#3] (sseq@{#1,#2,\tempnodenum}) at (#1\@xp\@nx\csname sseq@xoffset@\sseq@thename(#1,#2,\tempnodenum)\endcsname,#2\@xp\@nx\csname sseq@yoffset@\sseq@thename(#1,#2,\tempnodenum)\endcsname){};}
    \sseq@temptoks\@xp{\temp}%
    \@xp\xdef\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{\the\sseq@temptoks}
%
    % Classes that live forever
    \edef\temp{\@nx\node[/tikz/sseqpages/internal/no shifts pass,every class,\the\sseq@thepermcyclestyle,\sseq@scopeoptions,#3] (sseq@{#1,#2,\tempnodenum}) at (#1\@xp\@nx\csname sseq@xoffset@\sseq@thename(#1,#2,\tempnodenum)\endcsname,#2\@xp\@nx\csname sseq@yoffset@\sseq@thename(#1,#2,\tempnodenum)\endcsname){};}
    \sseq@temptoks\@xp{\temp}
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\the\sseq@temptoks}
    \@xp\xdef\csname sseq@clearinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax}%
%
    \sseq@g@addto@macro\sseq@compilesseq{\sseq@setoffsets{#1}{#2}}
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname}}
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname}}

    \ifnum#1<\sseq@xmaxpp\ifnum#1>\sseq@xminmm\ifnum#2<\sseq@ymaxpp\ifnum#2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
            \@nx\fi %
        }%
    \fi\fi\fi\fi %
}

\def\sseq@setoffsets#1#2{
    \@ifundefined{sseq@xoffset@\sseq@thename(#1,#2,1)}{\sseq@setoffsets@{#1}{#2}}{\sseq@checkoffsets{#1}{#2}}
}
\def\sseq@setoffsets@#1#2{
    \sseq@tempcount=\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname\relax
    \ifcase\sseq@tempcount\relax
        \sseq@error{Internal error. This should never happen}{}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{1}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{2}
        \sseq@usestdoffsets{#1}{#2}{2}{2}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{3}
        \sseq@usestdoffsets{#1}{#2}{2}{3}
        \sseq@usestdoffsets{#1}{#2}{3}{3}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{4}
        \sseq@usestdoffsets{#1}{#2}{2}{4}
        \sseq@usestdoffsets{#1}{#2}{3}{4}
        \sseq@usestdoffsets{#1}{#2}{4}{4}
    \else
        \sseq@error{Too many nodes in coordinate (#1,#2). Improve this error message}{}
    \fi
}

\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}
\def\sseq@checkoffsets#1#2{} %TODO: Implement this

\sseq@setstdoffsets11{}{}
\sseq@setstdoffsets12{-0.13}{}
\sseq@setstdoffsets22{+0.13}{}

\def\sseq@usestdoffsets#1#2#3#4{
    \@xp\global\@xp\let\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdxoffset#3/#4\endcsname
    \@xp\global\@xp\let\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdyoffset#3/#4\endcsname
}

% Not yet implemented
\def\sseq@replace(#1){%
    \sseq@ifundefcoord(#1){\sseq@error{There never was a class at (#1) so I can't replace it}{}}{}%
    \sseq@ifdead(#1){}{\sseq@error{I cannot replace the class at (#1) because it seems to be alive and well}{}}%
    \sseq@parsecommas(#1)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
}%


\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp(#3)%
}

\def\sseq@d@@#1#2(#3,#4){%
    \conditionally@traceon%
%
    \pgfqkeys{/tikz/sseqpages/internal/shifts only pass}{#1}
    \sseq@parsecommas(\sseq@x+#3,\sseq@y+#4)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \edef\sourcecoord{\sseq@arg1,\sseq@arg2}
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}
    \edef\source{(\sourcecoord,\sseq@optarg{1}3)}%
%
%
    \sseq@parsecoords\targetcoord{\sseq@arg1 + \sseq@targetx{#2},\sseq@arg2+\sseq@targety{#2}}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}
    \edef\target{(\targetcoord,\sseq@optarg{1}4)}%
%
%   Errors:
    \ifsseq@errorchecking
        \sseq@ifundefcoord\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" can't support
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifundefcoord\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" can't accept
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifdead\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" can't support
                a differential because it already perished on page \sseq@getdeathpage\source %
            }{}%
        }{}%
        \sseq@ifdead\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" can't accept
                a differential because it already perished on page \sseq@getdeathpage\target %
            }{}%
        }{}%
%
        \ifnum\csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg3}{}{\sseq@error{
                There is only one node in source coordinate (\sourcecoord) so instead of "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" you should say
                "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)"%
            }{}}
        \else
            \@ifundefined{sseq@arg3}{\sseq@error{
                There are multiple nodes in source coordinate (\sourcecoord) so instead of "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" you should say
                "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)" where n specifies which of the
                \csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname\sseq@macroname\ nodes at (\sourcecoord) should be the source%
            }{}}{}
        \fi
        \ifnum\csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg4}{}{\sseq@error{
                There is only one node in target coordinate (\targetcoord) so instead of "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" you should say
                "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)"%
            }{}}
        \else
            \@ifundefined{sseq@arg4}{\sseq@error{
                There are multiple nodes in target coordinate (\targetcoord) so instead of "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)" you should say
                "\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)" where n specifies which of the
                \csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname\sseq@macroname\ nodes at (\targetcoord) should be the target%
            }{}}{}
        \fi
    \fi
%
%
    \sseq@setdeathpage\source{#2}%
    \sseq@setdeathpage\target{#2}%
%
    \sseq@temptoks{#1}%
    \@xp\sseq@x@addto@macro\csname sseq@saveddiffs@\sseq@thename#2\endcsname{%
        \@nx\sseq@temptoks{\the\sseq@temptoks}%
        \@nx\edef\@nx\temp{\@nx\@nx\@nx\draw[/tikz/sseqpages/internal/no shifts pass,every differential,\sseq@scopeoptions,\@nx\the\@nx\sseq@temptoks,\@xp\@nx\csname sseq@dstyle#2\source\endcsname] \source to \target;}%
        \@nx\temp %
    }%
%
    \@xp\gdef\csname sseq@dstyle#2\source\endcsname{}%
%
    % Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} % This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\source\endcsname%
    \csname sseq@clearinfty\sseq@thename\target\endcsname%
%
    % Add placement on appropriate page
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename#2\endcsname{%
        \@xp\@nx\csname sseq@place\sseq@thename\source\endcsname %
        \@xp\@nx\csname sseq@place\sseq@thename\target\endcsname %
    }%
}

\def\sseq@addcontingentfeature#1#2{%
    \@xp\gdef\csname sseq@feature\the\sseq@featurecount\endcsname{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
        \@nx\fi %
    }%
    %\@xp\show\csname sseq@feature\the\sseq@featurecount\endcsname
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        \@nx\@xp\@nx\sseq@g@addto@macro\@nx\csname sseq@savednodes@\sseq@thename\@nx\sseq@temppage\endcsname{%
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname %
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax %
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil,)%
    \global\advance\sseq@featurecount1%
}

\def\sseq@addcontingentfeature@(#1,#2){
    \ifx\sseq@nil#1\else %
        \sseq@parsecoords\temp{\sseq@x+#1,\sseq@y+#2}%
        \@xp\sseq@iffullcoord\@xp(\temp){}{\edef\temp{\temp,1}}%
        \@xp\sseq@x@addto@macro\csname sseq@clearinfty\sseq@thename(\temp)\endcsname{%
                \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname %
        }%
    %
        \@xp\sseq@addcontingentfeature@ %
    \fi
}

\def\sseq@structline(#1)(#2){\edef\temp{\@nx\sseq@structline@\sseq@anchorsplit{#1}\sseq@anchorsplit{#2}}\temp}
\def\sseq@structline@#1#2#3#4{
    \sseq@parsecoords\source{#1}%
    \sseq@parsecoords\target{#3}%
    \edef\temp{\@nx\sseq@structline@@{\source}{#2}{\target}{#4}}%
    \temp %
}
\def\sseq@structline@@#1#2#3#4{\edef\temp{\@nx\sseq@addcontingentfeature{(#1)(#3)}{\@nx\draw[/tikz/sseqpages,\sseq@scopeoptions] (#1#2) to (#3#4);}}\temp}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


%% Redo tikz parsing rules for interpreting coordinates
% We want to intepret (x,y) as the name of a node.		
%
% Original behavior:
% The original parsing rule said something like:
%   if there's a cs: treat it like a coordinate shift
%     if there's the word intersection: treat it as an intersection
%       ...
%        if there's a comma treat it as a literal coordinate
%          else treat it as the name of a node
%
% We replace the second to last step with:
%    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%      if there is such a node, treat it as refering to sseq@{x,y}
%      else treat it as a literal coordinate
%
% Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}

\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}
    %\show\temp
    \@xp\sseq@iffullcoord\@xp(\temp){}{\@ifundefined{sseq@coord\sseq@thename(\temp)@numnodes}{}{\ifnum\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname=1\relax\edef\temp{\temp,1}\fi}}
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid % Check if a node with name sseq@{x,y} is defined in this picture
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}
    \else %( % No such node exists
        \ifx&#4& % make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3#4})} % Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor "\@gobble#4". In order to accept an anchor, there must be a node at the given location}{}
        \fi
    \fi
    \next
}

\def\sseq@tikz@@to@or@edge@@coordinate(#1){%
  \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
    \def\tikztotarget{sseq@{#1}}
  \else
    \def\tikztotarget{#1}
  \fi
  \tikz@to@or@edge@function%
}
