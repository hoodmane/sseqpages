%%
%
% Sseqpages 0.9
% A package for drawing spectral sequences
% Written by Hood Chatham
%
%%

% TODO:
% manual
%
% Add option "update existing" or something and make an error message if \sseqdata is given with the same name but no "update" option or vice versa.
% Error if "keep changes" is passed, but no name
%% Fix bug with \sseqset used inside sseqpage environment
%% figure out if we can delete first pass/differential/ and /first pass/structline. what's going on with handle quote/.code=\sseq@needstikztrue?
%
% improve axes options? allow axis to be centered on coordinate or centered between coordinates
% add error checking / improve robustness of modified tikz code
% User interface to control arrow head for edges that go off page (option to turn ellipses off)
% named standard offset patterns with options
% automated grids

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{sseqpages}

\newif\ifsseq@versionwarn

\RequirePackage{tikz}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usetikzlibrary{positioning}
\usetikzlibrary{intersections}
\usepgflibrary{arrows.meta}

\def\sseq@authorname#1{Hood Chatham}
\def\sseq@authoremail#1{hood@mit.edu}


\DeclareOption{versionwarn}{\sseq@versionwarntrue}
\ProcessOptions\relax
\@ifpackagelater{tikz}{2015/07/08}{%
    \@ifpackagelater{tikz}{2015/08/08}{%
    \ifsseq@versionwarn
        \expandafter\PackageWarning
     \else
        \expandafter\PackageError
     \fi
     {sseqpages}{You are using a version of Tikz later than the version sseqpages was developed for. Something might go wrong. Please say
     '\string\usepackage[version warn]{sseqpages}' to suppress this error message and email me at \sseq@authoremail{} if you find any bugs}{}
    }{%
        % Current version of tikz
    }
}{%
    \ifsseq@versionwarn
        \PackageWarning{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a.}
     \else
        \PackageError{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a. Please say
        '\string\usepackage[version warn]{sseqpages}' to suppress this error message, and email me at \sseq@authoremail{} to let me know whether sseqpages works with your version of Tikz. Or just update Tikz}{}
     \fi

}

% Ensure \@xp and \@nx have the correct values in case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand
\def\@xptwo{\@xp\@xp\@xp}
\def\@xpthree{\@xp\@xp\@xp\@xp\@xp\@xp\@xp}

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@eval#1{\bgroup\edef\sseq@temp{#1}\@xp\egroup\sseq@temp}% I got this from sseq.sty
\def\sseq@eval@show#1{\bgroup\edef\sseq@temp{#1}\show\sseq@temp\@xp\egroup\sseq@temp}

\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords
\def\sseq@uptocomma#1,#2\sseq@nil{#1}
\def\sseq@fullcoord@to@partialcoord(#1,#2,#3){(#1,#2)}
\def\sseq@fullcoord@to@partialcoordb(#1){\sseq@fullcoord@to@partialcoordb@#1,\@nil}
\def\sseq@fullcoord@to@partialcoordb@#1,#2,#3\@nil{{#1cm}{#2cm}}
\def\sseq@fullcoord@lastelt(#1,#2,#3){#3}


%% Declarations
\newif\ifsseq@needstikz
\newif\ifsseq@classlabel
\newif\ifsseq@outofrange
\newif\ifsseq@keepchanges
\newif\ifsseq@hasname
\newif\ifsseq@thispage
\newif\ifsseq@globaldetone
\newif\ifsseq@drawedge
\newif\ifsseq@draworphanedges
\sseq@drawedgetrue

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@scopeoptions
\newtoks\sseq@thislabelstyle

\newcount\sseq@anonsseqcount
\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@featurecount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempcountb
\newcount\sseq@tempx
\newcount\sseq@tempy
\newcount\sseq@tempxb
\newcount\sseq@tempyb
\newdimen\sseq@tempxdim
\newdimen\sseq@tempydim
\newdimen\sseq@tempxadim
\newdimen\sseq@tempyadim
\newdimen\sseq@tempxbdim
\newdimen\sseq@tempybdim
\sseq@context@depth\z@
\sseq@context@tempcount\z@
\sseq@featurecount\z@
\sseq@x\z@ \sseq@y\z@
\sseq@tempcount\z@


\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii

%%% Commands to help the user define "groups" of commands to be reused
\def\sseqnewgroup#1{\@ifnextchar[{\sseqnewgroup@#1}{\sseqnewgroup@#1[0]}}%]
\long\def\sseqnewgroup@#1[#2]#3{\sseqnewcmd@@#1(\sseq@macrox,\sseq@macroy)[#2]{\begin{scope}[xshift=\sseq@macrox,yshift=\sseq@macroy,\options]#3\end{scope}}}
\def\sseqnewcmd#1{\@ifnextchar({\sseqnewcmd@#1}{\sseqnewcmd@#1(\x,\y)}}%)
\def\sseqnewcmd@#1(#2,#3){\@ifnextchar[{\sseqnewcmd@@#1(#2,#3)}{\sseqnewcmd@@#1(#2,#3)[0]}}%]
\bgroup\lccode`\*=`\#\lowercase{\egroup
    \long\def\sseqnewcmd@@#1(#2,#3)[#4]#5{%
        \@ifundefined{\sseq@macroname #1}{}{%
            \sseq@error{%
                A command named \string#1\sseq@macroname\ already exists. You can only use \string\sseqnewgroup\sseq@macroname\
                and \string\sseqnewgroup\sseq@macroname\ to define new commands.
            }{}%
        }%
        \ifnum#4>6 \sseq@error{Commands defined using '\@nx\sseqnewcmd' can take at most six arguments}\fi
        \edef\helpera{\@xp\@nx\csname \sseq@macroname#1@\endcsname}%
        \edef\helperb{\@xp\@nx\csname \sseq@macroname#1@@\endcsname}%
        \xdef#1{\@nx\@ifnextchar[{\@xp\@nx\helpera}{\@xp\@nx\helpera[]}}%
        \@xp\xdef\helpera[##1](##2,##3){\@xp\@nx\helperb{##1}{##2}{##3}}%
        \def\temp##1##2##3##4##5##6{#5}%
        \sseq@temptoks\@xp{\temp\ppfour\ppfive\ppsix\ppseven\ppeight\ppnine}%
        \bgroup
            \aftergroup\@xp\aftergroup\edef\aftergroup\helperb\aftergroup##\aftergroup1\aftergroup##\aftergroup2\aftergroup##\aftergroup3%
            \ifnum#4>0\relax
                \sseq@tempcount=0\relax
                \sseq@tempcountb=3\relax
                \loop
                    \advance\sseq@tempcount1\relax\advance\sseq@tempcountb1\relax
                    \aftergroup####\@xp\aftergroup\the\sseq@tempcountb
                \ifnum\sseq@tempcount<#4\repeat
            \fi
            \aftergroup{%
                \aftergroup\the\aftergroup\sseq@temptoks
            \aftergroup}%
        \egroup
        \@xp\patchcmd\helperb{\options}{*1}{}{}%
        \@xp\sseq@patchrepeat\helperb{#2}{*2}%
        \@xp\sseq@patchrepeat\helperb{#3}{*3}%
        \@xp\sseq@patchrepeat\helperb{\ppfour}{*4}%
        \@xp\sseq@patchrepeat\helperb{\ppfive}{*5}%
        \@xp\sseq@patchrepeat\helperb{\ppsix}{*6}%
        \@xp\sseq@patchrepeat\helperb{\ppseven}{*7}%
        \@xp\sseq@patchrepeat\helperb{\ppeight}{*8}%
        \@xp\sseq@patchrepeat\helperb{\ppnine}{*9}%
        \sseq@eval{\global\let\@xp\@nx\helperb\@xp\@nx\helperb}
    }
}
\def\sseq@patchrepeat#1#2#3{\patchcmd#1{#2}{#3}{\sseq@patchrepeat#1{#2}{#3}}{}}


%%% Load/store
% These are attributes that come with a given spectral sequence (by name)
% All of these values are loaded at the beginning of sseqpage (and of sseqdata if an existing sseq is being modified).
% They are then stored together at the end of sseqdata (and of sseqpage if "keep changes" option is present).
\def\sseq@storelist{}
\def\sseq@storelist@setdefaults{}
\def\sseq@addtostorelist#1#2{%
    \@xp\def\@xp\sseq@storelist\@xp{\sseq@storelist\\#1}%
    \sseq@temptoks\@xp{\sseq@storelist@setdefaults}%
    \edef\sseq@storelist@setdefaults{\the\sseq@temptoks \let\@nx#1\@xp\@nx\csname \sseq@macroname#1@default\endcsname}%
    \@xp\def\csname\sseq@macroname#1@default\endcsname{#2}%
}
\def\sseq@addiftostorelist#1{\sseq@addiftostorelistopt{#1}{false}}
\def\sseq@addiftostorelist@truedefault#1{\sseq@addiftostorelistopt{#1}{true}}
\def\sseq@addiftostorelistopt#1#2{%
    \@xp\newif\csname ifsseq@#1\endcsname
    \@xp\def\@xp\sseq@storelist\@xp{\sseq@storelist\sseq@storelistif{#1}}%
    \@xp\def\@xp\sseq@storelist@setdefaults\@xp{\sseq@storelist@setdefaults\@xp\global\csname sseq@#1#2\endcsname}%
}

% transfer data about the current spectral sequence between \<command> and \<command><sseqname>
\def\sseq@storelist@store#1{\edef\sseq@temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\sseq@temp}
\def\sseq@storelist@get#1{\edef\sseq@temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\sseq@temp}

\def\sseq@storelistif@store#1{%
    \@xp\edef\csname sseq@storeif@#1\endcsname{\csname ifsseq@#1\endcsname \@xp\@nx\csname sseq@#1true\endcsname\else\@xp\@nx\csname sseq@#1false\endcsname\fi}%
    \@xp\sseq@storelist@store\csname sseq@storeif@#1\endcsname
}
\def\sseq@storelistif@get#1{
    \@xp\sseq@storelist@get\csname sseq@storeif@#1\endcsname
    \csname sseq@storeif@#1\endcsname
}

\def\sseq@storecmds{\let\\\sseq@storelist@store\let\sseq@storelistif\sseq@storelistif@store\sseq@storelist}
\def\sseq@getcmds{\let\\\sseq@storelist@get\let\sseq@storelistif\sseq@storelistif@get\sseq@storelist}

%%% New "poor man's OOP" Load/Store
\def\sseq@obj@fullname#1{sseq.\sseq@thename.#1}
\def\sseq@obj#1{\csname sseq.\sseq@thename.#1\endcsname}
\def\sseq@obj@gdef#1{\@xptwo\gdef\sseq@obj{#1}}
\def\sseq@obj@xdef#1{\@xptwo\xdef\sseq@obj{#1}}
\def\sseq@obj@xodef#1{\@xp\gdef\csname \sseq@obj@fullname{#1}\@xp\endcsname\@xp}
\def\sseq@obj@let#1{\@xptwo\let\sseq@obj{#1}}
\def\sseq@obj@gletcsname#1#2{\global\@xp\let\csname\sseq@obj@fullname{#1}\@xp\endcsname\csname#2\endcsname}
\def\sseq@obj@gletobj#1#2{\global\@xp\let\csname\sseq@obj@fullname{#1}\@xp\endcsname\csname\sseq@obj@fullname{#1}\endcsname}
\def\sseq@obj@undef#1{\@xptwo\let\sseq@obj{#1}\relax}
\def\sseq@obj@show#1{\@xptwo\show\sseq@obj{#1}}
\def\sseq@obj@ifundef#1#2#3{\@ifundefined{\sseq@obj@fullname{#1}}{#2}{#3}}
\def\sseq@obj@inc#1{\bgroup\sseq@tempcount\sseq@obj{#1}\relax\advance\sseq@tempcount1\relax\sseq@obj@xdef{#1}{\the\sseq@tempcount}\egroup}
\def\sseq@obj@gaddto#1#2{\@xptwo\sseq@g@addto@macro\sseq@obj{#1}{#2}} % TODO: either gaddto or g@addto
\def\sseq@obj@xaddto#1#2{\@xptwo\sseq@x@addto@macro\sseq@obj{#1}{#2}}
\def\sseq@obj@gdeforaddto#1#2{\@xptwo\sseq@g@deforaddto@macro\sseq@obj{#1}{#2}}
\def\sseq@obj@xdeforaddto#1#2{\@xptwo\sseq@x@deforaddto@macro\sseq@obj{#1}{#2}}
\def\sseq@obj@gaddtolist#1#2{\@xptwo\sseq@g@addto@macro\sseq@obj{#1}{\\{#2}}}
\def\sseq@obj@xaddtolist#1#2{\@xptwo\sseq@x@addto@macro\sseq@obj{#1}{\@nx\\{#2}}}
\def\sseq@obj@map#1#2{\def\\##1{#2}\sseq@obj{#1}}

\def\sseq@obj@new#1{
    \sseq@obj@xdef{#1.page}{\sseq@infinity}
}

\def\sseq@obj@setpageminrec#1#2{% not really recursive.
    \sseq@obj@setpagemin{#1[\sseq@obj{#1.num}]}{#2}
    \sseq@obj@map{#1[\sseq@obj{#1.num}].dependencies}{
        \sseq@obj@setpagemin{##1}{#2}
    }
}
\def\sseq@obj@setpageminrectemp#1#2{
    \sseq@cleanup@obj{#1[\sseq@obj{#1.num}].page}
    \sseq@obj@setpagemin{#1}{#2}
    \sseq@obj@map{#1[\sseq@obj{#1.num}].dependencies}{
        \sseq@cleanup@obj{##1.page}
        \sseq@obj@setpagemin{##1}{#2}
    }
}
\def\sseq@obj@setpagemin#1#2{
    \ifnum\sseq@obj{#1.page}>#2\relax
        \sseq@obj@xdef{#1.page}{#2}
    \fi
}


%%% add to macro commands
%% \sseq@--@--addto@macro and friends.
% My own variants of \pgfutil@g@addto@macro.
% \sseq@x@addto@macro recursively expands the argument and then adds it.
% \sseq@g/x@deforaddto@macro checks first whether the macro is defined or not, if not it used \gdef or \xdef, else it uses \sseq@g/x@addto@macro
% The "ctx" variants are \let equal to the foreach versions when inside of \foreach or when the context command (not named yet) is used
% The "noctx" variants never are set equal to the foreach versions. These are primarily for use in defining internals, to prevent infinite loops
% The standard variants are \def'd to expand to a "ctx" variant when the "use context" option is requested
% Except now "use context" is gone, so they are always def'd to the ctx variant
% They also add saved state information to the macro the first time they add data to that macro
\def\sseq@g@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1#2}\xdef#1{\the\pgfutil@toks@}\endgroup} % copy of \pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} % let #2 be expanded

\let\sseq@g@addto@macro@ctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@ctx\sseq@x@addto@macro
\let\sseq@g@addto@macro@noctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@noctx\sseq@x@addto@macro


\def\sseq@g@deforaddto@macro#1{\@ifundefined{#1}{\@xp\gdef\csname#1\endcsname}{\@xp\sseq@g@addto@macro@noctx\csname#1\endcsname}}
\def\sseq@x@deforaddto@macro#1{\@ifundefined{#1}{\@xp\xdef\csname#1\endcsname}{\@xp\sseq@x@addto@macro@noctx\csname#1\endcsname}}

\let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro
\let\sseq@g@deforaddto@macro@noctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@noctx\sseq@x@deforaddto@macro


\def\sseq@g@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@g@addto@macro@noctx#1%
}

\def\sseq@x@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@x@addto@macro@noctx#1%
}

\def\sseq@g@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@g@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@x@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@x@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@gx@addto@macro@foreach@#1{%
    \@ifundefined{sseq@context@\sseq@macroname#1}%
        {\sseq@context@tempcount=0\relax}%
        {\sseq@context@tempcount=\csname sseq@context@\sseq@macroname#1\endcsname\relax}%
    \ifnum\sseq@context@tempcount<\sseq@context@depth\relax %
        \loop %
            \advance\sseq@context@tempcount1\relax
            \sseq@for@addsavedtoksntomacro{\the\sseq@context@tempcount}{#1}%
        \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
        \@xp\edef\csname sseq@context@\sseq@macroname#1\endcsname{\the\sseq@context@depth}%
    \fi %
}

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@addtosavedtoks{\@xp\sseq@g@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@xaddtosavedtoks{\@xp\sseq@x@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@addsavedtoksntomacro#1#2{\@xp\@xp\@xp\sseq@g@addto@macro@noctx\@xp\@xp\@xp#2\@xp\@xp\@xp{\csname sseq@for@savedtoks#1\endcsname}}

\def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}%
\def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}%
\def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}%
\def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}

\def\sseq@g@addtosavedpaths{\@xp\sseq@g@addto@macro\sseq@savedpaths}
\def\sseq@x@addtosavedpaths{\@xp\sseq@x@addto@macro\sseq@savedpaths}
\def\sseq@g@addtosavedpaths@ctx{\@xp\sseq@g@addto@macro@ctx\sseq@savedpaths}
\def\sseq@x@addtosavedpaths@ctx{\@xp\sseq@x@addto@macro@ctx\sseq@savedpaths}

\def\sseq@tempsavedpaths{}
\def\sseq@savedpaths@initialize{\sseq@obj@gdef{savedpaths}{}}
\def\sseq@savedpaths@addclass#1{\sseq@obj@xaddto{savedpaths}{\@nx\sseq@class@draw@ifpage{#1}}}
\def\sseq@savedpaths@adddifferential#1{\sseq@obj@xaddto{savedpaths}{\@nx\sseq@differential@draw@ifpage{#1}}}
\def\sseq@savedpaths@addstructline#1{\sseq@obj@xaddto{savedpaths}{\@nx\sseq@structline@draw@ifpage{#1}}}
\def\sseq@savedpaths@addoption{\sseq@obj@gaddto{savedpaths}}
\def\sseq@savedpaths@addtikz{\sseq@obj@gaddto{savedpaths}}

\def\sseq@tempsavedpaths@addclass#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@class@draw@ifpage{#1}}}
\def\sseq@tempsavedpaths@adddifferential#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@differential@draw@ifpage{#1}}}
\def\sseq@tempsavedpaths@addstructline#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@structline@draw@ifpage{#1}}}
\def\sseq@tempsavedpaths@addoption{\sseq@g@addto@macro\sseq@tempsavedpaths}
\def\sseq@tempsavedpaths@addtikz{\sseq@g@addto@macro\sseq@tempsavedpaths}

\def\sseq@usesavedpaths{
    \sseq@obj{savedpaths}
    \sseq@tempsavedpaths
    \gdef\sseq@tempsavedpaths{}
}


\def\sseq@obj@ifchanged#1#2#3{\sseq@obj@ifundef{#1.changed}{#3}{#2}}
\def\sseq@obj@changedtrue#1{\sseq@obj@gdef{#1.changed}{}}
\def\sseq@obj@changedfalse#1{\sseq@obj@undef{#1.changed}}

\def\sseq@cleanup@gadd{\sseq@g@addto@macro\sseq@pagecleanup}
\def\sseq@cleanup@xadd{\sseq@x@addto@macro\sseq@pagecleanup}

\def\sseq@cleanup@obj#1{
    \ifsseq@keepchanges\else
        \sseq@obj@ifchanged{#1}{}{
            \sseq@obj@changedtrue{#1}
            \sseq@temptoks\@xpthree{\sseq@obj{#1}}
            \sseq@cleanup@xadd{
                \@nx\sseq@obj@gdef{#1}{\the\sseq@temptoks}
                \@nx\sseq@obj@changedfalse{#1}
            }
        }
    \fi
}

%%%% Tikz modifications

%%% Context -- make sure \foreach doesn't break when used with sseqpages commands that defer evaluation
% TODO: robustify by copying pgffor wholesale?
\newcount\sseq@contextcount
\def\sseq@addtolocalcontext#1{%
    \global\advance\sseq@contextcount1\relax%
    \@xp\global\@xp\let\csname sseq@context@save@\sseq@macroname#1\the\sseq@contextcount\endcsname#1%
    \sseq@for@xaddtosavedtoks{\let\@nx#1\@xp\@nx\csname sseq@context@save@\sseq@macroname#1\the\sseq@contextcount\endcsname}%
}
\def\sseq@addtoglobalcontext#1{%
    \@ifundefined{sseq@context@save@\sseq@macroname#1}{%
        \@xp\global\@xp\let\csname sseq@context@save@\sseq@macroname#1\endcsname#1%
        \sseq@x@addto@macro\sseq@globalcontext{\let\@nx#1\@xp\@nx\csname sseq@context@save@\sseq@macroname#1\endcsname}%
    }{%
        \sseq@error{You can only use the \string\addtocontext\sseq@macroname\ command once on the command \string#1\sseq@macroname\
            outside of a context environment or \string\foreach\sseq@macroname\ loop%
        }%
    }%
}
\let\sseq@addtocontext\sseq@addtoglobalcontext

\def\sseq@context{
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \let\addtocontext\sseq@addtolocalcontext
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\sseq@addtostorelist\sseq@globalcontext{}

% Patch \foreach to use sseq@context
\def\sseq@pgffor@@vars@opt[#1]{\pgfkeys{/tikz/sseqpages/foreach/.cd,#1}\pgffor@vars}
\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{%
    \let\pgffor@@vars@opt\sseq@pgffor@@vars@opt
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \let\addtocontext\sseq@addtolocalcontext
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\def\sseq@error@fornopatch{\sseq@error{Internal error: failed to patch \string\foreach. Contact the package author at \sseq@authoremail{}}}

\patchcmd\sseq@pgffor@invokebody % store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@doloop % store setting before
    {\ifx\pgffor@assign@before@code}
    {\sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}%
     \ifx\pgffor@assign@before@code}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@invokebody % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@doloop % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\sseq@error@fornopatch}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@addtosavedtoks{\def#2{#4}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\sseq@error@fornopatch}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\sseq@error@fornopatch}

\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@xaddtosavedtoks{\def\@nx#1{\the#2}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@xaddtosavedtoks\@xp{\@xp\def\@xp#1\@xp{#2}}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@xaddtosavedtoks{\def\@nx#2{#1}}}}
    {}{\sseq@error@fornopatch}


\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@currentvar{\pgffor@temp}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@once@expanded}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@expanded}}
    {}{\sseq@error@fornopatch}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\sseq@error@fornopatch}

%% Redo tikz parsing rules for interpreting coordinates
% We want to intepret (x,y) as the name of a node.		
%
% Original behavior:
% The original parsing rule said roughly:
%   if there's a cs: treat it like a coordinate shift
%     if there's the word intersection: treat it as an intersection
%       ...
%        if there's a comma treat it as a literal coordinate
%          else treat it as the name of a node
%
% We replace the second to last step with:
%    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%      if there is such a node, treat it as refering to sseq@{x,y}
%      else treat it as a literal coordinate
%
% Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{%
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}


\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \sseq@eval{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}%
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{%
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}%
    \@xp\sseq@iffullcoord\@xp(\temp){}{%
        \sseq@obj@ifundef{partcoord.(\temp).numnodes}{}%
            {\ifnum\sseq@obj{partcoord.(\temp).numnodes}=1\relax\edef\temp{\temp,1}\fi}%
            %{\edef\temp{\temp,\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname}}
    }%
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid % Check if a node with name sseq@{x,y} is defined in this picture
        \def\tikztotarget{sseq@{\temp}}% fixes the bend left and bend right options (probably others)
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}%
    \else %( % No such node exists
        \ifx&#4& % make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3})}% Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor '\@gobble#4'. In order to accept an anchor, there must be a node at the given location}{}%
        \fi
    \fi
    \next
}


%%%% Internal utilities
\def\sseq@iffullcoord(#1){\@xp\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

% only works for full coordinates
\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){%
    \sseq@obj@ifundef{partcoord.(#1,#2).numnodes}%
        {\@firstoftwo}%
        {\ifnum#3<\sseq@obj{partcoord.(#1,#2).numnodespp}\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}%
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\sseq@obj@ifundef{cord.(#1).death}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\sseq@obj{coord.(#1).death}}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\sseq@obj@xdef{coord.(#1).death}}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\sseq@obj@undef{coord.(#1).death}}

%% \sseq@whichclass -- Find out which class an index indicates
% if the index is positive, just check that it is within bounds
% if the index is negative, return (number of nodes at (x,y)) - index + 1
% if index is empty, return 1 (should it be -1?)
%
% #1 -- output variable
% #2 -- x coordinate
% #3 -- y coordinate
% #4 -- index
% #5 -- calling command (for error messages)
\def\sseq@whichclass#1#2#3#4#5{%
    \edef#1{#4}%
    \ifx#1\pgfutil@empty % If no index is provided, just use 1 TODO: Maybe we should use -1?
        \edef#1{1}%
    \else
        \ifnum#4<0% Negative case -- why this command exists
            \sseq@obj@ifundef{partcoord.(#2,#3).numnodes}{
                \sseq@error{Error: negative index #4 provided for #5 but no classes yet exist in #5 position (#2,#3).
                    Negative indices count from the most recent class in the given position; in particular, there must be at least one existing class}{}
            }{%
                \sseq@tempcount=\sseq@obj{partcoord.(#2,#3).numnodes}
                \advance\sseq@tempcount#4\relax
                \advance\sseq@tempcount1\relax
                \ifnum\sseq@tempcount<1\relax
                    \sseq@error{Error: index #4 provided for the #5 is out of bounds -- fewer than \@gobble#4 classes exist at #5 position (#2,#3)}{}
                \fi
                \edef#1{\the\sseq@tempcount}%
            }%
        \fi
    \fi % TODO: Check here whether the given class is dead and throw an error
}

%% Parsers
% These are very internal commands. They work. I should probably never touch or look at them again.

% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\pgfmathparse{#2}\edef\sseq@temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\sseq@temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


%% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
% This command is primarily to set up the weird syntax of \d, but it gets used in some other places because it already existed.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax
    \ifnum\sseq@commacount<4 % This causes an error without a space I think?
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1\relax
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%%% Set up keys
\def\sseqset{\pgfqkeys{/tikz/sseqpages/global/default}}
\def\sseqset@inprogress{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@set{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\edef\sseq@temp{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname={\the\sseq@temptoks}}}\sseq@temp}

\pgfkeys{%
    /tikz/sseqpages/.is family,
    /tikz/sseqpages/.unknown/.code={\sseq@passoptionto{/tikz}},
    % \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    /tikz/sseqpages/global/.unknown/.code={%
        \let\sseq@tempa\pgfkeyscurrentname
        \let\sseq@tempb\pgfkeyscurrentvalue
        \pgfkeysifdefined{/tikz/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/tikz/\pgfkeyscurrentname}{}{%
            \pgfkeysifdefined{/tikz/sseqpages/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/tikz/sseqpages/\pgfkeyscurrentname}{}{%
                \sseq@error{Undefined global option '\pgfkeyscurrentname\@xp\ifx\pgfkeyscurrentvalue\pgfkeysnovalue\else=\pgfkeyscurrentvalue\fi'}%
            }}%
        }}%
        \pgfkeysalso{{\sseq@currentoptionpath} options/.append style/.expand twice={\@xp\sseq@tempa\@xp=\@xp{\sseq@tempb}}}%
    },
    /tikz/sseqpages/global/default/.unknown/.code={%
        \let\sseq@currentoptionpath@save\sseq@currentoptionpath
        \def\sseq@currentoptionpath{default}%
        \sseq@passoptionto{/tikz/sseqpages/global}
        \let\sseq@currentoptionpath\sseq@currentoptionpath@save
    },
    /tikz/sseqpages/global/{default} options/.code={},
    /tikz/sseqpages/global/name only/.unknown/.code={},
    /tikz/sseqpages/first pass/.unknown/.code={},
    /tikz/sseqpages/first pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/class/.unknown/.code={%
        \expandafter\ifx\csname pgf@sh@s@\pgfkeyscurrentname\endcsname\relax % is it the name of a shape?
            \sseq@passoptionto{/tikz/sseqpages/first pass}%
        \else
            \edef\tikz@shape{\pgfkeyscurrentname}% if so, store it
        \fi
    },
    /tikz/sseqpages/first pass/class/labels/.unknown/.code={},
    /tikz/sseqpages/first pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/structline/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/second pass/.is family,
    /tikz/sseqpages/second pass/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages}},
    /tikz/sseqpages/second pass/scope/.is family,
    /tikz/sseqpages/second pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/class/.is family,
    /tikz/sseqpages/second pass/class/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/class/labels/.is family,
    /tikz/sseqpages/second pass/class/labels/.unknown/.code={\sseq@passoptionto{/tikz}},
    /tikz/sseqpages/second pass/class/node texts/.is family,
    /tikz/sseqpages/second pass/class/node texts/.unknown/.code={\sseq@passoptionto{/tikz}},
    /tikz/sseqpages/second pass/differential/.is family,
    /tikz/sseqpages/second pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/structline/.is family,
    /tikz/sseqpages/second pass/structline/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/tikz primitives/.is family,
    /tikz/sseqpages/second pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    % One off directories
    /tikz/sseqpages/foreach/.unknown/.code={\sseq@passoptionto{/pgf/foreach}},
    /tikz/sseqpages/class placement/.unknown/.code={\sseq@passoptionto{/tikz}}
}

\pgfqkeys{/tikz/sseqpages/first pass/class}{shape/.code={\edef\tikz@shape{\pgfkeyscurrentname}}} % shape=whatever shape passing


%% label directions
\def\sseq@labeldirectionlist{\\{above}\\{below}\\{left}\\{right}\\{above left}\\{above right}\\{below left}\\{below right}}
\def\sseq@setlabeldirectionkeys#1{
    \@ifnextchar[{\sseq@setlabeldirectionkeys@{#1}}{\sseq@setlabeldirectionkeys@{#1}[/.code]}
}

\def\\#1{\@xp\sseq@addtostorelist\csname sseq@default@#1@distance\endcsname{1ex}}
\sseq@labeldirectionlist
\def\sseq@defaultlabeldistance#1{\csname sseq@default@#1@distance\endcsname}
\def\sseq@setdefaultlabeldistance#1#2{\sseq@savedpaths@addoption{\@xp\def\csname sseq@default@#1@distance\endcsname{#2}}}
\def\sseq@setdefaultlabeldistances#1{\def\\##1{\sseq@setdefaultlabeldistance{##1}{#1}}\sseq@labeldirectionlist}
\def\sseq@savedefaultlabeldistances{
    \def\\##1{
        \sseq@eval{
            \sseq@temptoks@iii{\the\sseq@temptoks@iii\@nx\sseq@setdefaultlabeldistance{##1}{\sseq@defaultlabeldistance{##1}}}
        }
    }
    \sseq@labeldirectionlist
}

\def\sseq@setlabeldirectionkeys@#1[#2]#3{
    \def\sseq@temp##1{#3}
    \sseq@temptoks@ii{}
    \def\\##1{
        \sseq@temptoks\@xp{\sseq@temp{##1}}
        \sseq@eval{\sseq@temptoks@ii{\the\sseq@temptoks@ii##1#2={\the\sseq@temptoks},}}
    }
    \sseq@labeldirectionlist
    \sseq@eval{\@nx\pgfqkeys{#1}{\the\sseq@temptoks@ii}}
}

\sseq@setlabeldirectionkeys{/tikz/sseqpages/first pass/class/labels}{\sseq@classlabeltrue}
\pgfqkeys{/tikz/sseqpages/first pass/class/labels}{% maybe implement multipart node labels this way? No way!
    node/.code={\sseq@classlabelfalse},
    inside/.code={\sseq@classlabelfalse},
}

\sseq@setlabeldirectionkeys{/tikz/sseqpages/second pass/class/labels}{\sseq@class@positionlabel{#1}{##1}}
\sseq@setlabeldirectionkeys{/tikz/sseqpages/second pass/class/labels}[/.default]{\sseq@defaultlabeldistance{#1}}


\pgfqkeys{/tikz/sseqpages/second pass/class/labels}{
    node/.code={},
    inside/.code={}
}

\sseq@setlabeldirectionkeys{/tikz/sseqpages/global}[ label distance/.code]{\sseq@setdefaultlabeldistance{#1}{##1}}
\sseq@setlabeldirectionkeys{/tikz/sseqpages}[ label distance/.code]{\sseq@setdefaultlabeldistance{#1}{##1}}
%\sseq@setlabeldirectionkeys{/tikz/sseqpages}[ label distance/.code]{\sseq@error@optionglobalonly{#1 label distance}}

\pgfqkeys{/tikz/sseqpages/global}{
    label distance/.code={\sseq@setdefaultlabeldistances{#1}}
}
\pgfqkeys{/tikz/sseqpages}{
    label distance/.code={\sseq@setdefaultlabeldistances{#1}}
}

\sseq@setlabeldirectionkeys{/tikz/sseqpages/second pass/class/node texts}{}
\pgfqkeys{/tikz/sseqpages/second pass/class/node texts}{
    node/.code={},
    inside/.code={}
}


\def\sseq@class@positionlabel#1#2{\pgfqkeys{/tikz}{#1=#2 of \sseq@thisnodename.center}}

%% Quote handling
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\def\sseq@handleclassquotes#1#2{% We use this via \let\tikz@quotes@as\sseq@handleclassquotes
    /utils/exec={% so it's called inside \pgfkeysalso{stuff}. Need to surround with /utils/exec={} to get out.
        \begingroup
        \sseq@temptoks{#1}
        \sseq@temptoks@ii{\pgfkeysalso{#2}}
        \def\pgfkeysdefaultpath{/tikz/sseqpages/first pass/class/labels/}
        \the\sseq@labelstyle\the\sseq@classlabelstyle
        \pgfkeysalso{#2}
        \ifsseq@classlabel
            \the\sseq@outerclasslabelstyle
            \sseq@x@addto@macro@noctx\sseq@classlabelnodes{%
                \@nx\ifsseq@needstikz
                    node[
                        /tikz/sseqpages/second pass/class/labels,
                        /utils/exec={
                            \sseq@thelabelstyle\sseq@theclasslabelstyle\sseq@theouterclasslabelstyle\the\sseq@temptoks@ii
                            \@nx\iftikz@fullytransformed\@nx\else
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                         }
                    ]{\the\sseq@temptoks}%
                \@nx\else
                    \@nx\node[
                        /tikz/sseqpages/second pass/class/labels,
                        /utils/exec={
                            \sseq@thelabelstyle\sseq@theclasslabelstyle\sseq@theouterclasslabelstyle\the\sseq@temptoks@ii
                            \@nx\iftikz@fullytransformed\@nx\else
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                         }
                    ]{\the\sseq@temptoks};%
                \@nx\fi
            }%
        \else
            \the\sseq@innerclasslabelstyle
            \pgfkeysalso{#2}
            \gdef\sseq@classnodetext{#1}%
            \xdef\sseq@classnodetextoptions{
                \def\@nx\pgfkeysdefaultpath{/tikz/sseqpages/second pass/class/node texts/}
                \sseq@thelabelstyle\sseq@theinnerclasslabelstyle\the\sseq@temptoks@ii
            }%
        \fi
        \endgroup
    }%
}
\def\sseq@classnodetext{}
\def\sseq@classnodetextoptions{}
\def\sseq@classlabelnodes{}

\pgfkeys{%
    /tikz/sseqpages/first pass/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /tikz/sseqpages/first pass/class/handle quote/.code={%
        \begingroup
        \let\tikz@quotes@as\sseq@handleclassquotes
        \tikz@quote@parser{#1}
        \endgroup
    },
    /tikz/sseqpages/first pass/differential/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/first pass/structline/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/second pass/class/handle quote/.code={},
    /tikz/sseqpages/handle quote/.code={\tikzset{every to/.append style={#1}}}
}

%% Parsing, background vs foreground, and context
\def\sseq@standardparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@old
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transformations
    \let\sseq@shifttransform\sseq@okaytransform
    \let\sseq@firstpass@shifttransform\@gobbletwo
    \def\class{\sseq@error{You cannot use \@nx\class\sseq@macroname in standard parse mode}{}}%
    \def\replaceclass{\sseq@error{You cannot use \@nx\replaceclass\sseq@macroname in standard parse mode}{}}%
    \def\d{\sseq@error{You cannot use \@nx\d\sseq@macroname in standard parse mode}{}}%
    \def\structline{\sseq@error{You cannot use \@nx\structline\sseq@macroname in standard parse mode}{}}%
}

\def\sseq@nodeparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform
    \let\class\sseq@class
    \let\replaceclass\sseq@replaceclass
    \let\d\sseq@d
    \let\structline\sseq@structline
}

\def\sseq@errortikzprimsonly#1{\sseq@error{You can only use '#1' as an option for tikz primitives, not for \@nx\class, \@nx\replaceclass\sseq@macroname, \@nx\d, or \@nx\structline}{}}

\sseq@set{%
    standard parse/.code={\sseq@standardparse},
    node parse/.code={\sseq@nodeparse},
    background/.code={\sseq@standardparse},
    foreground/.code={\sseq@nodeparse}
}


\pgfqkeys{/tikz/sseqpages/first pass}{%
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform},
    background/.code={\let\sseq@savedforegroundpaths\sseq@savedpaths\def\sseq@savedpaths{\sseq@savedbackgroundpaths}\pgfkeysalso{standard parse}},
    foreground/.code={\let\sseq@savedpaths\sseq@savedforegroundpaths\pgfkeysalso{node parse}}% is this okay?
}


\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/first pass/differential}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ % This is only for scope and tikz primitives, but in other cases, it emits an error on first pass.
    needs tikz/.code={},
    class/transform shape/.code={\pgfsettransform{\savetransform}\pgfqkeys{/tikz/sseqpages/class transform}{transform shape}}
}

%% Needs tikz
% Force \class or \d to fall back to using tikz to render their output
% Rather than using the faster direct \pgf primitives (largely copied from tikz to maximize compatibility)
% Drawing with tikz is slower, but I don't want to reimplement these features


% multipart shapes and alignment to be done with tikz
\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    circle split/.code=\sseq@needstikztrue,
    circle solidus/.code=\sseq@needstikztrue,
    ellipse split/.code=\sseq@needstikztrue,
    rectangle split/.code=\sseq@needstikztrue,
    align/.code=\sseq@needstikztrue,
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\class' command. You should use 'alias' instead}{}}
}

\def\sseq@needstikzandpass#1#2{\sseq@needstikzandpass@{#1}#2,\@nil}
\def\sseq@needstikzandpass@#1#2,{%
    \pgfqkeys{#1}{#2/.code={\sseq@needstikztrue\pgfqkeys{/tikz}{#2}}}%
    \@ifnextchar\@nil{\@gobble}{\sseq@needstikzandpass@}%
}

\pgfqkeys{/tikz/sseqpages}{needs tikz/.code=\sseq@needstikztrue}
\sseq@needstikzandpass{/tikz/sseqpages}{%
    shade, blend mode, pattern, path picture, path fading, decorate, pin, label
}

\sseq@needstikzandpass{/tikz/sseqpages/second pass/differential}{
    bend left, bend right, in, out, controls, in control, out control,
    loop, loop above, loop below, loop left, loop right % maybe delete the loops and replace them with errors? It's pretty pointless to use these.
}

\sseq@needstikzandpass{/tikz/sseqpages/second pass/structline}{
    bend left, bend right, in, out, controls, in control, out control,
    loop, loop above, loop below, loop left, loop right % maybe delete the loops and replace them with errors? It's pretty pointless to use these.
}

\pgfqkeys{/tikz/sseqpages/second pass/struct line}{
    source anchor/.store in=\sseq@edgesourceanchor,
    target anchor/.store in=\sseq@edgetargetanchor
}
\pgfqkeys{/tikz/sseqpages/second pass/differential}{
    source anchor/.store in=\sseq@edgesourceanchor,
    target anchor/.store in=\sseq@edgetargetanchor
}

%% Style options
\def\sseq@stylelist{}
\def\sseq@restorestylelist{}
\def\sseq@clearstyles{}
\bgroup\catcode` =\active
\gdef\sseq@activespace{ }
\egroup
\def\sseq@newstyles{\bgroup\catcode` =\active\sseq@newstyles@}
\def\sseq@newstyles@#1{\egroup\sseq@newstyles@@#1\sseq@nil}
\def\sseq@newstyles@@#1,{\sseq@newsseqstyle{#1}\sseq@newstyles@@goblespaces}
\def\sseq@newstyles@@goblespaces{\@xp\@ifnextchar\sseq@activespace{\@xp\sseq@newstyles@@goblespaces\@gobble}{\@ifnextchar\sseq@nil{\@gobble}{\sseq@newstyles@@}}}

\def\sseq@set@newstyle#1{\pgfqkeys{/tikz/sseqpages}{#1}\pgfqkeys{/tikz/sseqpages/global}{#1}\pgfqkeys{/tikz/sseqpages/first pass}{#1}}


\def\sseq@newsseqstyle#1{%
    \@xp\def\sseq@activespace{}
    \edef\sseq@tempcmd{\csname sseq@#1style\endcsname}%
    \@xp\edef\csname sseq@the#1style\endcsname{\@nx\the\sseq@tempcmd\@nx\@nx\@nx\the\sseq@tempcmd}
    \@xp\let\sseq@activespace\space
    \@xp\newtoks\sseq@tempcmd
    \sseq@x@addto@macro@noctx\sseq@stylelist{\sseq@tempcmd{\@nx\the\sseq@tempcmd}}
    \sseq@x@addto@macro@noctx\sseq@restorestylelist{\sseq@temptoks{\@nx\the\sseq@tempcmd}\edef\@nx\@nx\@nx\temp{\sseq@tempcmd{\@nx\@nx\@nx\the\sseq@temptoks\@nx\@nx\@nx\the\sseq@tempcmd}}\@nx\@nx\@nx\temp}%
    \sseq@x@addto@macro@noctx\sseq@clearstyles{\sseq@tempcmd{}}%
    \sseq@set@newstyle{%
        every #1/.ecode={%
            \sseq@tempcmd{\@nx\pgfkeysalso{##1}}%
            \@ifundefined{sseq@thename}{}{%
                \@nx\sseq@savedpaths@addoption{\sseq@tempcmd{\the\sseq@tempcmd}}%
            }%
        },%
        #1s/.ecode={%
            \sseq@tempcmd\@nx\@xp{\@nx\the\sseq@tempcmd\@nx\pgfkeysalso{##1}}%
            \@ifundefined{sseq@thename}{}{%
                \@nx\sseq@savedpaths@addoption{\sseq@tempcmd{\the\sseq@tempcmd}}%
            }%
        }%
    }%
}

\sseq@newstyles{ % Make sure to put a comma after the last entry
    sseq, path, node,
    class, permanent cycle, transient cycle, this page cycle,
    edge, differential, struct line, this page struct line,
    label, class label, inner class label, outer class label, edge label, differential label, struct line label,
}

\sseq@set@newstyle{classes/.style={classs={#1}}}% "class" has a nonstandard plural
\sseq@set@newstyle{
    permanent classes/.code={\pgfkeysalso{permanent cycles={#1}}},
    transient classes/.code={\pgfkeysalso{transient cycles={#1}}},
    this page classes/.code={\pgfkeysalso{this page cycles={#1}}},
    class label position/.code={\pgfkeysalso{class label positions={#1}}}
}%

\sseqset{classes=draw}

%% Global options
\pgfqkeys{/tikz/sseqpages/global/name only}{
    name/.code={\def\sseq@thename{#1}\let\sseqthename\sseq@thename\sseq@hasnametrue},
    name/.value required
}
\pgfqkeys{/tikz/sseqpages/global}{%
    name/.code={},
    page/.code={\ifsseq@hasname\def\sseq@thepage{#1}\let\sseqthepage\sseq@thepage\else\sseq@error{You can't specify a page but no name}{}\fi},
    degree/.code 2 args={\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}\let\d\sseq@d},
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
    xrange/.code 2 args={\sseq@xrange{#1}{#2}},
    yrange/.code 2 args={\sseq@yrange{#1}{#2}},
% axes options:
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    axes gap/.code={\def\sseq@xaxisgap{#1}\def\sseq@yaxisgap{#1}},
    x axis gap/.code={\def\sseq@xaxisgap{#1}},
    x axis gap/.value required,
    y axis gap/.code={\def\sseq@yaxisgap{#1}},
    y axis gap/.value required,
    x axis style/.is choice,
    y axis style/.is choice,
    axes style/.is choice,
    x axis style/border/.code={\sseq@drawxaxistrue\sseq@borderxaxistrue},
    y axis style/border/.code={\sseq@drawyaxistrue\sseq@borderyaxistrue},
    axes style/border/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue\sseq@borderxaxistrue\sseq@borderyaxistrue},
    x axis style/center/.code={
        \sseq@drawxaxistrue\sseq@borderxaxisfalse
        \ifx\sseq@xaxisgap\sseq@xaxisgap@default
            \def\sseq@xaxisgap{0cm}
        \fi
    },
    y axis style/center/.code={\sseq@drawyaxistrue\sseq@borderyaxisfalse\ifx\sseq@yaxisgap\sseq@yaxisgap@default\def\sseq@yaxisgap{0cm}\fi},
    axes style/center/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue\sseq@borderxaxisfalse\sseq@borderyaxisfalse},
    x axis style/none/.code={\sseq@drawxaxisfalse},
    y axis style/none/.code={\sseq@drawyaxisfalse},
    axes style/none/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    x axis origin/.store in=\sseq@xaxisorigin,
    y axis origin/.store in=\sseq@yaxisorigin,
    axes origin/.code={\pgfkeysalso{x axis origin={#1},y axis origin={#1}}},
    no x axis/.code={\sseq@drawxaxisfalse},
    no x axis/.value forbidden,
    draw x axis/.is if=sseq@drawxaxis,
    no y axis/.code={\sseq@drawyaxisfalse},
    no y axis/.value forbidden,
    draw y axis/.is if=sseq@drawyaxis,
    no axes/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    no axes/.value forbidden,
    draw axes/.is choice,
    draw axes/true/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue},
    draw axes/false/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    draw axes/.default=true,
    no x axis labels/.code={\sseq@drawxaxislabelsfalse},
    no x axis labels/.value forbidden,
    draw x axis labels/.is if=sseq@drawxaxislabels,
    no y axis labels/.code={\sseq@drawyaxislabelsfalse},
    no y axis labels/.value forbidden,
    draw y axis labels/.is if=sseq@drawyaxislabels,
    no axes labels/.code={\sseq@drawxaxislabelsfalse\sseq@drawyaxislabelsfalse},
    no axes labels/.value forbidden,
    draw axes labels/.is choice,
    draw axes labels/true/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue},
    draw axes labels/false/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    draw axes labels/.default=true,
    draw differentials/.is if=sseq@drawdifferentials,
    no differentials/.code={\sseq@drawdifferentialsfalse},
    no differentials/.value forbidden,
    draw struct lines/.is if=sseq@drawstructlines,
    no struct lines/.code={\sseq@drawstructlinesfalse},
    no struct lines/.value forbidden,
    draw orphan edges/.is if=sseq@draworphanedges,
    rotate labels/.is if=sseq@rotatelabels,
    label step/.code={\def\sseq@xlabelstep{#1}\def\sseq@ylabelstep{#1}},
    label step/.value required,
    x label step/.store in=\sseq@xlabelstep,
    y label step/.store in=\sseq@ylabelstep,
    class placement transform/.code={%
        \bgroup
        \let\tikz@transform\pgfutil@empty
        \pgfqkeys{/tikz/sseqpages/class placement}{#1}%
        \global\let\sseq@classplacementtransform\tikz@transform
        \egroup
    },
    class placement transform/.value required,
    keep changes/.is if=sseq@keepchanges
}
%
\pgfqkeys{/tikz/sseqpages/global/default}{%
    name/.code={\sseq@error{You cannot set a default name}{}},
    page/.code={\sseq@error{You cannot set a default page}{}},
    degree/.code 2 args={\def\sseq@targetx@default##1{#1}\def\sseq@targety@default##1{#2}\let\d\sseq@d},
    x range/.code 2 args={\sseq@xrange@default{#1}{#2}},
    y range/.code 2 args={\sseq@yrange@default{#1}{#2}},
    xrange/.code 2 args={\sseq@xrange@default{#1}{#2}},
    yrange/.code 2 args={\sseq@yrange@default{#1}{#2}},
% axes options:
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    axes gap/.code={\def\sseq@xaxisgap@default{#1}\def\sseq@yaxisgap@default{#1}},
    x axis gap/.code={\def\sseq@xaxisgap@default{#1}},
    x axis gap/.value required,
    y axis gap/.code={\def\sseq@yaxisgap@default{#1}},
    x label step/.store in=\sseq@xlabelstep@default,
    y label step/.store in=\sseq@ylabelstep@default,
    label step/.code={\def\sseq@xlabelstep@default{#1}\def\sseq@ylabelstep@default{#1}},
    x axis origin/.store in=\sseq@xaxisorigin@default,
    y axis origin/.store in=\sseq@yaxisorigin@default,
    axes origin/.code={\pgfkeysalso{x axis origin={#1},y axis origin={#1}}},
    class placement transform/.code={%
        \bgroup
        \let\tikz@transform\pgfutil@empty
        \pgfqkeys{/tikz/sseqpages/class placement}{#1}%
        \global\let\sseq@classplacementtransform@default\tikz@transform
        \egroup
    },
    class placement transform/.value required,
}

\sseq@addtostorelist\sseq@targetx{}\sseq@addtostorelist\sseq@targety{}
\sseq@addtostorelist\sseq@xaxisgap{0.5cm}\sseq@addtostorelist\sseq@yaxisgap{0.5cm}
\sseq@addiftostorelist@truedefault{drawxaxis}\sseq@addiftostorelist@truedefault{drawyaxis}
\sseq@addiftostorelist@truedefault{drawxaxislabels}\sseq@addiftostorelist@truedefault{drawyaxislabels}
\sseq@addiftostorelist@truedefault{drawdifferentials}\sseq@addiftostorelist@truedefault{drawstructlines}
\sseq@addiftostorelist@truedefault{rotatelabels}
\sseq@addtostorelist\sseq@xlabelstep{1}\sseq@addtostorelist\sseq@ylabelstep{1}
\sseq@addtostorelist\sseq@classplacementtransform{}

\sseq@addiftostorelist@truedefault{borderxaxis}\sseq@addiftostorelist@truedefault{borderyaxis}
\sseq@addtostorelist\sseq@xaxisorigin{0}\sseq@addtostorelist\sseq@yaxisorigin{0}

% Range commands
\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobbletwo % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobbletwo %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

\def\sseq@xrange@default#1#2{%
    \global\let\sseq@xminmax\@gobbletwo % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin@default{#1}%
    \gdef\sseq@xmax@default{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm@default{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp@default{\the\sseq@tempcount}%
}
\def\sseq@yrange@default#1#2{%
    \global\let\sseq@yminmax\@gobbletwo %
    \gdef\sseq@ymin@default{#1}%
    \gdef\sseq@ymax@default{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm@default{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp@default{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1#2{%
    \ifnum#1<\sseq@xmin
        \ifx\sseq@yminmax\@gobbletwo
            \ifnum#2>\sseq@ymin
                \ifnum#2<\sseq@ymax
                    \xdef\sseq@xmin{#1}%
                \fi
            \fi
        \else
            \xdef\sseq@xmin{#1}%
        \fi
    \fi
    \ifnum#1>\sseq@xmax
        \ifx\sseq@yminmax\@gobbletwo
            \ifnum#2>\sseq@ymin
                \ifnum#2<\sseq@ymax
                    \xdef\sseq@xmax{#1}%
                \fi
            \fi
        \else
            \xdef\sseq@xmax{#1}%
        \fi
    \fi
}

\def\sseq@yminmax@active#1#2{%
    \ifnum#2<\sseq@ymin
        \ifx\sseq@xminmax\@gobbletwo
            \ifnum#1>\sseq@xmin
                \ifnum#1<\sseq@xmax
                    \xdef\sseq@ymin{#2}%
                \fi
            \fi
        \else
            \xdef\sseq@ymin{#2}%
        \fi
    \fi
    \ifnum#2>\sseq@ymax
        \ifx\sseq@xminmax\@gobbletwo
            \ifnum#1>\sseq@xmin
                \ifnum#1<\sseq@xmax
                    \xdef\sseq@ymax{#2}%
                \fi
            \fi
        \else
            \xdef\sseq@ymax{#2}%
        \fi
    \fi
}


\sseq@addtostorelist\sseq@xlabelgap{0.5cm}
\sseq@addtostorelist\sseq@ylabelgap{0.5cm}
\sseq@addtostorelist\sseq@xaxis@start@extend{0.9cm}
\sseq@addtostorelist\sseq@yaxis@start@extend{0.9cm}
\sseq@addtostorelist\sseq@xaxis@end@extend{0.5cm}
\sseq@addtostorelist\sseq@yaxis@end@extend{0.5cm}
\sseq@addtostorelist\sseq@xclip@axisgap{0.1cm}
\sseq@addtostorelist\sseq@yclip@axisgap{0.1cm}
\sseq@addtostorelist\sseq@clip@padding@right{0.1cm}
\sseq@addtostorelist\sseq@clip@padding@top{0.1cm}
\sseq@addtostorelist\sseq@clip@padding@left{0.4cm}
\sseq@addtostorelist\sseq@clip@padding@bottom{0.4cm}

\pgfqkeys{/tikz/sseqpages/global}{% TODO: Are these names okay?
    x label gap/.store in=\sseq@xlabelgap,
    y label gap/.store in=\sseq@ylabelgap,
    label gap/.code={\def\sseq@xlabelgap{#1}\def\sseq@ylabelgap{#1}},
    x axis extend start/.store in=\sseq@xaxis@start@extend,
    y axis extend start/.store in=\sseq@yaxis@start@extend,
    x axis extend end/.store in=\sseq@xaxis@end@extend,
    y axis extend end/.store in=\sseq@yaxis@end@extend,
    x clip axis padding/.store in=\sseq@xclip@axisgap,
    y clip axis padding/.store in=\sseq@yclip@axisgap,
    right clip padding/.store in=\sseq@clip@padding@right,
    left clip padding/.store in=\sseq@clip@padding@left,
    top clip padding/.store in=\sseq@clip@padding@top,
    bottom clip padding/.store in=\sseq@clip@padding@bottom
}

\pgfqkeys{/tikz/sseqpages/global/default}{
    x label gap/.store in=\sseq@xlabelgap@default,
    y label gap/.store in=\sseq@xlabelgap@default,
    label gap/.code={\def\sseq@xlabelgap@default{#1}\def\sseq@ylabelgap@default{#1}},
    x axis extend start/.store in=\sseq@xaxis@start@extend@default,
    y axis extend start/.store in=\sseq@yaxis@start@extend@default,
    x axis extend end/.store in=\sseq@xaxis@end@extend@default,
    y axis extend end/.store in=\sseq@yaxis@end@extend@default,
    x clip axis padding/.store in=\sseq@xclip@axisgap@default,
    y clip axis padding/.store in=\sseq@yclip@axisgap@default,
    right clip padding/.store in=\sseq@clip@padding@right@default,
    left clip padding/.store in=\sseq@clip@padding@left@default,
    top clip padding/.store in=\sseq@clip@padding@top@default,
    bottom clip padding/.store in=\sseq@clip@padding@bottom@default
}
% Global transformations
\sseq@globaldetonetrue
\sseq@addtostorelist\sseq@globaldetonetransform{}
\sseq@addtostorelist\sseq@globalrotatetransform{}
\sseq@addtostorelist\sseq@globalscaletransform{}

\def\sseq@globaldetoneoption#1#2{%
    \ifsseq@globaldetone
        \@xp\gdef\@xp\sseq@globaldetonetransform\@xp{\sseq@globaldetonetransform #1}%
        #1
    \else
        \sseq@error{You cannot use the option '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option after using 'xscale', 'yscale', or 'scale'. Please move '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' before any scaling options}
    \fi
}
\def\sseq@globalscaleoption#1{%
    \sseq@globaldetonefalse
    \@xp\gdef\@xp\sseq@globalscaletransform\@xp{\sseq@globalscaletransform#1}#1
}
\pgfqkeys{/tikz/sseqpages/global}{%
    xshift/.code={\sseq@errorillegalasglobal{xshift}},
    yshift/.code={\sseq@errorillegalasglobal{yshift}},
    shift/.code={\sseq@errorillegalasglobal{shift}},
    scale around/.code={\sseq@errorillegalasglobal{scale around}},
    rotate around/.code={\sseq@errorillegalasglobal{rotate around}},
    rotate/.code={%
        \@xp\gdef\@xp\sseq@globalrotatetransform\@xp{\sseq@globalrotatetransform\pgftransformrotate{#1}}%
        \sseq@globaldetoneoption{\pgftransformrotate{#1}}{rotate}%
    },
    rotate/.value required,
    xslant/.code={\sseq@globaldetoneoption{\pgftransformxslant{#1}}{xslant}},
    xslant/.value required,
    yslant/.code={\sseq@globaldetoneoption{\pgftransformyslant{#1}}{yslant}},
    yslant/.value required,
    xmirror/.code={\sseq@globaldetoneoption{\pgftransformxscale{-1}}{xmirror}},
    xmirror/.value forbidden,
    ymirror/.code={\sseq@globaldetoneoption{\pgftransformyscale{-1}}{ymirror}},
    ymirror/.value forbidden,
    xscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax%
            \sseq@error{You said 'xscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'xmirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformxscale{#1}}%
    },
    xscale/.value required,
    yscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax
            \sseq@error{You said 'yscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'ymirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformyscale{#1}}%
    },
    yscale/.value required,
    scale/.code={\sseq@globalscaleoption{\pgftransformscale{#1}}},
    scale/.value required
}

\pgfqkeys{/tikz/sseqpages/class placement}{
    x shift/.code={\sseq@error@noclassplacementshift{x shift}{#1}},
    y shift/.code={\sseq@error@noclassplacementshift{y shift}{#1}},
    shift/.code={\sseq@error@noclassplacementshift{shift}{#1}}
}

\sseq@set{%
    name/.code={\sseq@error@optionglobalonly{name}},
    page/.code={\sseq@error@optionglobalonly{page}},
    x range/.code 2 args={\sseq@error@optionglobalonly{x range}},
    y range/.code 2 args={\sseq@error@optionglobalonly{y range}},
    grid/.code={\sseq@error@optionglobalonly{grid}},
    labels/.code={\sseq@error@optionglobalonly{labels}},
    x labels/.code={\sseq@error@optionglobalonly{x labels}},
    y labels/.code={\sseq@error@optionglobalonly{y labels}},
    label step/.code={\sseq@error@optionglobalonly{labelstep}},
    x label step/.code={\sseq@error@optionglobalonly{x labelstep}},
    y label step/.code={\sseq@error@optionglobalonly{y labelstep}}
}


%% setup for coordinate transformation keys
\sseq@set{%
    x/.code={\sseq@error@optionillegal{x}{#1}{}},
    y/.code={\sseq@error@optionillegal{y}{#1}{}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{xshift}{#1}},
    xshift/.value required,
    yshift/.code={\sseq@shifttransform{yshift}{#1}},
    yshift/.value required,
    shift/.code={\sseq@transform{shift}{#1}},
    shift/.value required,
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    xscale/.value required,
    yscale/.code={\sseq@transform{yscale}{#1}},
    yscale/.value required,
    scale/.code={\sseq@transform{scale}{#1}},
    scale/.value required,
    scale around/.code={\sseq@transform{scale around}{#1}},
    scale around/.value required,
    xslant/.code={\sseq@transform{xslant}{#1}},
    xslant/.value required,
    yslant/.code={\sseq@transform{yslant}{#1}},
    yslant/.value required,
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate/.value required,
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    rotate around/.value required,
    cm/.code={\sseq@transform{cm}{#1}},
    cm/.value required,
    reset cm/.code={\sseq@transform{reset cm}{}},
    reset cm/.value forbidden,
    transform canvas/.code={\sseq@transform{transform canvas}{#1}},
    transform canvas/.value required
}

% Catch shifts on first pass to update \sseq@x, \sseq@y
\pgfqkeys{/tikz/sseqpages/first pass}{%
    xshift/.code={\sseq@firstpass@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@firstpass@shifttransform{yshift}{#1}}
}

\pgfqkeys{/tikz/sseqpages/second pass/class}{%
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages/second pass/differential}{%
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages}{
    description/.code={
        \pgfkeysalso{/tikz/anchor=center}
        \def\sseq@edgeoptionhook{\pgfkeysalso{/tikz/fill=white}}
    }
}
\def\sseq@edgeoptionhook{}


\def\sseq@error@optionillegal#1#2#3{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}%
}

\def\sseq@error@optionglobalonly#1{%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]')%
    }{}%
}

\def\sseq@error@illegalasglobal#1{
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option, but option '#1' is illegal as a global option
    }
}


\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@error@illegaltransform#1#2{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}%
}

\def\sseq@firstpass@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
    }{\sseq@error@illegaltransform{#1}{#2}}%
}
\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform

\def\sseq@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
        \edef\sseq@temp{\@nx\sseq@okaytransform{#1}{#2 cm}}%
        \sseq@temp
    }{\sseq@error@illegaltransform{#1shift}{#2}}%
}

\def\sseq@okayshifttransform#1#2{%
    \pgfmathparse{#2}
    \ifpgfmathunitsdeclared
        \def\temp{/tikz/#1=#2}
    \else
        \def\temp{/tikz/#1=#2cm}
    \fi
    \@xp\pgfkeysalso\@xp{\temp}%
}

\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%%% Command redefinition commands

% copy commands into user namespace by removing sseq@ prefixes
% given a list of commands, \let\thiscommand\sseq@thiscommand on each one
\def\sseq@copycommands#1{\sseq@copycommands@#1\sseq@nil}
\def\sseq@copycommands@#1{%
    \ifx#1\sseq@nil\else % if so, that was the last command in the list
        \@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname
        \@xp\sseq@copycommands@
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@tikzcommands{%
        \clip\coordinate\draw\fill\filldraw
        \graph\matrix\node\path\pattern
        \shade\shadedraw\useasboundingbox
}

\def\sseq@modtikzcommands{%
    \let\scope\sseq@scope
    \let\endscope\sseq@endscope
    \@xp\sseq@modtikzcommands@\sseq@tikzcommands\sseq@nil
}
\def\sseq@modtikzcommands@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@\fi}
\def\sseq@defer@tikzcommand#1#2;{%
    \begingroup
    \sseq@temptoks{}%
    \sseq@changeoptiondirectory{#1}#2;[\sseq@nil]%
    \sseq@eval{\@nx\pgfqkeys{/tikz/sseqpages/first pass/tikz primitives}{\the\sseq@temptoks}}
    \sseq@x@addtosavedpaths@ctx{\the\sseq@temptoks@ii}%@ctx variant so that tikz primitives always "use context"
    \endgroup
}

\def\sseq@changeoptiondirectory#1#2[#3]{
    \ifx\sseq@nil#3%
        \sseq@temptoks@ii{#1#2}%
    \else
        \sseq@temptoks\@xp{\the\sseq@temptoks,#3}%
        \sseq@ifhop{\sseq@changeoptiondirectory{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%
    \fi
}


\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{%
    \pgfqkeys{/tikz/sseqpages/first pass/scope}{#1}%
    \sseq@scopeoptions\@xp{\the\sseq@scopeoptions\pgfkeysalso{#1}}%
    \sseq@g@addtosavedpaths{\begin{scope}[/tikz/sseqpages/second pass/scope,#1]}%
}
\def\sseq@endscope{\sseq@g@addtosavedpaths{\end{scope}}}



%% Environment definitions

\sseq@addtostorelist\sseq@savedbackgroundpaths{}
\sseq@addtostorelist\sseq@savedforegroundpaths{}
% These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
\@xp\sseq@addtostorelist\@xp\sseq@xmin\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymin\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@xmax\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymax\@xp{\@xp-\sseq@infinity}
% These are used to decide whether to add a certain node to savedpaths.
% In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
% If the user doesn't specify a range, all nodes should be rendered
% To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
\@xp\sseq@addtostorelist\@xp\sseq@xminmm\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@yminmm\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@xmaxpp\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymaxpp\@xp{\sseq@infinity}


\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]{%
%
    \sseq@keepchangestrue
    \sseq@storelist@setdefaults
%
    \ifx\sseq@xmin@default\sseq@infinity
        \let\sseq@xminmax\sseq@xminmax@active
    \fi
    \ifx\sseq@ymin@default\sseq@infinity
        \let\sseq@yminmax\sseq@yminmax@active
    \fi
%
    \def\xmin{\sseq@xmin}\def\xmax{\sseq@xmax}
    \def\ymin{\sseq@ymin}\def\ymax{\sseq@ymax}
    % copy commands into the user namespace.
    \sseq@copycommands{\class\replaceclass\d\structline\classoptions\doptions\structlineoptions\context\addtocontext}%
    \ifx\sseq@targetx\pgfutil@empty \let\d\sseq@d@error@nodegree \fi%
%
    \gdef\sseq@restorestyles{}%
%
    \pgfqkeys{/tikz/sseqpages/global/name only}{#1}%
    \@ifundefined{sseq@thename}{\sseq@error{Every 'sseqdata' environment must have a name. Specify one by saying 'name=your sseq name'}{}}{}
    \sseq@obj@ifundef{exists}{
        \sseq@obj@gdef{exists}{}
        \pgfqkeys{/tikz/sseqpages/global}{{\sseq@thename} options/.code={}}
        \@xp\gdef\csname sseq@savednodes@\sseq@thename infty\endcsname{}%
        \@xp\gdef\csname sseq@savedfeatures@\sseq@thename infty\endcsname{}%
%
        \sseq@savedpaths@initialize
%
    }{%
        \sseq@getcmds
    }%
    \edef\sseq@savedpaths{\@xptwo\@nx\sseq@obj{savedpaths}}
    % the default option handler for /tikz/sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \pgfqkeys{/tikz/sseqpages/global}{#1}%
    \sseq@eval{\@nx\sseq@savedpaths@addoption{\sseq@stylelist}}
    %To give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \sseq@eval{
        \global\let\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname
            \@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname
    }%
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
%
    \sseq@modtikzcommands % Defer evaluation of tikz primitives
    \sseq@patchfor % patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} % install quotes parsing
    \selectfont\nullfont
    \def\par{}%
}

% Store the savedpaths and ranges
\sseq@addtostorelist\sseq@restorestyles{}
\def\endsseqdata{%
    \edef\sseq@restorestyles{\sseq@restorestylelist}
    \bgroup
    \sseq@storecmds
    \egroup
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{%
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
%
    % Copy commands into user namespace
    \sseq@copycommands{\class\replaceclass\d\structline\classoptions\doptions\structlineoptions\addtocontext}%
%
    \gdef\sseq@thispagenodes{}% For storing any nodes to be printed just on this page
    \gdef\sseq@thispagedifferentials{}%
    \gdef\sseq@thispagestructlines{}%
    \gdef\sseq@pagecleanup{}% For undoing local option settings
    \gdef\sseq@savedforegroundpaths{}%
    \def\sseq@thepage{0}%
    \sseq@clearstyles % Keep \sseqset changes from "double dipping" TODO: fix the glitch.
    \pgfqkeys{/tikz/sseqpages/global/name only}{#1}%
    \ifsseq@hasname
        \sseq@getcmds
    \else
        \def\sseq@thename{temp@sseq@number@\the\sseq@anonsseqcount}%
        \advance\sseq@anonsseqcount1
        \sseq@storelist@setdefaults
        \def\sseq@savedpaths{\sseq@tempsavedpaths}
    \fi
    \def\sseq@currentoptionpath{this page}%
    \pgfqkeys{/tikz/sseqpages/global}{{this page} options/.code={},#1}%
    \def\xmin{\sseq@xmin}\def\xmax{\sseq@xmax}%
    \def\ymin{\sseq@ymin}\def\ymax{\sseq@ymax}%
%
    \sseq@modtikzcommands % Redefine tikz primitives to store themselves in \sseq@savedbackgroundpaths or \sseq@savedforegroundpaths as appropriate
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}%
    \sseq@patchfor
    \selectfont\nullfont
    \def\par{}%
}

\def\endsseqpage{%
    % Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \pgfkeys{%
      /tikz/edge quotes mean={%
        edge node={node [%execute at begin node=$,%$
                         %execute at end node=$,%$
                         auto=right,/tikz/sseqpages,
                         /utils/exec={\let\sseq@shifttransform\sseq@okayshifttransform\let\sseq@transform\sseq@okaytransform\the\sseq@thislabelstyle\the\sseq@edgelabelstyle},
                         ##2,
                         /utils/exec={
                            \ifsseq@rotatelabels\iftikz@fullytransformed\else \tikz@fullytransformedtrue\tikz@addtransform{\pgftransformresetnontranslations\sseq@globalrotatetransform}\fi\fi
                            \sseq@edgeoptionhook
                         }
                   ]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \sseq@eval{\@nx\begin{tikzpicture}[/tikz/sseqpages,/utils/exec={\the\sseq@sseqstyle},/tikz/sseqpages/global/{default} options,\ifsseq@hasname/tikz/sseqpages/global/{\sseq@thename} options\fi,/tikz/sseqpages/global/{this page} options]}%
    \sseq@globaldetonetransform
    \sseq@globalscaletransform
    \tikzset{%
        z=0pt,
        every path/.style={},
        every node/.style={}
    }%
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
    %
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    \ifsseq@drawxaxis
        \bgroup
        \ifsseq@borderxaxis\else
            \let\sseq@ymin\sseq@yaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawxaxis
        \ifsseq@drawxaxislabels
            \sseq@drawxlabels
        \fi
        \egroup
    \fi
    \ifsseq@drawyaxis
        \bgroup
        \ifsseq@borderyaxis\else
            \let\sseq@xmin\sseq@xaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawyaxis
        \ifsseq@drawyaxislabels
            \sseq@drawylabels
        \fi
        \egroup
    \fi
%
    \sseq@globalcontext
    \begingroup
    \sseq@savedbackgroundpaths
    \endgroup
%
    \sseq@clip
%
%
    % Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
%
    \ifsseq@drawdifferentials\else
        \let\sseq@differential@draw@ifpage\@gobble
    \fi
    \ifsseq@drawstructlines\else
        \let\sseq@structline@draw@ifpage\@gobble
    \fi
    \sseq@usesavedpaths
%
    \end{tikzpicture}%
    \ifsseq@keepchanges
        \bgroup
        \sseq@storecmds
        \egroup
    \fi
    \sseq@pagecleanup  % blank any options special to this page
    \let\sseq@thename\relax %
}


\def\sseq@drawxaxis{%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    %
    \bgroup
    \pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}%
    \egroup
    \bgroup
    \pgftransformxshift{-\sseq@yaxisgap}
    %\pgftransformxshift{-\sseq@ylabelgap}
    \pgftransformxshift{-\sseq@xaxis@start@extend}
    \pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfusepath{stroke}%
}
\def\sseq@drawyaxis{%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    \bgroup
    \pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \pgftransformyshift{-\sseq@xaxisgap}
    %\pgftransformyshift{-\sseq@xlabelgap}
    \pgftransformyshift{-\sseq@yaxis@start@extend}
    \pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfusepath{stroke}%
%   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}

\def\sseq@drawxlabels{%
    \sseq@tempy=\sseq@ymin\relax
    %\advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}%
    \sseq@tempx=\sseq@xmin\relax
    \loop
        \bgroup
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformyshift{-\sseq@xlabelgap}\pgftransformyshift{-\sseq@xaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempx$}%
        \egroup
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}

\def\sseq@drawylabels{%
    \sseq@tempx=\sseq@xmin\relax
    %\advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@tempmax{\the\sseq@tempy}%
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \bgroup
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformxshift{-\sseq@ylabelgap}\pgftransformxshift{-\sseq@yaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempy$}%
        \egroup
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@tempmax\repeat
}



\def\sseq@clip{%
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    \ifsseq@borderyaxis
        \def\xmin{\pgftransformxshift{-\sseq@yaxisgap}\pgftransformxshift{\sseq@xclip@axisgap}}
    \else
        \def\xmin{\pgftransformxshift{-\sseq@xaxis@start@extend}\pgftransformxshift{-\sseq@clip@padding@left}}
    \fi
    \ifsseq@borderxaxis
        \def\ymin{\pgftransformyshift{-\sseq@xaxisgap}\pgftransformyshift{\sseq@yclip@axisgap}}
    \else
        \def\ymin{\pgftransformyshift{-\sseq@yaxis@start@extend}\pgftransformyshift{-\sseq@clip@padding@bottom}}
    \fi
    \def\xmax{\pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformxshift{\sseq@clip@padding@right}}
    \def\ymax{\pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformyshift{\sseq@clip@padding@top}}
    \bgroup
    \xmin\ymin\sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \bgroup
    \xmin\ymax\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \xmax\ymax\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \xmax\ymin\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfpathclose
    \pgfgetpath\sseq@theclippath % This stores the clipping so I can find intersections later
    \pgfusepath{clip}% This has to be after the egroup or else the clipping gets screwed up
}

\def\printpage[#1]{%
    \begin{sseqpage}[#1]%
    \end{sseqpage}%
}

%% Placement
% TODO: Maybe add error checking for whether x,y are integers? any other error checking?
% Needs \coord to contain... \coord
\def\sseq@class@draw@ifpage#1{
    \bgroup
    \sseq@tempcount=-1
    \sseq@tempcountb=\sseq@obj{#1.num}\relax
    \loop
        \advance\sseq@tempcount1\relax
        \ifnum\sseq@obj{#1[\the\sseq@tempcount].page}>\sseq@thepage\relax
            \sseq@class@drawnode{#1[\the\sseq@tempcount]}
            \sseq@tempcount=\sseq@tempcountb\relax
        \else
            \ifnum\sseq@obj{#1[\the\sseq@tempcount].page}=\sseq@thepage\relax
                \sseq@thispagetrue
                \sseq@class@drawnode{#1[\the\sseq@tempcount]}
                \sseq@tempcount=\sseq@tempcountb\relax
            \fi
        \fi
    \ifnum\sseq@tempcount<\sseq@tempcountb\repeat
    \egroup
}


\def\sseq@class{\@ifnextchar[{\sseq@class@}{\sseq@class@[]}}%}
\def\sseq@class@[#1](#2,#3){%
    \begingroup
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecoords\temp{#2,#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}%
    \sseq@eval{\@nx\sseq@class@@(\temp){\the\sseq@temptoks}}{#1}%
}
\def\sseq@class@@(#1,#2)#3#4{%
    \sseq@tempx=#1\relax
    \advance\sseq@tempx\sseq@x\relax
    \sseq@tempy=#2\relax
    \advance\sseq@tempy\sseq@y\relax
    \edef\partialcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \sseq@xminmax{\the\sseq@tempx}{\the\sseq@tempy}
    \sseq@yminmax{\the\sseq@tempx}{\the\sseq@tempy}
    \sseq@tempcount=\sseq@obj@ifundef{partcoord.(\partialcoord).numnodespp}{1}{\sseq@obj{partcoord.(\partialcoord).numnodespp}}%
    \edef\nodenum{\the\sseq@tempcount}%
    \ifsseq@hasname
        \ifsseq@keepchanges\else
            \ifnum\sseq@tempcount=1\relax
                \sseq@obj@gdef{partcoord.(\partialcoord).numnodes}{0}
                \sseq@obj@gdef{partcoord.(\partialcoord).numnodespp}{1}
            \fi
            \sseq@cleanup@obj{partcoord.(\partialcoord).numnodes}
            \sseq@cleanup@obj{partcoord.(\partialcoord).numnodespp}
        \fi
    \fi
%
    \sseq@obj@xdef{partcoord.(\partialcoord).numnodes}{\the\sseq@tempcount}% and here again?
    \advance\sseq@tempcount1\relax
    \sseq@obj@xdef{partcoord.(\partialcoord).numnodespp}{\the\sseq@tempcount}
    \edef\coord{(\the\sseq@tempx,\the\sseq@tempy,\nodenum)}%
%
    \sseq@restorestyles
    \sseq@obj@gdef{class.\coord.num}{0}% For \classreplace
    \sseq@obj@new{class.\coord[0]}
    \sseq@obj@gdef{class.\coord[0].options}{\pgfkeysalso{#4}}
    \sseq@obj@xodef{class.\coord[0].nodetext}{\sseq@classnodetext}
    \sseq@obj@xodef{class.\coord[0].nodetext.options}{\sseq@classnodetextoptions}
    \sseq@obj@xodef{class.\coord[0].labelnodes}{\sseq@classlabelnodes}
    \sseq@obj@xdef{class.\coord.x}{\the\sseq@tempx}
    \sseq@obj@xdef{class.\coord.y}{\the\sseq@tempy}
    \sseq@obj@ifundef{class.\coord[0].dependencies}{\sseq@obj@gdef{class.\coord[0].dependencies}{}}{}%%TODO: fix replaceclass
    \sseq@obj@xdef{class.\coord[0].needstikz}{\ifsseq@needstikz\@nx\sseq@needstikztrue\else\@nx\sseq@needstikzfalse\fi}

    \ifsseq@keepchanges
        \sseq@savedpaths@addclass{class.\coord}
    \else
        \sseq@tempsavedpaths@addclass{class.\coord}
    \fi
    \sseq@obj@gdef{class.\coord.style}{}%
    \endgroup
}

\def\sseq@replaceclass{\@ifnextchar[{\sseq@replaceclass@}{\sseq@replaceclass@[]}}%}

\def\sseq@replaceclass@[#1](#2){%
    \begingroup
    \def\sseq@thiscall{\replaceclass[#1](#2)}
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecommas(#2)%
    \sseq@replaceclass@@{#1}%
}

\def\sseq@replaceclass@@#1{%
    \sseq@arg@checkpresent\replaceclass1%
    \sseq@arg@checkpresent\replaceclass2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\sseq@n{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{replace class command '\sseq@thiscall'}
    \edef\coord{(\sseq@arg1,\sseq@arg2,\sseq@n)}%
    \edef\coordname{(\sseq@arg1,\sseq@arg2\sseq@optargc3)}%
\iffalse%%%%%%
    \sseq@ifundefcoord\coord{\sseq@error{There never was a class at \coordname\sseq@macroname\ so I cannot replace it}{}}{}%
    \sseq@ifdead\coord{}{\sseq@error{I cannot replace the class at \coordname\sseq@macroname\ because it seems to be alive and well}{}}%
\fi%%%%%%%%
    \sseq@cleanup@obj{class.\coord.num}
    \sseq@obj@inc{class.\coord.num}
    \edef\classnum{\sseq@obj{class.\coord.num}}%
%
    \sseq@restorestyles
%
    \sseq@obj@new{class.\coord[\classnum]}
    \sseq@obj@gdef{class.\coord[\classnum].options}{\pgfkeysalso{#1}}
    \sseq@obj@xodef{class.\coord[\classnum].nodetext}{\sseq@classnodetext}
    \sseq@obj@xodef{class.\coord[\classnum].nodetext.options}{\sseq@classnodetextoptions}
    \sseq@obj@xodef{class.\coord[\classnum].labelnodes}{\sseq@classlabelnodes}
    \sseq@obj@gdef{class.\coord[\classnum].dependencies}{}%%TODO: fix replaceclass
    \sseq@obj@xdef{class.\coord[\classnum].needstikz}{\ifsseq@needstikz\@nx\sseq@needstikztrue\else\@nx\sseq@needstikzfalse\fi}
%
    \endgroup
}

\def\sseq@classoptions{\@ifnextchar[{\sseq@classoptions@}{\sseq@error{There is no reason to use \string\sseq@classoptions without giving options}{}}}%]

\def\sseq@classoptions@[#1](#2){%
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecommas(#2)%
    \sseq@arg@checkpresent\replaceclass1%
    \sseq@arg@checkpresent\replaceclass2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@obj@ifundef{partcoord.(\the\sseq@tempx,\the\sseq@tempy).numnodes}{\sseq@error{No class in the specified position exists}{}}{}
    \sseq@whichclass\sseq@n{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{replace class command '\sseq@thiscall'}
    \edef\coord{(\the\sseq@tempx,\the\sseq@tempy,\sseq@n)}%
    \sseq@ifdead\coord{%
        \@ifundefined{sseq@thepage}{}{
            \ifnum\sseq@thepage>\sseq@getdeathpage\coord\relax
                \sseq@error{The node (#2) perished on page \sseq@getdeathpage\coord\sseq@macroname\ so there is no reason to add an option to it on page \sseq@thepage}{}%
            \fi
        }
    }{}%
    \sseq@cleanup@obj{class.\coord[0].options}
    \sseq@obj@gaddto{class.\coord[0].options}{\pgfkeysalso{#1}}%

    \ifx\sseq@classnodetext\pgfutil@empty\else
        \sseq@temptoks\@xp{\sseq@classnodetext}
        \sseq@obj@xaddto{class.\coord.options}{\@nx\sseq@g@addto@macro\@nx\sseq@classnodetext{\the\sseq@temptoks}}
    \fi
    \ifx\sseq@classnodetextoptions\pgfutil@empty\else
        \sseq@temptoks\@xp{\sseq@classnodetextoptions}
        \sseq@obj@xaddto{class.\coord.options}{\@nx\sseq@g@addto@macro\@nx\sseq@classnodetextoptions{\the\sseq@temptoks}}
    \fi
    \ifx\sseq@classlabelnodes\pgfutil@empty\else
        \sseq@temptoks\@xp{\sseq@classlabelnodes}
        \sseq@obj@xaddto{class.\coord.options}{\@nx\sseq@g@addto@macro\@nx\sseq@classlabelnodes{\the\sseq@temptoks}}
    \fi
}


\def\sseq@class@getparts#1(#2,#3,#4)[#5].{
    \def\sseq@thisclassname{class.(#2,#3,#4)}
    \def\sseq@thisnodename{sseq@{#2,#3,#4}}
    \def\sseq@thispos{(#2,#3)}
    \def\sseq@thisposnum{#4}
    \def\sseq@thisclassnum{#5}
}%

% #1 -- x
% #2 -- \sseq@x shift (change name of node but position already accounted for)
% #3 -- y
% #4 -- \sseq@y
% #5 -- n
% #6 -- node text
% #7 -- options
\def\sseq@class@drawnode#1{%
    \begingroup
    \sseq@class@getparts#1.
    \sseq@tempx=\sseq@obj{\sseq@thisclassname.x}\relax
    \sseq@tempy=\sseq@obj{\sseq@thisclassname.y}\relax
    \sseq@obj{#1.needstikz}
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \ifsseq@needstikz
            \sseq@temptoks\@xpthree{\sseq@obj{#1.nodetext}}
            \sseq@temptoks@ii\@xpthree{\sseq@obj{#1.options}}%
            \sseq@eval{\sseq@temptoks@ii{
                \ifnum\sseq@obj{#1.page}=\sseq@infinity\relax
                    \the\sseq@permanentcyclestyle
                \else
                    \the\sseq@thetransientcyclestyle
                    \ifsseq@thispage
                        \the\sseq@thispagecyclestyle
                    \fi
                \fi
                \the\sseq@temptoks@ii
            }}
            \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}
            \pgfgettransform{\savetransform}%
            \pgftransformresetnontranslations
            \sseq@globalrotatetransform
            \sseq@classplacementtransform
            \sseq@offset{\sseq@thisclassnum}{\sseq@obj{\sseq@thisclassname.num}}
            \pgftransformresetnontranslations
            \tikzset{every text node part/.code/.expand once={\sseq@globalrotatetransform\sseq@obj{#1.nodetext.options}}}%
            \sseq@eval{%
                \@nx\node[
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote,
                    /tikz/sseqpages/second pass/class,
                    /utils/exec={\the\sseq@temptoks@ii
                        \@nx\ifsseq@rotatelabels\@nx\iftikz@fullytransformed\@nx\else \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                        \@nx\fi\@nx\fi
                    }
                ] (\sseq@thisnodename) {\the\sseq@temptoks}
                [every text node part/.code={}]
                \@nx\sseq@obj{#1.labelnodes};
            }%
        \else
            \pgfscope
            \let\tikz@options\pgfutil@empty
            \let\tikz@alias=\pgfutil@empty
            \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/}% Not sure why this shouldn't be in /second pass/class (but putting it there breaks things).s
            \the\sseq@classstyle
            \ifnum\sseq@obj{#1.page}=\sseq@infinity\relax
                \the\sseq@permanentcyclestyle
            \else
                \the\sseq@transientcyclestyle
                \ifsseq@thispage
                    \the\sseq@thispagecyclestyle
                \fi
            \fi
            \sseq@obj{#1.options}%
            \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}
            \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{-\the\sseq@x cm}{-\the\sseq@y cm}}}
            \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
            \pgftransformresetnontranslations
            \sseq@globalrotatetransform
            \sseq@classplacementtransform
            \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
            \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\ifsseq@rotatelabels\sseq@globalrotatetransform\fi\fi
            \tikz@options
            \tikz@node@textfont
            \edef\sseq@classnodetextoptions{\@xptwo\@nx\sseq@obj{#1.nodetext.options}}
            \edef\sseq@classnodetext{\@xptwo\@nx\sseq@obj{#1.nodetext}}
            \sseq@setnodetext
            \let\tikz@fig@name\sseq@thisnodename
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
            \sseq@obj{#1.labelnodes}
            \endpgfscope
        \fi
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}%
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{-\the\sseq@x cm}{-\the\sseq@y cm}}}
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
        \pgfcoordinate{\sseq@thisnodename}{\pgfpointorigin}%
    \fi
    \endgroup
}

\def\sseq@setnodetext{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        \tikzset{every text node part/.try}%
        \sseq@classnodetextoptions
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          \sseq@classnodetext%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    \iftikz@mode@clip \sseq@error{Clip shouldn't happen here, but this error should be caught earlier}{}\fi %
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \sseq@eval{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%% Offsets


\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}

\sseq@setstdoffsets11{0}{0}%
%
\sseq@setstdoffsets12{-0.13}{0}
\sseq@setstdoffsets22{0.13}{0}
%
\sseq@setstdoffsets13{-0.2}{0}
\sseq@setstdoffsets23{0}{0}
\sseq@setstdoffsets33{0.2}{0}
%
\sseq@setstdoffsets14{-0.13}{-0.13}
\sseq@setstdoffsets24{0.13}{-0.13}
\sseq@setstdoffsets34{-0.13}{0.13}
\sseq@setstdoffsets44{0.13}{0.13}
%
\sseq@setstdoffsets15{-0.16}{-0.16}
\sseq@setstdoffsets25{0.16}{-0.16}
\sseq@setstdoffsets35{-0.16}{0.16}
\sseq@setstdoffsets45{0.16}{0.16}
\sseq@setstdoffsets55{0}{0}
%
\sseq@setstdoffsets16{-0.13}{-0.2}
\sseq@setstdoffsets26{-0.13}{0}
\sseq@setstdoffsets36{-0.13}{0.2}
\sseq@setstdoffsets46{0.13}{-0.2}
\sseq@setstdoffsets56{0.13}{0}
\sseq@setstdoffsets66{0.13}{0.2}

\def\sseq@offset#1#2{
    \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@stdxoffset#1/#2\endcsname cm}{0\csname sseq@stdyoffset#1/#2\endcsname cm}}}%
}

\def\sseq@usestdoffsets#1#2#3#4{%
    \sseq@obj@gletcsname{class.(#1,#2,#3).xoffset}{sseq@stdxoffset#3/#4}
    \sseq@obj@gletcsname{class.(#1,#2,#3).yoffset}{sseq@stdyoffset#3/#4}
}


\bgroup\lccode`@=`\#\lccode`Y=`Y\lccode`S=`S \lowercase{\egroup
    \def\sseq@d@error@nodegree{
        \sseq@error{
            You must specify the degree of your spectral sequence if you want to use the differential command \string\d.
            Specify the degree by providing 'degree={f(@1)}{g(@1)}' as an option to '\string\begin{sseqdata}',
            where f(@1) and g(@1) compute the x and y degree of the @1th page differential%
        }
    }
}
\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \begingroup
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \sseq@eval{\the\sseq@temptoks{\the\sseq@tempcount}}{#3}%
}

% #1 -- options
% #2 -- page
% #3 -- source coordinate
\def\sseq@d@@#1#2#3{%
    \sseq@dsetupsourceandtarget{#2}{#3}
    \def\sseq@thiscall{\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3)}%
%
%   Errors:
    \sseq@ifundefcoord\source{%
        \sseq@error{%
            Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \sseq@ifundefcoord\target{%
        \sseq@error{%
            Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \ifsseq@keepchanges
        \sseq@ifdead\source{%
            \ifnum\sseq@getdeathpage\source=#2\else
                \sseq@error{%
                    Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
                    a differential because it already perished on page \sseq@getdeathpage\source %
                }{}%
            \fi
        }{}%
        \sseq@ifdead\target{%
            \ifnum\sseq@getdeathpage\target=#2\else
                \sseq@error{%
                    Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
                    a differential because it already perished on page \sseq@getdeathpage\target %
                }{}%
            \fi
        }{}%
    \else
        \sseq@ifdead\source{%
            \ifnum\sseq@getdeathpage\source<#2
                    \sseq@error{%
                        Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
                        a differential because it already perished on page \sseq@getdeathpage\source %
                    }{}%
            \fi
        }{}%
        \sseq@ifdead\target{%
            \ifnum\sseq@getdeathpage\target<#2
                    \sseq@error{%
                        Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
                        a differential because it already perished on page \sseq@getdeathpage\target %
                    }{}%
            \fi
        }{}%
    \fi
%
    \ifnum\sseq@obj{partcoord.(\sourcecoord).numnodes}=1\relax
%            \@ifundefined{sseq@arg3}{}{\sseq@error{%
%                There is only one node at source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3)' you should say
%                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)'%
%            }{}}
    \else
        \@ifundefined{sseq@arg3}{\sseq@error{%
            There are multiple nodes at source coordinate (\sourcecoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
            \sseq@obj{partcoord.(\sourcecoord).numnodes} nodes at (\sourcecoord) should be the source%
        }{}}{}%
    \fi
    \ifnum\sseq@obj{partcoord.(\targetcoord).numnodes}=1\relax
%            \@ifundefined{sseq@arg4}{}{\sseq@error{%
%                There is only one node at target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3)' you should say
%                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)'%
%            }{}}%
    \else
        \@ifundefined{sseq@arg4}{\sseq@error{%
            There are multiple nodes at target coordinate (\targetcoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
            \sseq@obj{partcoord.(\targetcoord).numnodes}\ nodes at (\targetcoord) should be the target%
        }{}}{}%
    \fi
%
%
    \pgfqkeys{/tikz/sseqpages/first pass/differential}{#1}%
%
%
    \sseq@obj@gdef{d.#2\source\target.page}{#2}
    \sseq@obj@gdef{d.#2\source\target.style}{}%
    \sseq@obj@xdef{d.#2\source\target.source}{\source}
    \sseq@obj@xdef{d.#2\source\target.target}{\target}
    \sseq@temptoks{\pgfkeysalso{#1}}
    \sseq@obj@xdef{d.#2\source\target.options}{\ifsseq@needstikz\@nx\sseq@needstikztrue\else\@nx\sseq@needstikzfalse\fi\the\sseq@temptoks}
%
    \sseq@restorestyles
    \ifsseq@keepchanges
        \sseq@savedpaths@adddifferential{d.#2\source\target}%
%
        \sseq@obj@setpageminrec{class.\source}{#2}
        \sseq@obj@setpageminrec{class.\target}{#2}
    \else
        \sseq@tempsavedpaths@adddifferential{d.#2\source\target}%
        \sseq@obj@setpageminrectemp{class.\source}{#2}
        \sseq@obj@setpageminrectemp{class.\target}{#2}
    \fi
%
    \endgroup
}


\def\sseq@doptions{\pgfutil@ifnextchar[{\sseq@doptions@}{\sseq@error{It's pointless to use '\string\doptions' without giving any options}}} %}

\def\sseq@doptions@[#1]#2(#3){%
    \begingroup
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@doptions@@{#1}}%
    \sseq@eval{\the\sseq@temptoks{\the\sseq@tempcount}}{#3}%
}

\def\sseq@doptions@@#1#2#3{%
    \def\sseq@thiscall{\string\doptions[#1]#2(#3)}%
    \sseq@dsetupsourceandtarget{#2}{#3}
    \sseq@obj@ifundef{d.#2\source\target.style}{\sseq@error{There is no differential of the form '\string\d#2(#3)' so I can't add options to it}{}}{}%
    \ifsseq@keepchanges\else
        \@ifundefined{sseq@thepage}{}{
            \ifnum\sseq@thepage=#2\relax\else\ifnum\sseq@thepage=0\else
                \sseq@error{Adding an option to a differential on page #2 when the current page is \sseq@thepage\sseq@macroname\ has no effect}{}%
            \fi\fi
        }%
    \fi
%
    \ifsseq@keepchanges\else
        \sseq@cleanup@obj{d.#2\source\target.options}
    \fi
    \sseq@obj@gaddto{d.#2\source\target.options}{\pgfkeysalso{#1}}
    \endgroup
}

\def\sseq@dsetupsourceandtarget#1#2{
    \sseq@parsecommas(#2)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{source of differential '\sseq@thiscall'}%
    \edef\sourcecoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}%
    \edef\source{(\sourcecoord,\tempn)}%
%
%
    \pgfmathparse{int(\the\sseq@tempx+\sseq@targetx{#1})}%
    \sseq@tempx=\pgfmathresult\relax
    \pgfmathparse{int(\the\sseq@tempy+\sseq@targety{#1})}%
    \sseq@tempy=\pgfmathresult\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}4}{target of differential '\sseq@thiscall'}%
    \edef\targetcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}%
    \edef\target{(\targetcoord,\tempn)}%
}

\def\sseq@differential@draw@ifpage#1{
    \ifsseq@drawdifferentials\else\show\hi\fi
    \ifnum\sseq@thepage=0\relax
        \sseq@drawdifferential{#1}
    \else
        \ifnum\sseq@obj{#1.page}=\sseq@thepage\relax
            \sseq@drawdifferential{#1}
        \fi
    \fi
}

\def\sseq@drawdifferential#1{
    \bgroup
    \sseq@eval{
        \@nx\sseq@drawedge\sseq@obj{#1.source}\sseq@obj{#1.target}{differential}{
            \@nx\sseq@obj{#1.options}
        }
    }
    \egroup
}

%
\pgfdeclarearrow{
    name = ...,
    parameters = { \the\pgfarrowlength\the\pgflinewidth},
    setup code = {
        % The different end values:
        \pgfarrowssetlineend{-\pgfarrowlength}
        \pgfarrowssetbackend{-0.6\pgfarrowlength}
        % The hull
        \pgfarrowshullpoint{-\pgfarrowlength}{0pt}
        \pgfarrowshullpoint{\pgfarrowlength}{0pt}
        % Saves: Only the length:
        \pgfarrowssavethe\pgfarrowlength
        \pgfarrowssavethe\pgflinewidth
    },
    drawing code = {
        \pgfpathcircle{\pgfpoint{-0.7\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.4\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.1\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathclose
        \pgfusepathqfill
    },
    defaults = { length = 0.3cm }
}

\def\sseq@ifinrange(#1){\sseq@ifinrange@#1,\sseq@nil}

\def\sseq@ifinrange@#1,#2,#3\sseq@nil{%
    \sseq@tempx=#1\relax\sseq@tempy=#2\relax
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
    \sseq@outofrangefalse
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \@xp\pgfutil@secondoftwo
    \else
        \@xp\pgfutil@firstoftwo
    \fi
}

\sseq@addtostorelist\sseq@runoffarrow@start@differential@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@end@differential@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@start@structline@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@end@structline@spec{...}


% #1 -- source (full)
% #2 -- target (full)
% #3 -- which type of edge (either "structline" or "differential")
% #4 -- options
\def\sseq@drawedge(#1)(#2)#3#4{%
    \begingroup\pgfscope
    \let\sseq@edgesourceanchor\pgfutil@empty
    \let\sseq@edgetargetanchor\pgfutil@empty
    \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/#3/}%
    \pgfkeysalso{draw}%
    \the\sseq@pathstyle\the\sseq@edgestyle\@xp\the\csname sseq@#3style\endcsname
    \the\sseq@scopeoptions
    #4%

    % First calculate actual start and end of the edge
    \let\tempaf\pgfutil@empty
    \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid % Check if source is a named coordinate
        \ifx\sseq@edgesourceanchor\pgfutil@empty % Check that the source doesn't have a specified anchor
            \def\tempa{\pgfpointanchor{sseq@{#1}}{center}}% if so, start by taking the center of that coordinate
        \else
            \edef\tempa{\@nx\pgfpointanchor{sseq@{#1}}{\sseq@edgesourceanchor}} % If it has an anchor, use that
            \let\tempaf\tempa
        \fi
    \else
        \ifx\sseq@edgesourceanchor\pgfutil@empty\else % if the source isn't a named coordinate, we shouldn't have a source anchor
            \sseq@error{You specified a source anchor to the #3 between (#1) and (#2), but the source (#1) is not a node}
        \fi
        \edef\tempa{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#1)}% if the source isn't a named coordinate just take the coordinate in question
        \let\tempaf\tempa
    \fi
    \@xp\ifx\csname pgf@sh@pi@sseq@{#2}\endcsname\pgfpictureid % Check if the target is a named coordinate
        \ifx\sseq@edgetargetanchor\pgfutil@empty % check that the target doesn't have a specified anchor
            \def\tempb{\pgfpointshapeborder{sseq@{#2}}{\tempa}}% if so, our end point is the point on the boundary of node b that is in the direction of our initial start coordinate
        \else
            \edef\tempb{\@nx\pgfpointanchor{sseq@{#2}}{\sseq@edgetargetanchor}}% If it has a specified anchor, use that
        \fi
    \else
        \ifx\sseq@edgetargetanchor\pgfutil@empty\else
            \sseq@error{You specified a target anchor to the #3 between (#1) and (#2), but the target (#2) is not a node}
        \fi
        \edef\tempb{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#2)}% if the targt is not a node, just use the coordinate
    \fi
    \let\tempbf\tempb
    \ifx\tempaf\pgfutil@empty
        \def\tempaf{\pgfpointshapeborder{sseq@{#1}}{\tempb}}%
    \fi
%

    \tikz@options
    \tikz@mode
    \pgfpathmoveto{\tempaf}%
    \pgfpathlineto{\tempbf}%
    \pgfgetpath\thispath
    \pgfusepath{discard}%
    \sseq@ifinrange(#1){\sseq@ifinrange(#2){\sseq@outofrangefalse}{\sseq@outofrangetrue}}{\sseq@outofrangetrue}%
    \ifsseq@outofrange
        \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}%
    \else
        \def\pgfintersectionsolutions{0}%
    \fi
    \def\temparrowstartspec{}%
    \def\temparrowendspec{}%
    \pgfcoordinate{tempa}{\tempaf}%
    \pgfcoordinate{tempb}{\tempbf}%
    \pgftransformreset
    \ifcase\pgfintersectionsolutions\relax
    \or
        \sseq@ifinrange(#1){%
            \def\tempbf{\pgfpointintersectionsolution{1}}%
            \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}%
            \pgfcoordinate{tempb}{\tempbf}%
        }{%
            \def\tempaf{\pgfpointintersectionsolution{1}}%
            \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}%
            \pgfcoordinate{tempa}{\tempaf}%
        }%
    \or
            \ifsseq@draworphanedges
                \def\tempaf{\pgfpointintersectionsolution{1}}%
                \def\tempbf{\pgfpointintersectionsolution{2}}%
                \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}%
                \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}%
                \pgfcoordinate{tempa}{\tempaf}%
                \pgfcoordinate{tempb}{\tempbf}%
            \else
                \sseq@drawedgefalse % Don't draw "orphaned edges"
            \fi
    \else
        \sseq@error{This shouldn't happen.}%
    \fi
    \ifsseq@drawedge
         % TODO: should some sort of transformation manipulation be here?
        % TODO: Decide whether this code should be here or what related thing should happen
        % Don't draw dots on very short segments
        \tempbf\pgf@xa=\pgf@x\pgf@ya=\pgf@y
        \tempaf\advance\pgf@xa-\pgf@x\advance\pgf@ya-\pgf@y
        \pgfmathveclen{\pgf@xa}{\pgf@ya}%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \ifnum\pgfmathresult<10\relax%%17?
            \tikzset{every text node part/.append code={\pgfsetcolor{white}}}%
            \ifx\temparrowstartspec\pgfutil@empty
            \else
                \def\temparrowstartspec{\pgfsetarrowsstart{}}%
            \fi
            \ifx\temparrowendspec\pgfutil@empty
            \else
                \def\temparrowendspec{\pgfsetarrowsend{}}%
            \fi
        \fi
        \ifsseq@needstikz
            \sseq@eval{\@nx\draw[/tikz/sseqpages/second pass/differential,
                /utils/exec={\@xp\@nx\temparrowstartspec\@xp\@nx\temparrowendspec}
            ] (tempa) to (tempb);}%
        \else
            \temparrowstartspec
            \temparrowendspec
            \pgfpathmoveto{\pgfpointanchor{tempa}{center}}%
            \pgfpathlineto{\pgfpointanchor{tempb}{center}}%
            \sseq@eval{\noexpand\pgfusepath{%
                \iftikz@mode@fill fill,\fi%
                \iftikz@mode@draw draw,\fi%
            }}%
        \fi
    \fi
    \endpgfscope\endgroup
}

\def\sseq@structline{\@ifnextchar[{\sseq@structline@}{\sseq@structline@[]}}%]
\def\sseq@structline@[#1](#2)(#3){%
    \begingroup
    \sseq@eval{\@nx\sseq@structline@@\sseq@anchorsplit{#2}\sseq@anchorsplit{#3}}
    {#1}{\string\structline\ifx\sseq@nil#1\sseq@nil \else[#1]\fi(#2)(#3)}%
}
\def\sseq@structline@@#1#2#3#4#5#6{%
    \def\sseq@thiscmdname{structure line }% To pass error information to \sseq@whichclass
    \def\sseq@thiscall{#6}%
    \sseq@parsecoords\source{#1}%
    \sseq@parsecoords\target{#3}%
    \sseq@eval{%
        \@nx\sseq@structline@@@
            \@xp\sseq@iffullcoord\@xp(\source)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\source){\@xp\sseq@fullcoord@lastelt\@xp(\source)}}%
                {(\source){}}
            {#2}%
            \@xp\sseq@iffullcoord\@xp(\target)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\target){\@xp\sseq@fullcoord@lastelt\@xp(\target)}}%
                {(\target){}}
            {#4}%
    }{#5}%
    \endgroup
}

\def\sseq@structline@@@(#1,#2)#3#4(#5,#6)#7#8#9{%
    \pgfqkeys{/tikz/sseqpages/first pass/structline}{#9}%
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#5\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#6\relax
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source of structure line '\sseq@thiscall'}%
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#7}{target of structure line '\sseq@thiscall'}%
    \edef\source{(\the\sseq@tempx,\the\sseq@tempy,\sseq@na)}
    \edef\target{(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)}
    \sseq@restorestyles
    \sseq@eval{\@nx\sseq@obj@newstructline{\source}{\target}}
    \sseq@temptoks{\pgfkeysalso{#9}}
    \sseq@obj@xdef{structline.\source\target.options}{\ifsseq@needstikz\@nx\sseq@needstikztrue\else\@nx\sseq@needstikzfalse\fi\the\sseq@temptoks}
}

\def\sseq@obj@newstructline#1#2{
    \sseq@obj@xdef{structline.#1#2.page}{\sseq@infinity}
    \sseq@obj@xdef{structline.#1#2.source}{#1}
    \sseq@obj@xdef{structline.#1#2.target}{#2}
    \sseq@obj@adddependence{class.#1}{structline.#1#2}
    \sseq@obj@adddependence{class.#2}{structline.#1#2}
    \ifsseq@keepchanges
        \sseq@savedpaths@addstructline{structline.#1#2}
    \else
        \sseq@tempsavedpaths@addstructline{structline.#1#2}
    \fi
}

\def\sseq@obj@adddependence#1#2{
    \sseq@obj@ifundef{#1.num}{
        \sseq@obj@gdef{#1[0].dependencies}{\\{#2}}
    }{
        \sseq@obj@gaddtolist{#1[\sseq@obj{#1.num}].dependencies}{#2}
        \sseq@obj@setpagemin{#2}{\sseq@obj{#1[\sseq@obj{#1.num}].page}}
    }
}

\def\sseq@structline@draw@ifpage#1{
    \bgroup
    \ifnum\sseq@obj{#1.page}>\sseq@thepage\relax
        \sseq@structline@draw{#1}
    \else
        \ifnum\sseq@obj{#1.page}=\sseq@thepage\relax
            \sseq@thispagetrue
            \sseq@structline@draw{#1}
        \fi
    \fi
    \egroup
}
\def\sseq@structline@draw#1{
    \sseq@eval{\@nx\sseq@drawedge\sseq@obj{#1.source}\sseq@obj{#1.target}{structline}{\@nx\sseq@obj{#1.options}}}
}


\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


\def\sseq@structlineoptions[#1](#2)(#3){
    \begingroup
    \sseq@parsecoords\source{#2}
    \sseq@parsecoords\target{#3}
    \sseq@eval{%
        \@nx\sseq@structlineoptions@
            \@xp\sseq@iffullcoord\@xp(\source)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\source){\@xp\sseq@fullcoord@lastelt\@xp(\source)}}%
                {(\source){}}
            \@xp\sseq@iffullcoord\@xp(\target)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\target){\@xp\sseq@fullcoord@lastelt\@xp(\target)}}%
                {(\target){}}
    }{#1}%
}

\def\sseq@structlineoptions@(#1,#2)#3(#4,#5)#6#7{
    \sseq@structlineoptions@@{#1}{#2}#3{#4}{#5}{#6}{#7}
}
\def\sseq@structlineoptions@@#1#2#3#4#5#6#7{
    \pgfqkeys{/tikz/sseqpages/first pass/structline}{#7}%
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#4\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#5\relax
    \sseq@temptoks{\pgfkeysalso{#7}}%
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source of structure line '\sseq@thiscall'}%
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#6}{target of structure line '\sseq@thiscall'}%
    \edef\source{(\the\sseq@tempx,\the\sseq@tempy,\sseq@na)}
    \edef\target{(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)}
    \sseq@obj@ifundef{structline.\source\target.page}{
        \sseq@error{Cannot add options to struct line \source--\target because such a struct line doesn't exist}{}
    }{}
    \ifsseq@keepchanges\else
        \sseq@cleanup@obj{structline.\source\target.options}
    \fi
    \ifsseq@needstikz
        \sseq@obj@gaddto{structline.\source\target.options}{\sseq@needstikztrue}
    \fi
    \sseq@obj@gaddto{structline.\source\target.options}{\pgfkeysalso{#7}}%
    \endgroup
}
