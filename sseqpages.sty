\ProvidesPackage{sseqpages}
\RequirePackage{tikz}
\RequirePackage{etoolbox}

% TODO: fix bug in scope options context
% add calculation of maxpage
% expose to user more of the \xmax, \xmin, etc
% option not to render axes
% offsets
% Render certain out of range nodes? second range command to allow for nearby nodes to be printed anyways?
% fix \structline

\usetikzlibrary{quotes}
\usepackage{trace}

% Ensure \@xp and \@nx have the correct values in case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords
\def\sseq@uptocomma#1,#2\sseq@nil{#1}
\def\sseq@fullcoord@to@partialcoord(#1,#2,#3){(#1,#2)}
\def\sseq@fullcoord@lastelt(#1,#2,#3){#3}


%% Declarations
\newif\ifsseq@fastmode
\newif\ifsseq@needstikz

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@thepermcyclestyle
\newtoks\sseq@thetranscyclestyle
\newtoks\sseq@classoptionslist
\newtoks\sseq@doptionslist
\newtoks\sseq@genoptionslist


\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@featurecount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempx
\newcount\sseq@tempy
\newcount\sseq@tempxb
\newcount\sseq@tempyb
\newdimen\sseq@tempxdim
\newdimen\sseq@tempydim
\sseq@context@depth\z@
\sseq@context@tempcount\z@
\sseq@featurecount\z@
\sseq@x\z@ \sseq@y\z@
\sseq@tempcount\z@


\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii


%% \sseq@--@--addto@macro and friends.
% My own variants of \pgfutil@g@addto@macro.
% \sseq@x@addto@macro recursively expands the argument and then adds it.
% \sseq@g/x@deforaddto@macro checks first whether the macro is defined or not, if not it used \gdef or \xdef, else it uses \sseq@g/x@addto@macro
% The "ctx" variants are \let equal to the foreach versions when inside of \foreach or when the context command (not named yet) is used
% The "noctx" variants never are set equal to the foreach versions. These are primarily for use in defining internals, to prevent infinite loops
% The standard variants are \def'd to expand to a "ctx" variant when the "use context" option is requested
% They also add saved state information to the macro the first time they add data to that macro
% TODO: Make context command / environment
\def\sseq@g@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1#2}\xdef#1{\the\pgfutil@toks@}\endgroup} % copy of \pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} % let #2 be expanded

\let\sseq@g@addto@macro@ctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@ctx\sseq@x@addto@macro
\let\sseq@g@addto@macro@noctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@noctx\sseq@x@addto@macro


\def\sseq@g@deforaddto@macro#1{\@ifundefined{#1}{\@xp\gdef\csname#1\endcsname}{\@xp\sseq@g@addto@macro@noctx\csname#1\endcsname}}
\def\sseq@x@deforaddto@macro#1{\@ifundefined{#1}{\@xp\xdef\csname#1\endcsname}{\@xp\sseq@x@addto@macro@noctx\csname#1\endcsname}}

\let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro
\let\sseq@g@deforaddto@macro@noctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@noctx\sseq@x@deforaddto@macro


\def\sseq@g@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1
    \sseq@g@addto@macro@noctx#1%
}

\def\sseq@x@addto@macro@foreach#1{
    \sseq@gx@addto@macro@foreach@#1
    \sseq@x@addto@macro@noctx#1%
}

\def\sseq@g@deforaddto@macro@foreach#1{
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@g@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@x@deforaddto@macro@foreach#1{
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@x@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@gx@addto@macro@foreach@#1{%
    \@ifundefined{sseq@context@\sseq@macroname#1}
        {\sseq@context@tempcount=0\relax}
        {\sseq@context@tempcount=\csname sseq@context@\sseq@macroname#1\endcsname\relax}%
    \ifnum\sseq@context@tempcount<\sseq@context@depth\relax %
        \loop %
            \advance\sseq@context@tempcount1\relax%
            \sseq@for@addsavedtoksntomacro{\the\sseq@context@tempcount}{#1}%
        \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
        \@xp\edef\csname sseq@context@\sseq@macroname#1\endcsname{\the\sseq@context@depth}%
    \fi %
}

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@addtosavedtoks{\@xp\sseq@g@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@xaddtosavedtoks{\@xp\sseq@x@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@addsavedtoksntomacro#1#2{\@xp\@xp\@xp\sseq@g@addto@macro@noctx\@xp\@xp\@xp#2\@xp\@xp\@xp{\csname sseq@for@savedtoks#1\endcsname}}

\def\sseq@g@addtosavedpaths{\@xp\sseq@g@addto@macro\sseq@savedpaths}
\def\sseq@x@addtosavedpaths{\@xp\sseq@x@addto@macro\sseq@savedpaths}
\def\sseq@g@addtosavedpaths@ctx{\@xp\sseq@g@addto@macro@ctx\sseq@savedpaths}
\def\sseq@x@addtosavedpaths@ctx{\@xp\sseq@x@addto@macro@ctx\sseq@savedpaths}
\def\sseq@savedpaths{\sseq@savedforegroundpaths}

%%%% Set up keys

\def\sseqset#1{\pgfqkeys{/tikz/sseqpages}{#1}}
\def\sseq@set{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\edef\sseq@temp{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname=\the\sseq@temptoks}}\sseq@temp}

\pgfkeys{
    /tikz/sseqpages/.is family,
    /tikz/sseqpages/.unknown/.code={\sseq@passoptionto{/tikz}},
    % \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    % TODO: fix global so that unknown options cause errors at the begining of the environment
    % It should check that the option is defined somewhere before deferring it?
    /tikz/sseqpages/global/.unknown/.code={
        \let\sseq@tempa\pgfkeyscurrentname
        \let\sseq@tempb\pgfkeyscurrentvalue
        \pgfkeysalso{{\sseq@currentoptionpath} options/.append style/.expand twice={\@xp\sseq@tempa\@xp=\@xp{\sseq@tempb}}}
    },
    /tikz/sseqpages/first pass/.unknown/.code={},
    /tikz/sseqpages/first pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/class/.unknown/.code={
        \expandafter\ifx\csname pgf@sh@s@\pgfkeyscurrentname\endcsname\relax % is it the name of a shape?
            \sseq@passoptionto{/tikz/sseqpages/first pass}
        \else
            \edef\tikz@shape{\pgfkeyscurrentname} % if so, store it
        \fi
    },
    /tikz/sseqpages/first pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/second pass/.is family,
    /tikz/sseqpages/second pass/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages}},
    /tikz/sseqpages/second pass/scope/.is family,
    /tikz/sseqpages/second pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/differential/.is family,
    /tikz/sseqpages/second pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/tikz primitives/.is family,
    /tikz/sseqpages/second pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}}
}

\pgfqkeys{/tikz/sseqpages/first pass/class}{shape/.code={\edef\tikz@shape{\pgfkeyscurrentname}}} % shape=whatever shape passing

%% Quote handling
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\def\sseq@removequotes"#1"{#1}
\def\sseq@classnodetext{}

\pgfkeys{
    /tikz/sseqpages/first pass/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /tikz/sseqpages/first pass/class/handle quote/.code={\@xp\def\@xp\sseq@classnodetext\@xp{\sseq@removequotes#1}},
    /tikz/sseqpages/first pass/differential/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/second pass/class/handle quote/.code={},
    /tikz/sseqpages/handle quote/.code={\tikzset{every to/.append style={#1}}}
}

%% Parsing, background vs foreground, and context
\def\sseq@standardparse{
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@old
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transformations
    \let\sseq@shifttransform\sseq@okaytransform
    \let\sseq@firstpass@shifttransform\@gobbletwo
    \def\place{\sseq@error{You cannot use \@nx\place\sseq@macroname in standard parse mode}{}}
    \def\replace{\sseq@error{You cannot use \@nx\replace\sseq@macroname in standard parse mode}{}}
    \def\d{\sseq@error{You cannot use \@nx\d\sseq@macroname in standard parse mode}{}}
}

\def\sseq@nodeparse{
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform
    \let\place\sseq@place
    \let\replace\sseq@replace
    \let\d\sseq@d
}

\def\sseq@errortikzprimsonly#1{\sseq@error{You can only use '#1' as an option for tikz primitives, not for \@nx\place, \@nx\replace\sseq@macroname\ or \@nx\d}{}}

\sseq@set{
    standard parse/.code={\sseq@standardparse},
    node parse/.code={\sseq@nodeparse},
    background/.code={\pgfkeysalso{standard parse}},
    foreground/.code={\pgfkeysalso{node parse}} %TODO: track original mode and restore it?
}

\pgfqkeys{/tikz/sseqpages/first pass}{
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform},
    background/.code={\def\sseq@savedpaths{\sseq@savedbackgroundpaths}\pgfkeysalso{standard parse}},
    foreground/.code={\def\sseq@savedpaths{\sseq@savedforegroundpaths}\pgfkeysalso{node parse}},% is this okay?
    use context/.code={%\def rather than \let because until a \foreach loop occurs, \sseq@g@addto@macro@ctx is vanilla variant
        \def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}
        \def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}
        \def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}
        \def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}
    }
}

\pgfqkeys{/tikz/sseqpages/first pass/class}{
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/first pass/differentials}{
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ % This is only for scope and tikz primitives, but in other cases, it emits an error on first pass.
    use context/.code={},
    needs tikz/.code={}
}

%% Needs tikz
% Force \place or \d to fallback to using tikz to render their output
% Rather than using the faster direct \pgf primitives (largely copied from tikz to maximize compatibility)
% Drawing with tikz is slower, but I don't want to reimplement these features

\pgfqkeys{/tikz/sseqpages/first pass}{
    needs tikz/.code=\sseq@needstikztrue,
    shade/.code=\sseq@needstikztrue, % TOD? shading? (NOPE!)
    blend mode/.code=\sseq@needstikztrue,
    pattern/.code=\sseq@needstikztrue,
    path picture/.code=\sseq@needstikztrue,
    path fading/.code=\sseq@needstikztrue,
    decorate/.code=\sseq@needstikztrue,
    pin/.code=\sseq@needstikztrue,
    label/.code=\sseq@needstikztrue
}

% multipart shapes and alignment to be done with tikz
\pgfqkeys{/tikz/sseqpages/first pass/class}{
    circle split/.code=\sseq@needstikztrue,
    circle solidus/.code=\sseq@needstikztrue,
    ellipse split/.code=\sseq@needstikztrue,
    rectangle split/.code=\sseq@needstikztrue,
    align/.code=\sseq@needstikztrue,
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\place' command. You should use 'alias' instead}{}}
}


% Force differential to be drawn with tikz if it is bent
\pgfqkeys{/tikz/sseqpages/first pass/differential}{
    bend left/.code=\sseq@needstikztrue,
    bend right/.code=\sseq@needstikztrue,
    in/.code=\sseq@needstikztrue,
    out/.code=\sseq@needstikztrue,
    controls/.code=\sseq@needstikztrue,
    in control/.code=\sseq@needstikztrue,
    out control/.code=\sseq@needstikztrue,
    loop/.code=\sseq@needstikztrue,
    loop above/.code=\sseq@needstikztrue,
    loop below/.code=\sseq@needstikztrue,
    loop left/.code=\sseq@needstikztrue,
    loop right/.code=\sseq@needstikztrue
}


%% Style options
\def\sseq@cyclestyles#1#2{\sseq@permanentcyclestyle{#1}\sseq@transientcyclestyle{#2}}
\def\sseq@cyclestyle#1{\sseq@permanentcyclestyle{#1}\sseq@transientcyclestyle{#1}}
\def\sseq@permanentcyclestyle#1{\sseq@thepermcyclestyle{\pgfkeysalso{#1}}}
\def\sseq@transientcyclestyle#1{\sseq@thetranscyclestyle{\pgfkeysalso{#1}}}

\def\sseq@redooptions{\sseq@redoclassoptions\sseq@redodifferentialoptions\sseq@redogenoptions}
\def\sseq@redoclassoptions{
    \sseq@classoptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}%
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every path}
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every node}
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every class}
}
\def\sseq@redodifferentialoptions{
    \sseq@doptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}%
    \sseq@addstylecmdtotoks\sseq@doptionslist{every path}
    \sseq@addstylecmdtotoks\sseq@doptionslist{every differential}%
}
\def\sseq@redogenoptions{
    \sseq@genoptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}
    \sseq@addstylecmdtotoks\sseq@genoptionslist{every path}
    \sseq@addstylecmdtotoks\sseq@genoptionslist{every node}
}

\def\sseq@addstylecmdtotoks#1#2{%
    \pgfkeysgetvalue{/tikz/sseqpages/#2/.@cmd}{\sseq@tempcmd}%
    \ifx\sseq@tempcmd\relax\else
        \@xp\def\@xp\sseq@temp\@xp{\sseq@tempcmd\pgfeov}
        \ifx\sseq@temp\pgfutil@empty\else
            #1\@xp\@xp\@xp{\@xp\the\@xp#1\sseq@tempcmd\pgfeov}
        \fi
    \fi
}

\def\sseq@addsetstylecmdtotoks#1#2{
    \pgfkeysgetvalue{/tikz/sseqpages/#2/.@cmd}{\sseq@tempcmd}
    \ifx\sseq@tempcmd\relax\else
        \@xp\def\@xp\sseq@temp\@xp{\sseq@tempcmd\pgfeov}
        \ifx\sseq@temp\pgfutil@empty\else
            \sseq@temptoks\@xp{\sseq@tempcmd\pgfeov}
            \edef\sseq@temp{\@nx#1{\the#1\@nx\pgfkeysalso{#2/.code={\the\sseq@temptoks}}}}
            \sseq@temp
        \fi
    \fi
}

\sseq@set{
    every sseq/.code={},
    every page/.code={},
    every path/.code={},
    every node/.code={},
    every differential/.code={},
    every class/.code={},
    every label/.style={ %TOD? make changes to every label work correctly? (maybe?)
            /tikz/auto,
            /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},
            /tikz/inner sep=+0.5ex
    },
    sseqs/.code=           {\pgfkeysalso{every sseq/.append style={#1}}}, % TODO: should sseqs and pages have different handling? (probably)
    pages/.code=           {\pgfkeysalso{every page/.append style={#1}}},
    paths/.code=           {\pgfkeysalso{every path/.append style={#1}}\sseq@redooptions},
    nodes/.code=           {\pgfkeysalso{every node/.append style={#1}}\sseq@redooptions},
    differentials/.code=   {\pgfkeysalso{every differential/.append style={#1}}\sseq@redodifferentialoptions},
    classes/.code=         {\pgfkeysalso{every class/.append style={#1}}\sseq@redoclassoptions},
    labels/.code=          {\pgfkeysalso{every label/.append style={#1}}},%{\sseq@redodifferentialoptions},
    permanent cycle style/.code={\sseq@permanentcyclestyle{#1}},
    transient cycle style/.code={\sseq@transientcyclestyle={#1}},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/global}{
    sseqs/.code=           {\sseq@set{every sseq/.append style={#1}}},
    pages/.code=           {\sseq@set{every page/.append style={#1}}},
    paths/.code=           {\sseq@set{every path/.append style={#1}}},
    nodes/.code=           {\sseq@set{every node/.append style={#1}}},
    differentials/.code=   {\sseq@set{every differential/.append style={#1}}},
    classes/.code=         {\sseq@set{every class/.append style={#1}}},
    labels/.code=          {\sseq@set{every label/.append style={#1}}},
    permanent cycle style/.code={\sseq@thepermcyclestyle={#1}},
    transient cycle style/.code={\sseq@thetranscyclestyle={#1}},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/first pass}{
    sseqs/.code=           {\sseq@set{every sseq/.append style={#1}}},
    pages/.code=           {\sseq@set{every page/.append style={#1}}},
    paths/.code=           {\sseq@set{every path/.append style={#1}}\sseq@redooptions},
    nodes/.code=           {\sseq@set{every node/.append style={#1}}\sseq@redooptions},
    differentials/.code=   {\sseq@set{every differential/.append style={#1}}\sseq@redodifferentialoptions},
    classes/.code=         {\sseq@set{every class/.append style={#1}}\sseq@redoclassoptions},
    labels/.code=          {\sseq@set{every label/.append style={#1}}},%{\sseq@redodifferentialoptions},
    permanent cycle style/.code={\sseq@thepermcyclestyle={#1}},
    transient cycle style/.code={\sseq@thetranscyclestyle={#1}},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ % Is this right?
    sseqs/.code=           {},
    pages/.code=           {},
    paths/.code=           {},
    nodes/.code=           {},
    differentials/.code=   {},
    classes/.code=         {},
    labels/.code=          {},
    permanent cycle style/.code={},
    transient cycle style/.code={},
    cycle styles/.code 2 args={}
}


%% Global options
\def\sseq@xlabelstep{1}
\def\sseq@ylabelstep{1}

\pgfqkeys{/tikz/sseqpages/global}{
    name/.code={\name{#1}},
    page/.code={\page{#1}},
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
    grid/.code={},
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    label step/.code={\def\sseq@xlabelstep{#1}\def\sseq@ylabelstep{#1}},
    x label step/.store in=\sseq@xlabelstep,
    y label step/.store in=\sseq@ylabelstep
}

\sseq@set{
    name/.code={\sseq@error@optionglobalonly{name}},
    page/.code={\sseq@error@optionglobalonly{page}},
    x range/.code 2 args={\sseq@error@optionglobalonly{x range}},
    y range/.code 2 args={\sseq@error@optionglobalonly{y range}},
    grid/.code={\sseq@error@optionglobalonly{grid}},
    labels/.code={\sseq@error@optionglobalonly{labels}},
    x labels/.code={\sseq@error@optionglobalonly{x labels}},
    y labels/.code={\sseq@error@optionglobalonly{y labels}},
    label step/.code={\sseq@error@optionglobalonly{labelstep}},
    x label step/.code={\sseq@error@optionglobalonly{x labelstep}},
    y label step/.code={\sseq@error@optionglobalonly{y labelstep}}
}


%% setup for coordinate transformation keys
\sseq@set{
    x/.code={\sseq@transform{x}{#1}}, % TODO: Check what happens if you try to use x or y -- actually should probably make this illegal?? would require work not to I think
    y/.code={\sseq@transform{y}{#1}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@shifttransform{yshift}{#1}},
    shift/.code={\sseq@transform{shift}{#1}},
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    yscale/.code={\sseq@transform{yscale}{#1}},
    scale/.code={\sseq@transform{scale}{#1}},
    scale around/.code={\sseq@transform{scale around}{#1}},
    xslant/.code={\sseq@transform{xslant}{#1}},
    yslant/.code={\sseq@transform{yslant}{#1}},
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    cm/.code={\sseq@transform{cm}{#1}},
    reset cm/.code={\sseq@transform{reset cm}{}},
    transform canvas/.code={\sseq@transform{transform canvas}{#1}}
}

% Catch shifts on first pass to update \sseq@x, \sseq@y
\pgfqkeys{/tikz/sseqpages/first pass}{
    xshift/.code={\sseq@firstpass@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@firstpass@shifttransform{yshift}{#1}}
}

\pgfqkeys{/tikz/sseqpages/second pass/class}{
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages/second pass/differential}{
    xshift/.code={},
    yshift/.code={}
}

\def\sseq@error@optionillegal#1#2#3{
    \sseq@temptoks{#2}
    \sseq@error{
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}
}

\def\sseq@error@optionglobalonly#1{
    \sseq@error{
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]')%
    }{}
}

\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@error@illegaltransform#1#2{
    \sseq@temptoks{#2}
    \sseq@error{
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}
}

\def\sseq@firstpass@checkshifttransform#1#2{
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult
    }{\sseq@error@illegaltransform{#1}{#2}}
}
\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform

\def\sseq@checkshifttransform#1#2{% TODO: on second pass, usually shouldn't have to check?
    \pgfmathparse{#2}
    \sseq@ifpgfmathresultisunitlessint{
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult
        %\showthe\sseq@x
        \edef\sseq@temp{\@nx\sseq@okaytransform{shift}{{(\pgfmathresult\csname pgf@\sseq@getfirstchar#1\sseq@nil x\endcsname,\pgfmathresult\csname pgf@\sseq@getfirstchar#1\sseq@nil y\endcsname)}}}
        \sseq@temp
    }{\sseq@error@illegaltransform{#1shift}{#2}}
}

\def\sseq@okayshifttransform#1#2{
    \pgfkeysalso{/tikz/#1=#2cm}
}



\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%% (What should this section be titled?)
\def\sseq@iffullcoord(#1){\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

% apparently only works for full
\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){
    \@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}
        {\@firstoftwo}
        {\ifnum#3<\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}


%% Parsers

% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\conditionally@traceoff\pgfmathparse{#2}\conditionally@traceon\edef\sseq@temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\sseq@temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax%
    \ifnum\sseq@commacount<4 %
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1%
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%% Command redefinition commands

% Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@ %
    \fi %
}

% Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@ %
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@tikzcommands{%
        \clip\coordinate\draw\fill\filldraw
        \graph\matrix\node\path\pattern
        \shade\shadedraw\useasboundingbox
}

\def\sseq@modtikzcommands@defer{%
    \let\scope\sseq@scope
    \let\endscope\sseq@endscope
    \@xp\sseq@modtikzcommands@defer@\sseq@tikzcommands\sseq@nil
}
\def\sseq@modtikzcommands@defer@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@defer@\fi}
\def\sseq@defer@tikzcommand#1#2;{
    \begingroup
    \sseq@temptoks{}
    \sseq@changeoptiondirectory@{#1}#2;[\sseq@nil]
    \edef\temp{\@nx\pgfqkeys{/tikz/sseqpages/first pass/tikz primitives}{\the\sseq@temptoks}}\temp
    \sseq@x@addtosavedpaths@ctx{\the\sseq@temptoks@ii}%@ctx variant so that tikz primitives always "use context"
    \endgroup
}

\def\sseq@defer@tikzcommand@getoptions#1[#2]{\ifx#2\sseq@nil\else\sseq@temptoks\@xp{\the\sseq@temptoks#2,}\@xp\sseq@defer@tikzcommand@getoptions\fi}

% Ensure that \sseq@scopeoptions gets inserted exactly once, before all other options.
\def\sseq@changeoptiondirectory#1#2[#3]{
    \ifx\sseq@nil#3%
        \sseq@temptoks{}
        \sseq@temptoks@ii{#1[/tikz/sseqpages/second pass/tikz primitives]#2}%\sseq@scopeoptions
    \else %
        \sseq@temptoks{#3}
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%\sseq@scopeoptions,
    \fi %
}
\def\sseq@changeoptiondirectory@#1#2[#3]{% same as the first part except no need to insert \sseq@scopeoptions
    \ifx\sseq@nil#3%
        \sseq@temptoks@ii{#1#2}
    \else %
        \sseq@temptoks\@xp{\the\sseq@temptoks,#3}
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%
    \fi %
}


\def\sseq@modtikzcommands@options{}%\let\sseq@path@stored\path\def\path##1;{\sseq@changeoptiondirectory{\sseq@path@stored}##1;[\sseq@nil]}}

\def\sseq@modtikzcommands@options@#1{
    \ifx\sseq@nil#1\else
        \@xp\let\csname sseq@\sseq@macroname#1@stored\endcsname#1
        \edef#1##1;{\@nx\sseq@changeoptiondirectory{\@xp\@nx\csname sseq@\sseq@macroname#1@stored\endcsname}##1;[\@nx\sseq@nil]}
        \@xp\sseq@modtikzcommands@options@
    \fi
}

% TODO: respect the style "every scope"
\def\sseq@scopeoptions{}
\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{%
    \pgfqkeys{/tikz/sseqpages/first pass/scope}{#1}%
    \@xp\def\@xp\sseq@scopeoptions\@xp{\sseq@scopeoptions#1,}%
    \sseq@redooptions
    \sseq@g@addtosavedpaths{\begin{scope}[/tikz/sseqpages/second pass/scope,#1]}%
}
\def\sseq@endscope{\sseq@g@addtosavedpaths{\end{scope}}}

% transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@store#1{\edef\sseq@temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\sseq@temp}
\def\sseq@get#1{\ifx#1\sseq@novalue\edef\sseq@temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\sseq@temp\fi}


%% Environment definitions

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]#2{%
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
    % copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\replace\d\degree %
        \structline %
    }%
%
    \sseq@data@name{#2}%
%
    % the default option handler for /tikz/sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \pgfqkeys{/tikz/sseqpages/global}{{\sseq@thename} options/.code={},#1}
    \sseq@redooptions
    %To give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \edef\temp{\global\let\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname}
    \temp
    \gdef\sseq@savedbackgroundpaths{}
    \gdef\sseq@savedforegroundpaths{}%
    \gdef\sseq@compilesseq{}%
%
    \@xp\gdef\csname sseq@savednodes@\sseq@thename infty\endcsname{}
    % Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \foreach\sseq@p in {1,...,14}{%
            \csname sseq@saveddiffs@\sseq@thename\sseq@p\endcsname %
        }%
    }%
    % These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    %
    % These are used to decide whether to add a certain node to savedpaths.
    % In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    % If the user doesn't specify a range, all nodes should be rendered
    % To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
%
    \sseq@modtikzcommands@defer % Defer evaluation of tikz primitives
    \sseq@patchfor % patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} % install quotes parsing
    \selectfont\nullfont
}

% Store the savedpaths and ranges
\def\endsseqdata{
    %\@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
    \sseq@compilesseq
%
    \sseq@store\sseq@savedbackgroundpaths %
    \sseq@store\sseq@savedforegroundpaths
    \sseq@store\sseq@thepermcyclestyle\sseq@store\sseq@thetranscyclestyle %
    \sseq@store\sseq@xlabelstep
    \sseq@store\sseq@ylabelstep
    \sseq@store\sseq@xmin\sseq@store\sseq@xmax %
    \sseq@store\sseq@ymin\sseq@store\sseq@ymax %
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{
    \let\sseq@savedbackgroundpaths\sseq@novalue
    \let\sseq@savedforegroundpaths\sseq@novalue
    \let\sseq@xlabelstep\sseq@novalue
    \let\sseq@ylabelstep\sseq@novalue
    \let\sseq@xmin\sseq@novalue\let\sseq@xmax\sseq@novalue
    \let\sseq@ymin\sseq@novalue\let\sseq@ymax\sseq@novalue
    % Copy commands into user namespace
    \sseq@copypagecommands{\name\page\classoptions\doptions\xrange\yrange}%
%
    \gdef\sseqpage@cleanup{} % For undoing local option settings
    \def\sseq@currentoptionpath{this page}
    \pgfqkeys{/tikz/sseqpages/global}{#1}
    %
    % Defer evaluation of all tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}%
    \sseq@patchfor %
    \selectfont\nullfont
}

\def\endsseqpage{%
    % Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \pgfkeys{
      /tikz/edge quotes mean={%
        edge node={node [%execute at begin node=$,%$
                         %execute at end node=$,%$
                         auto=right,/tikz/sseqpages,every label,##2]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \edef\temp{\@nx\begin{tikzpicture}[/tikz/sseqpages,every sseq,/tikz/sseqpages/global/{\sseq@thename} options,/tikz/sseqpages/global/{this page} options]}%
    \temp
    \tikzset{
        z=0pt,
        every path/.style={},
        every node/.style={}
    }
    \sseq@redooptions
    %
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    \begingroup % for \sseq@modtikzcommands@options
    \sseq@modtikzcommands@options
    \sseq@savedbackgroundpaths
    \endgroup
    % Axes -- eventually incorporate \axesstyle, label options, changing the increment between the numbers, etc
    \sseq@drawaxes
    \sseq@drawxlabels
    \sseq@drawylabels
    \sseq@clip
%
%
    % Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
%
%    \@xp\sho\csname sseq@savednodes@\sseq@thename2\endcsname
    % Insert nodes from all pages on or after the current one
    \foreach\sseq@p in {\sseq@thepage,...,14,infty}{%
        \csname sseq@savednodes@\sseq@thename\sseq@p\endcsname %
    }%
%
    % Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    \csname sseq@saveddiffs@\sseq@thename\sseq@thepage\endcsname %
%
    % dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@modtikzcommands@options
    \sseq@savedforegroundpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup % blank any options special to this page
    \let\sseq@thename\relax %
}

\def\sseq@drawaxes{
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-1.5cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-0.5cm

    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmax cm
    \advance\sseq@tempxdim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.5cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-1.5cm
    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempydim=\sseq@ymax cm
    \advance\sseq@tempydim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \pgfusepath{stroke}
%   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}

\def\sseq@drawaxes{
    \bgroup
    \pgfpathmoveto{\pgfpoint{\sseq@xmax cm+0.5cm}{\sseq@ymin cm-0.5cm}}
    \pgftransformshift{\pgfpoint{\sseq@xmin cm-0.5cm}{\sseq@ymin cm-0.5cm}}
    \pgftransformresetnontranslations
    \pgfpathlineto{\pgfpoint{-1.1cm}{0cm}}
    \egroup
    \bgroup
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm-0.5cm}{\sseq@ymax cm+0.5cm}}
    \pgftransformshift{\pgfpoint{\sseq@xmin cm-0.5cm}{\sseq@ymin cm-0.5cm}}
    \pgftransformresetnontranslations
    \pgfpathlineto{\pgfpoint{0cm}{-1cm}}
    \egroup
    \pgfusepath{stroke}
%   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}


\def\sseq@drawxlabels{
    \sseq@tempy=\sseq@ymin\relax
    %\advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}
    \sseq@tempx=\sseq@xmin\relax
    \loop
        \bgroup
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm-0.5cm}}
        \pgftransformresetnontranslations
        \pgftext[at=\pgfpoint{0cm}{-0.5cm}]{$\the\sseq@tempx$}
        \egroup
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}

\def\sseq@drawylabels{
    \sseq@tempx=\sseq@xmin\relax
    %\advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@temp{\the\sseq@tempy}
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \bgroup
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm-0.5cm}{\the\sseq@tempy cm}}
        \pgftransformresetnontranslations
        \pgftext[at=\pgfpoint{-0.5cm}{0cm}]{$\the\sseq@tempy$}
        \egroup
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@temp\repeat
}

\def\sseq@clip{
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.4cm
    \sseq@tempydim=\sseq@ymin cm
    \advance\sseq@tempydim-0.4cm
    \pgfpathmoveto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmax cm
    \advance\sseq@tempxdim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempydim=\sseq@ymax cm
    \advance\sseq@tempydim0.5cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \sseq@tempxdim=\sseq@xmin cm
    \advance\sseq@tempxdim-0.4cm
    \pgfpathlineto{\pgfpoint{\the\sseq@tempxdim}{\the\sseq@tempydim}}
    \pgfusepath{clip}
}

\def\printpage[#1]{
    \begin{sseqpage}[#1]
    \end{sseqpage}
}


%% Options and primitives for sseqdata and sseqpage
\def\sseq@data@name#1{\gdef\sseq@thename{#1}}
% When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@get\sseq@savedbackgroundpaths %
    \sseq@get\sseq@savedforegroundpaths
    \sseq@get\sseq@xlabelstep
    \sseq@get\sseq@ylabelstep
    \sseq@get\sseq@xmin  \sseq@get\sseq@xmax %
    \sseq@get\sseq@ymin  \sseq@get\sseq@ymax %
}

\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobble % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1{%
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax@active#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

% Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\sseq@thepage}
\def\sseq@page@page@{\let\sseqthepage\sseq@thepage\sseq@tempcount=\sseq@thepage\advance\sseq@tempcount-1\edef\sseq@thepagemm{\the\sseq@tempcount}}

\def\sseq@classoptions(#1)#2{
    \def\temp{#1}
    \ifsseq@fastmode
        \sseq@iffullcoord(#1){}{\edef\temp{\temp,1}}
    \else
        \sseq@iffullcoord(#1){
            \@ifundefined{sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes}{\sseq@error{There are no classes at \sseq@fullcoord@to@partialcoord(#1)}{}}
            \ifnum\csname sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes\endcsname=1\relax
                \sseq@error{
                    There is only one node at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                    '\string\classoptions\sseq@fullcoord@to@partialcoord(#1){#2}'%
                }
            \fi
        }{
            \@ifundefined{sseq@coord\sseq@thename(#1)@numnodes}{\sseq@error{There are no classes at (#1)}{}}
            \ifnum\csname sseq@coord\sseq@thename(#1)@numnodes\endcsname=1\relax
                \edef\temp{\temp,1}
            \else
                \sseq@error{
                    There are multiple nodes at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                    '\string\classoptions(#1,n){#2}' where 'n' is the number of the node you are referring to%
                }
            \fi
        }
        \sseq@ifdead(\temp){
            \ifnum\sseq@thepage>\sseq@getdeathpage(\temp)\relax
                \sseq@error{The node (#1) perished on page \sseq@getdeathpage(\temp) so there is no reason to add an option to it on page \sseq@thepage}{}
            \fi
        }{}
    \fi
    \@xp\ifx\csname sseq@classstyle\sseq@thename(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@classstyle\sseq@thename(\temp)\endcsname{}}
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@classstyle\sseq@thename(\temp)\endcsname{#2,}
}

\def\sseq@doptions#1(#2){
    \sseq@tempcount=#1%%
    \edef\temp{\@nx\sseq@doptions@{\the\sseq@tempcount}{#2}}\temp%
}


\def\sseq@doptions@#1#2#3{
    \def\temp{#2}
    \ifsseq@fastmode
        \sseq@iffullcoord(#2){}{\edef\temp{\temp,1}}
    \else
        \sseq@iffullcoord(#2){
            \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
                \sseq@error{
                    There is only one node at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                    '\string\doptions#1\sseq@fullcoord@to@partialcoord(#2){#3}'%
                }
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}
            \fi
        }{
            \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
                \edef\temp{\temp,1}
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}
            \else
                \sseq@error{
                    There are multiple nodes at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                    '\string\doptions#1(#2,n){#3}' where 'n' is the number of the node you are referring to%
                }
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}
            \fi
        }
        \@ifundefined{sseq@thepage}{}{\ifnum\sseq@thepage=#1\relax\else\ifnum\sseq@thepage=0\else
            \sseq@error{Adding an option to a differential on page #1 when the current page is \sseq@thepage\sseq@macroname\ has no effect}{}
        \fi\fi}
    \fi
%
    \@xp\ifx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{}}
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{#3,}
}



%% Placement

\def\sseq@place{\@ifnextchar[{\sseq@place@}{\sseq@place@[]}}%}

\def\sseq@place@[#1](#2,#3){
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}
    \sseq@parsecoords\temp{#2,#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}
    \edef\next{\@nx\sseq@place@@(\temp){\the\sseq@temptoks}}%
    \next{#1} %
}

\def\sseq@place@@(#1,#2)#3#4{
    \sseq@tempx=#1\relax
    \advance\sseq@tempx\sseq@x
    \sseq@tempy=#2\relax
    \advance\sseq@tempy\sseq@y
    \edef\tempcoord{\the\sseq@tempx,\the\sseq@tempy}
    \sseq@xminmax{\the\sseq@tempx}\sseq@yminmax{\the\sseq@tempy}
    \sseq@tempcount=\@ifundefined{sseq@coord\sseq@thename(\tempcoord)@numnodespp}{1}{\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname}
    \edef\tempnodenum{\the\sseq@tempcount}
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodes\endcsname{\the\sseq@tempcount}
    \advance\sseq@tempcount1
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname{\the\sseq@tempcount}
%
    \sseq@temptoks{#3}% node text
%
    \sseq@temptoks@ii{\pgfkeysalso{#4}}% local options
%
    \@xp\gdef\csname sseq@placenum\sseq@thename(\tempcoord,\tempnodenum)\endcsname{0}% to make \replace work correctly
    % Classes that eventually die
    % we use deforaddto@macro here because this macro gets moved, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename(\tempcoord,\tempnodenum)0}{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}
            {\the\sseq@classoptionslist\the\sseq@thetranscyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname}}
        \endgroup
    }
%
    % Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}
            {\the\sseq@classoptionslist\the\sseq@thepermcyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname}}
        \endgroup
    }
%
    \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\tempcoord,\tempnodenum)}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname\relax}%
    \@xp\gdef\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname{}%
    \sseq@x@addto@macro\sseq@compilesseq{\@nx\sseq@setoffsets{\the\sseq@tempx}{\the\sseq@tempy}}%
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname}}
    %\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname}}
%
    % TODO: out of range nodes that eventually get hit get rendered anyways right now. Fix this.
    \ifnum\sseq@tempx<\sseq@xmaxpp\ifnum\sseq@tempx>\sseq@xminmm\ifnum\sseq@tempy<\sseq@ymaxpp\ifnum\sseq@tempy>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{% no need for defor since infty page initialized at begin{sseqdata}
%            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
%                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
%            \@nx\fi %
            \@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname %
        }%
    \fi\fi\fi\fi %
    \endgroup
}

\def\sseq@replace{\@ifnextchar[{\sseq@replace@}{\sseq@replace@[]}}%}

\def\sseq@replace@[#1](#2,#3){
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}
    \sseq@parsecommas(#2,#3)%
    \@xp\sseq@replace@@\@xp{\sseq@classnodetext}{#1}%
}

\def\sseq@replace@@#1#2{%
    \sseq@arg@checkpresent\replace1%
    \sseq@arg@checkpresent\replace2%
    \edef\coord{(\sseq@arg1,\sseq@arg2,\sseq@optarg{1}3)}
    \edef\coordname{(\sseq@arg1,\sseq@arg2\sseq@optargc3)}
    \sseq@ifundefcoord\coord{\sseq@error{There never was a class at \coordname\sseq@macroname\ so I cannot replace it}{}}{}%
    \sseq@ifdead\coord{}{\sseq@error{I cannot replace the class at \coordname\sseq@macroname\ because it seems to be alive and well}{}}%
    \sseq@tempcount=\csname sseq@placenum\sseq@thename\coord\endcsname\relax
    \advance\sseq@tempcount1
    \edef\tempclassversion{\the\sseq@tempcount}
    \@xp\xdef\csname sseq@placenum\sseq@thename\coord\endcsname{\the\sseq@tempcount}
%
    \sseq@temptoks{#1}% node text
%
    \sseq@temptoks@ii{\pgfkeysalso{#2}}% local options
%
    % Classes that eventually die
    % we use deforaddto@macro here because this macro gets moved around, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename\coord\tempclassversion}{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}
            {\the\sseq@classoptionslist\the\sseq@thetranscyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname}}
        \endgroup
        \@nx\fi
    }
%
    % Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}
            {\the\sseq@classoptionslist\the\sseq@thepermcyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname}}
        \endgroup
        \@nx\fi
    }
%
    \sseq@x@deforaddto@macro{sseq@clearinfty\sseq@thename\coord}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname\relax}%
    \ifnum\sseq@arg1<\sseq@xmaxpp\ifnum\sseq@arg1>\sseq@xminmm\ifnum\sseq@arg2<\sseq@ymaxpp\ifnum\sseq@arg2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{% no need for defor since infty page initialized at begin{sseqdata}
%            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
%                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
%            \@nx\fi %
            \@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname %
        }%
    \fi\fi\fi\fi %
    \sseq@cleardeathpage\coord
    \endgroup
}


% #1 -- x
% #2 -- \sseq@x shift (change name of node but position already accounted for)
% #3 -- y
% #4 -- \sseq@y
% #5 -- n
% #6 -- node text
% #7 -- options
\def\test#1#2#3#4#5#6#7{}
\def\sseq@place@drawnode#1#2#3#4#5#6#7{
    %\tracingall
    \sseq@tempx=#1\relax
    \advance\sseq@tempx#2\relax
    \sseq@tempy=#3\relax
    \advance\sseq@tempy#4\relax
    \edef\tempcoord{\the\sseq@tempx,\the\sseq@tempy,#5}
    \ifsseq@needstikz
        %\let\tikz@quote@parser\sseq@handlequote
        \sseq@temptoks{#6}
        \sseq@temptoks@ii{#7}
        \edef\temp{
            \@nx\node[
                /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote,
                /tikz/sseqpages/second pass,
                /utils/exec={\the\sseq@temptoks@ii}
            ] (sseq@{\tempcoord})
            at (#1\@xp\@nx\csname sseq@xoffset@\sseq@thename(\tempcoord)\endcsname,#3\@xp\@nx\csname sseq@yoffset@\sseq@thename(\tempcoord)\endcsname){\the\sseq@temptoks};
        }
        \temp
    \else
        \begingroup
        \pgfscope
        \let\tikz@options\pgfutil@empty
        \let\tikz@alias=\pgfutil@empty
        \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/}
        #7
        \pgftransformshift{\pgfpoint{#1 cm}{#3 cm}}%
        \tikz@options
        \tikz@node@textfont
        \sseq@setnodetext{#6}
        \edef\tikz@fig@name{sseq@{\tempcoord}}
        \iftikz@fullytransformed\else\pgftransformresetnontranslations\fi
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@xoffset@\sseq@thename(\tempcoord)\endcsname cm}{0\csname sseq@yoffset@\sseq@thename(\tempcoord)\endcsname cm}}}
        \temp
        \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}
        \tikz@alias
        \endpgfscope
        \endgroup
    \fi
}

\def\sseq@setnodetext#1{
    \setbox\pgfnodeparttextbox=\hbox{
        \pgfscope%
        \tikzset{every text node part/.try}%
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          #1%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

\def\sseq@drawnode{
  \pgfutil@tempdima=\pgflinewidth%
  {
    \tikz@mode%
    \iftikz@mode@clip \sseq@error{Clip shouldn't happen here, but this error should be caught earlier}{}\fi % TODO: catch this and similar errors?
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \edef\temp{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}\temp%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%% Offsets TODO: This section is pretty unfinished
\def\sseq@setoffsets#1#2{
    \@ifundefined{sseq@xoffset@\sseq@thename(#1,#2,1)}{\sseq@setoffsets@{#1}{#2}}{\sseq@checkoffsets{#1}{#2}}
}
\def\sseq@setoffsets@#1#2{
    \sseq@tempcount=\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname\relax
    \ifcase\sseq@tempcount\relax
        \sseq@error{Internal error. This should never happen}{}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{1}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{2}
        \sseq@usestdoffsets{#1}{#2}{2}{2}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{3}
        \sseq@usestdoffsets{#1}{#2}{2}{3}
        \sseq@usestdoffsets{#1}{#2}{3}{3}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{4}
        \sseq@usestdoffsets{#1}{#2}{2}{4}
        \sseq@usestdoffsets{#1}{#2}{3}{4}
        \sseq@usestdoffsets{#1}{#2}{4}{4}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{5}
        \sseq@usestdoffsets{#1}{#2}{2}{5}
        \sseq@usestdoffsets{#1}{#2}{3}{5}
        \sseq@usestdoffsets{#1}{#2}{4}{5}
        \sseq@usestdoffsets{#1}{#2}{5}{5}
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{6}
        \sseq@usestdoffsets{#1}{#2}{2}{6}
        \sseq@usestdoffsets{#1}{#2}{3}{6}
        \sseq@usestdoffsets{#1}{#2}{4}{6}
        \sseq@usestdoffsets{#1}{#2}{5}{6}
        \sseq@usestdoffsets{#1}{#2}{6}{6}
    \else
        \sseq@error{Too many nodes at coordinate (#1,#2). Improve this error message}{}
    \fi
}

\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}
\def\sseq@checkoffsets#1#2{} %TODO: Implement this

\sseq@setstdoffsets11{}{}
\sseq@setstdoffsets12{-0.13}{}
\sseq@setstdoffsets22{+0.13}{}

\def\sseq@usestdoffsets#1#2#3#4{
    \@xp\global\@xp\let\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdxoffset#3/#4\endcsname
    \@xp\global\@xp\let\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdyoffset#3/#4\endcsname
}


\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp(#3)%
}

\def\sseq@d@@#1#2(#3,#4){
%
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/differential}{#1}
    \sseq@parsecommas(#3,#4)
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2
    \edef\sourcecoord{\the\sseq@tempx,\the\sseq@tempy}
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}
    \edef\source{(\sourcecoord,\sseq@optarg{1}3)}%
%
%
    \sseq@parsecoords\targetcoord{\the\sseq@tempx + \sseq@targetx{#2},\the\sseq@tempy+\sseq@targety{#2}}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}
    \edef\target{(\targetcoord,\sseq@optarg{1}4)}%
%
%   Errors:
    \ifsseq@fastmode\else
        \sseq@ifundefcoord\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't support
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifundefcoord\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't accept
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifdead\source{%
            \ifnum\sseq@getdeathpage\source=#2\else
                \sseq@error{%
                    Source \sourcename\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't support
                    a differential because it already perished on page \sseq@getdeathpage\source %
                }{}%
            \fi
        }{}%
        \sseq@ifdead\target{%
            \ifnum\sseq@getdeathpage\target=#2\else
                \sseq@error{%
                    Target \targetname\sseq@macroname\ of differential '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' can't accept
                    a differential because it already perished on page \sseq@getdeathpage\target %
                }{}%
            \fi
        }{}%
%
        \ifnum\csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg3}{}{\sseq@error{
                There is only one node at source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)'%
            }{}}
        \else
            \@ifundefined{sseq@arg3}{\sseq@error{
                There are multiple nodes at source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname\sseq@macroname\ nodes at (\sourcecoord) should be the source%
            }{}}{}
        \fi
        \ifnum\csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname=1\relax
            \@ifundefined{sseq@arg4}{}{\sseq@error{
                There is only one node at target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)'%
            }{}}
        \else
            \@ifundefined{sseq@arg4}{\sseq@error{
                There are multiple nodes at target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname\sseq@macroname\ nodes at (\targetcoord) should be the target%
            }{}}{}
        \fi
    \fi
%
    \sseq@temptoks{\pgfkeysalso{#1}}% local options
%
    \sseq@x@deforaddto@macro{sseq@saveddiffs@\sseq@thename#2}{
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@d@drawedge\source\target{\the\sseq@doptionslist\the\sseq@temptoks\@nx\pgfkeysalso{\@xp\@nx\csname sseq@dstyle\sseq@thename#2\source\endcsname}}{}
        \endgroup
    }
%
    \@xp\gdef\csname sseq@dstyle\sseq@thename#2\source\endcsname{}%
%
    % Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} % This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\source\endcsname%
    \csname sseq@clearinfty\sseq@thename\target\endcsname%
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\source\endcsname\relax
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\target\endcsname\relax
%
    % Add placement on appropriate page
    \sseq@x@deforaddto@macro@noctx{sseq@savednodes@\sseq@thename#2}{%
        \sseq@ifdead\source{}{\@xp\@nx\csname sseq@place\sseq@thename\source\csname sseq@placenum\sseq@thename\source\endcsname\endcsname}%
        \sseq@ifdead\target{}{\@xp\@nx\csname sseq@place\sseq@thename\target\csname sseq@placenum\sseq@thename\target\endcsname\endcsname}%
    }%
%
    \sseq@setdeathpage\source{#2}%
    \sseq@setdeathpage\target{#2}%
    \endgroup
}

% #1 -- source
% #2 -- target
% #3 -- scope options
% #4 -- local and late options
\def\sseq@d@drawedge(#1)(#2)#3#4{
    \tikzset{#4}
    \ifsseq@needstikz
        \sseq@temptoks{#3}
        \edef\temp{\@nx\draw[draw,/tikz/sseqpages/second pass/differential,/utils/exec={\the\sseq@temptoks}] (#1) to (#2);}
        \temp
    \else
        \pgfscope
        \pgfqkeysalso{/tikz/sseqpages/second pass/differential}{draw}
        #3
        \tikz@options
        \tikz@mode
        \pgfpathmoveto{\pgfpointshapeborder{sseq@{#1}}{\pgfpointanchor{sseq@{#2}}{center}}}
        %\xdef\tikz@timer@start{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
        \pgfpathlineto{\pgfpointshapeborder{sseq@{#2}}{\pgfpointanchor{sseq@{#1}}{center}}}
        %\xdef\tikz@timer@end{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
        \edef\temp{\noexpand\pgfusepath{%
            \iftikz@mode@fill fill,\fi%
            \iftikz@mode@draw draw,\fi%
        }}\temp
        %\tikz@node@textfont
        %\def\tikz@time{0.5}
        %\tikz@do@auto@anchor%
        %\tikz@timer%
        %\tikz@timer@line
        %\tikz@transform
        %\pgfnode{rectangle}{\tikz@anchor}{hi}{}{\pgfusepath{draw}}
        \endpgfscope
    \fi
}

\def\sseq@addcontingentfeature#1#2{%
    \sseq@g@deforaddto@macro{sseq@feature\the\sseq@featurecount}{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    %\@xp\show\csname sseq@featureinfty\the\sseq@featurecount\endcsname
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
        \@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
%        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
%            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
%        \@nx\fi %
    }%
%    \@xp\show\csname sseq@featureinfty\the\sseq@featurecount\endcsname
    %
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        %\show\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        %\show\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
        %\sseq@temppage is defined by \d before it calls this.
        \@nx\sseq@g@deforaddto@macro@noctx{sseq@savednodes@\sseq@thename\@nx\sseq@temppage}{% needs to be defor in case this is placed before the nodes it connects.
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname %
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax %
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil,)%
    \global\advance\sseq@featurecount1%
}

\def\sseq@addcontingentfeature@(#1,#2){
    \ifx\sseq@nil#1\else %
        \sseq@parsecoords\temp{#1,#2}%
        \@xp\sseq@iffullcoord\@xp(\temp){}{
            \edef\temp{\temp,\@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}{1}{\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname}}
        }%
        \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\temp)}{% should be deforaddto, so that it will work even if this is called before the node is placed
            \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname %
        }%
    %
    %\@xp\show\csname sseq@feature\the\sseq@featurecount\endcsname
        \@xp\sseq@addcontingentfeature@ %
    \fi
}

\def\sseq@structline(#1)(#2){\edef\temp{\@nx\sseq@structline@\sseq@anchorsplit{#1}\sseq@anchorsplit{#2}}\temp}
\def\sseq@structline@#1#2#3#4{
    \sseq@parsecoords\source{#1}%
    %\@xp\sseq@iffullcoord\@xp(\source){}{\edef\source{\source,1}}
    \sseq@parsecoords\target{#3}%
    %\def\temp{#4}
  %  \show\temp
    %\@xp\sseq@iffullcoord\@xp(\target){}{\edef\target{\target,1}}
    \edef\temp{
        \@nx\sseq@structline@@
            \@xp\sseq@iffullcoord\@xp(\source)
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\source){,\@xp\sseq@fullcoord@lastelt\@xp(\source)}}
                {(\source){}}%{\@ifundefined{sseq@coord\sseq@thename(\source)@numnodes}{}{,\csname sseq@coord\sseq@thename(\source)@numnodes\endcsname}}}
            {#2}
            \@xp\sseq@iffullcoord\@xp(\target){
                \@xp\sseq@fullcoord@to@partialcoord\@xp(\target){,\@xp\sseq@fullcoord@lastelt\@xp(\target)}}
                {(\target){}}%{\@ifundefined{sseq@coord\sseq@thename(\target)@numnodes}{}{,\csname sseq@coord\sseq@thename(\target)@numnodes\endcsname}}}
            {#4}
    }%
    \temp %
}
\def\sseq@structline@@(#1,#2)#3#4(#5,#6)#7#8{
    \sseq@tempx=\sseq@x\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#5\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#6\relax
    \sseq@temptoks\@xp{\sseq@scopeoptions}%/utils/exec=\showthe\sseq@x}
    \def\sseq@na{#3}
    \ifx\sseq@na\pgfutil@empty\@ifundefined{sseq@coord\sseq@thename(\the\sseq@tempx,\the\sseq@tempy)@numnodes}{}
        {\edef\sseq@na{,\csname sseq@coord\sseq@thename(\the\sseq@tempx,\the\sseq@tempy)@numnodes\endcsname}}
    \fi
    \def\sseq@nb{#7}
    \ifx\sseq@nb\pgfutil@empty\@ifundefined{sseq@coord\sseq@thename(\the\sseq@tempxb,\the\sseq@tempyb)@numnodes}{}
        {\edef\sseq@nb{,\csname sseq@coord\sseq@thename(\the\sseq@tempxb,\the\sseq@tempyb)@numnodes\endcsname}}
    \fi

    %\edef\temp{(\the\sseq@tempx,\the\sseq@tempy#3)}
    \edef\temp{\@nx\sseq@addcontingentfeature{(\the\sseq@tempx,\the\sseq@tempy)(\the\sseq@tempxb,\the\sseq@tempyb)}
        {\@nx\draw[/tikz/sseqpages/second pass,\the\sseq@temptoks]\space(#1,#2\sseq@na) to (#5,#6\sseq@nb);}
    }
    \temp
}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


%% Redo tikz parsing rules for interpreting coordinates
% We want to intepret (x,y) as the name of a node.		
%
% Original behavior:
% The original parsing rule said roughly:
%   if there's a cs: treat it like a coordinate shift
%     if there's the word intersection: treat it as an intersection
%       ...
%        if there's a comma treat it as a literal coordinate
%          else treat it as the name of a node
%
% We replace the second to last step with:
%    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%      if there is such a node, treat it as refering to sseq@{x,y}
%      else treat it as a literal coordinate
%
% Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}


\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}
    \@xp\sseq@iffullcoord\@xp(\temp){}{
        \@ifundefined{sseq@coord\sseq@thename(\temp)@numnodes}{}
            {\ifnum\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname=1\relax\edef\temp{\temp,1}\fi}
            %{\edef\temp{\temp,\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname}}
    }
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid % Check if a node with name sseq@{x,y} is defined in this picture
        \def\tikztotarget{sseq@{\temp}}% fixes the bend left and bend right options (probably others)
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}
    \else %( % No such node exists
        \ifx&#4& % make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3})} % Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor '\@gobble#4'. In order to accept an anchor, there must be a node at the given location}{}
        \fi
    \fi
    \next
}

%% Patch \foreach to use sseq@context
% TODO: Add stuff for when this fails

\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\patchcmd\sseq@pgffor@invokebody % store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % store setting before
    {\ifx\pgffor@assign@before@code}
    {\sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}%
     \ifx\pgffor@assign@before@code}
    {}{\no}
\patchcmd\sseq@pgffor@invokebody % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@addtosavedtoks{\def#2{#4}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}


\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@xaddtosavedtoks{\def\@nx#1{\the#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@xaddtosavedtoks\@xp{\@xp\def\@xp#1\@xp{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@xaddtosavedtoks{\def\@nx#2{#1}}}}
    {}{\no}


\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@currentvar{\pgffor@temp}}}
    {}{\no}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@once@expanded}}
    {}{\no}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@expanded}}
    {}{\no}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\no}
