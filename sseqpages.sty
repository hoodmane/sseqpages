% TODO:
% Is global/.unknown right now? (I think so).
%
% add separate options to modify class labels and class text body
% named standard offset patterns with options
%
% User interface to change length of the axes and clipping at right and top of the picture (like y axis gap and x axis gap except mirrored)
% User interface to control arrow head for edges that go off page (option to turn ellipses off)
% 
% Fix edge drawing so that 'draw=none' makes edge not be stroked
% Make it so that \d and \structline work in \sseqpage environment
%
% Make a list of things I need to cover in the manual
% 
% still need context environment?
% add error checking for modified tikz code
%
% Email tikz people?

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{sseqpages}

\newif\ifsseq@versionwarn

\RequirePackage{tikz}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usetikzlibrary{positioning}
\usetikzlibrary{intersections}
\usepgflibrary{arrows.meta}

\DeclareOption{versionwarn}{\sseq@versionwarntrue}
\ProcessOptions\relax
\@ifpackagelater{tikz}{2015/07/08}{%
    \@ifpackagelater{tikz}{2015/08/08}{%
    \ifsseq@versionwarn
        \expandafter\PackageWarning
     \else
        \expandafter\PackageError
     \fi
     {sseqpages}{You are using a version of Tikz later than the version sseqpages was developed for. Something might go wrong. Please say 
     '\string\usepackage[version warn]{sseqpages}' to suppress this error message and let me (hood@mit.edu) know whether sseqpages works with your version of Tikz}{}
    }{%
        % Current version of tikz
    }
}{%
    \ifsseq@versionwarn
        \PackageWarning{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a.}
     \else
        \PackageError{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a. Please say 
        '\string\usepackage[version warn]{sseqpages}' to suppress this error message, then let me (hood@mit.edu) know whether sseqpages works with your version of Tikz. Or just update}{}
     \fi
    
}

% Ensure \@xp and \@nx have the correct values in case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords
\def\sseq@uptocomma#1,#2\sseq@nil{#1}
\def\sseq@fullcoord@to@partialcoord(#1,#2,#3){(#1,#2)}
\def\sseq@fullcoord@to@partialcoordb(#1,#2,#3){{#1cm}{#2cm}}
\def\sseq@fullcoord@lastelt(#1,#2,#3){#3}


%% Declarations
\newif\ifsseq@needstikz
\newif\ifsseq@classlabel
\newif\ifsseq@outofrange
\newif\ifsseq@thispage
\newif\ifsseq@globaldetone

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@scopeoptions
\newtoks\sseq@thislabelstyle

\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@featurecount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempcountb
\newcount\sseq@tempx
\newcount\sseq@tempy
\newcount\sseq@tempxb
\newcount\sseq@tempyb
\newdimen\sseq@tempxdim
\newdimen\sseq@tempydim
\newdimen\sseq@tempxadim
\newdimen\sseq@tempyadim
\newdimen\sseq@tempxbdim
\newdimen\sseq@tempybdim
\sseq@context@depth\z@
\sseq@context@tempcount\z@
\sseq@featurecount\z@
\sseq@x\z@ \sseq@y\z@
\sseq@tempcount\z@


\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii


%% \sseq@--@--addto@macro and friends.
% My own variants of \pgfutil@g@addto@macro.
% \sseq@x@addto@macro recursively expands the argument and then adds it.
% \sseq@g/x@deforaddto@macro checks first whether the macro is defined or not, if not it used \gdef or \xdef, else it uses \sseq@g/x@addto@macro
% The "ctx" variants are \let equal to the foreach versions when inside of \foreach or when the context command (not named yet) is used
% The "noctx" variants never are set equal to the foreach versions. These are primarily for use in defining internals, to prevent infinite loops
% The standard variants are \def'd to expand to a "ctx" variant when the "use context" option is requested
% Except now "use context" is gone, so they are always def'd to the ctx variant
% They also add saved state information to the macro the first time they add data to that macro
% TODO: Make context command / environment
\def\sseq@g@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1#2}\xdef#1{\the\pgfutil@toks@}\endgroup} % copy of \pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} % let #2 be expanded

\let\sseq@g@addto@macro@ctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@ctx\sseq@x@addto@macro
\let\sseq@g@addto@macro@noctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@noctx\sseq@x@addto@macro


\def\sseq@g@deforaddto@macro#1{\@ifundefined{#1}{\@xp\gdef\csname#1\endcsname}{\@xp\sseq@g@addto@macro@noctx\csname#1\endcsname}}
\def\sseq@x@deforaddto@macro#1{\@ifundefined{#1}{\@xp\xdef\csname#1\endcsname}{\@xp\sseq@x@addto@macro@noctx\csname#1\endcsname}}

\let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro
\let\sseq@g@deforaddto@macro@noctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@noctx\sseq@x@deforaddto@macro


\def\sseq@g@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@g@addto@macro@noctx#1%
}

\def\sseq@x@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@x@addto@macro@noctx#1%
}

\def\sseq@g@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@g@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@x@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@x@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@gx@addto@macro@foreach@#1{%
    \@ifundefined{sseq@context@\sseq@macroname#1}%
        {\sseq@context@tempcount=0\relax}%
        {\sseq@context@tempcount=\csname sseq@context@\sseq@macroname#1\endcsname\relax}%
    \ifnum\sseq@context@tempcount<\sseq@context@depth\relax %
        \loop %
            \advance\sseq@context@tempcount1\relax
            \sseq@for@addsavedtoksntomacro{\the\sseq@context@tempcount}{#1}%
        \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
        \@xp\edef\csname sseq@context@\sseq@macroname#1\endcsname{\the\sseq@context@depth}%
    \fi %
}

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@addtosavedtoks{\@xp\sseq@g@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@xaddtosavedtoks{\@xp\sseq@x@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@addsavedtoksntomacro#1#2{\@xp\@xp\@xp\sseq@g@addto@macro@noctx\@xp\@xp\@xp#2\@xp\@xp\@xp{\csname sseq@for@savedtoks#1\endcsname}}

\def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}%
\def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}%
\def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}%
\def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}

\def\sseq@g@addtosavedpaths{\@xp\sseq@g@addto@macro\sseq@savedpaths}
\def\sseq@x@addtosavedpaths{\@xp\sseq@x@addto@macro\sseq@savedpaths}
\def\sseq@g@addtosavedpaths@ctx{\@xp\sseq@g@addto@macro@ctx\sseq@savedpaths}
\def\sseq@x@addtosavedpaths@ctx{\@xp\sseq@x@addto@macro@ctx\sseq@savedpaths}
\def\sseq@savedpaths{\sseq@savedforegroundpaths}

%% Load/store
\def\sseq@storelist{}
\def\sseq@storelist@setdefaults{}
\def\sseq@addtostorelist#1{\sseq@addtostorelistopt#1{}}
\def\sseq@addtostorelistopt#1#2{%
    \@xp\def\@xp\sseq@storelist\@xp{\sseq@storelist\\#1}%
    \@xp\def\@xp\sseq@storelist@setdefaults\@xp{\sseq@storelist@setdefaults\gdef#1{#2}}%
}
\def\sseq@addiftostorelist#1{\sseq@addiftostorelistopt{#1}{false}}
\def\sseq@addiftostorelist@truedefault#1{\sseq@addiftostorelistopt{#1}{true}}
\def\sseq@addiftostorelistopt#1#2{%
    \@xp\newif\csname ifsseq@#1\endcsname
    \@xp\def\@xp\sseq@storelist\@xp{\sseq@storelist\sseq@storelistif{#1}}%
    \@xp\def\@xp\sseq@storelist@setdefaults\@xp{\sseq@storelist@setdefaults\@xp\global\csname sseq@#1#2\endcsname}%
}

% transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@storelist@store#1{\edef\sseq@temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\sseq@temp}
\def\sseq@storelist@get#1{\edef\sseq@temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\sseq@temp}

\def\sseq@storelistif@store#1{%
    \@xp\edef\csname sseq@storeif@#1\endcsname{\csname ifsseq@#1\endcsname \@xp\@nx\csname sseq@#1true\endcsname\else\@xp\@nx\csname sseq@#1false\endcsname\fi}%
    \@xp\sseq@storelist@store\csname sseq@storeif@#1\endcsname
}
\def\sseq@storelistif@get#1{
    \@xp\sseq@storelist@get\csname sseq@storeif@#1\endcsname
    \csname sseq@storeif@#1\endcsname
}

\def\sseq@storecmds{\let\\\sseq@storelist@store\let\sseq@storelistif\sseq@storelistif@store\sseq@storelist}
\def\sseq@getcmds{\let\\\sseq@storelist@get\let\sseq@storelistif\sseq@storelistif@get\sseq@storelist}

%%% Commands to help the user define "groups" and such of commands to be reused
\def\sseqnewgroup#1{\@ifnextchar[{\sseqnewgroup@#1}{\sseqnewgroup@#1[0]}}%]
\long\def\sseqnewgroup@#1[#2]#3{\sseqnewcmd@@#1(\sseq@macrox,\sseq@macroy)[#2]{\begin{scope}[xshift=\sseq@macrox,yshift=\sseq@macroy,\options]#3\end{scope}}}
\def\sseqnewcmd#1{\@ifnextchar({\sseqnewcmd@#1}{\sseqnewcmd@#1(\x,\y)}}%)
\def\sseqnewcmd@#1(#2,#3){\@ifnextchar[{\sseqnewcmd@@#1(#2,#3)}{\sseqnewcmd@@#1(#2,#3)[0]}}%]
\bgroup\lccode`\*=`\#\lowercase{\egroup
    \long\def\sseqnewcmd@@#1(#2,#3)[#4]#5{
        \ifnum#4>6 \sseq@error{Commands defined using '\@nx\sseqnewcmd' can take at most six arguments}\fi
        \edef\helpera{\@xp\@nx\csname \sseq@macroname#1@\endcsname}
        \edef\helperb{\@xp\@nx\csname \sseq@macroname#1@@\endcsname}
        \xdef#1{\@nx\@ifnextchar[{\@xp\@nx\helpera}{\@xp\@nx\helpera[]}}
        \@xp\xdef\helpera[##1](##2,##3){\@xp\@nx\helperb{##1}{##2}{##3}}
        \def\temp##1##2##3##4##5##6{#5}
        \sseq@temptoks\@xp{\temp\ppfour\ppfive\ppsix\ppseven\ppeight\ppnine}
        \bgroup
            \aftergroup\@xp\aftergroup\edef\aftergroup\helperb\aftergroup##\aftergroup1\aftergroup##\aftergroup2\aftergroup##\aftergroup3
            \ifnum#4>0\relax
                \sseq@tempcount=0\relax
                \sseq@tempcountb=3\relax
                \loop
                    \advance\sseq@tempcount1\relax\advance\sseq@tempcountb1\relax
                    \aftergroup####\@xp\aftergroup\the\sseq@tempcountb
                \ifnum\sseq@tempcount<#4\repeat
            \fi
            \aftergroup{
                \aftergroup\the\aftergroup\sseq@temptoks
            \aftergroup}
        \egroup
        \@xp\patchcmd\helperb{\options}{*1}{}{}
        \@xp\sseq@patchrepeat\helperb{#2}{*2}
        \@xp\sseq@patchrepeat\helperb{#3}{*3}
        \@xp\sseq@patchrepeat\helperb{\ppfour}{*4}
        \@xp\sseq@patchrepeat\helperb{\ppfive}{*5}
        \@xp\sseq@patchrepeat\helperb{\ppsix}{*6}
        \@xp\sseq@patchrepeat\helperb{\ppseven}{*7}
        \@xp\sseq@patchrepeat\helperb{\ppeight}{*8}
        \@xp\sseq@patchrepeat\helperb{\ppnine}{*9}
    }
}
\def\sseq@patchrepeat#1#2#3{\patchcmd#1{#2}{#3}{\sseq@patchrepeat#1{#2}{#3}}{}}



%%% Set up keys

% TODO: is this the right definition of \sseqset? Test it.
\def\sseqset{\pgfqkeys{/tikz/sseqpages/global}}
\def\sseqset@inprogress{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@set{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\edef\sseq@temp{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname=\the\sseq@temptoks}}\sseq@temp}

\pgfkeys{%
    /tikz/sseqpages/.is family,
    /tikz/sseqpages/.unknown/.code={\sseq@passoptionto{/tikz}},
    % \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    /tikz/sseqpages/global/.unknown/.code={%
        \let\sseq@tempa\pgfkeyscurrentname
        \let\sseq@tempb\pgfkeyscurrentvalue
        \pgfkeysifdefined{/tikz/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/tikz/\pgfkeyscurrentname}{}{%
            \pgfkeysifdefined{/tikz/sseqpages/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/tikz/sseqpages/\pgfkeyscurrentname}{}{%
                \sseq@error{Undefined global option '\pgfkeyscurrentname\@xp\ifx\pgfkeyscurrentvalue\pgfkeysnovalue\else=\pgfkeyscurrentvalue\fi'}%
            }}%
        }}%
        \pgfkeysalso{{\sseq@currentoptionpath} options/.append style/.expand twice={\@xp\sseq@tempa\@xp=\@xp{\sseq@tempb}}}%
    },
    /tikz/sseqpages/global/name only/.unknown/.code={},
    /tikz/sseqpages/first pass/.unknown/.code={},
    /tikz/sseqpages/first pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/class/.unknown/.code={%
        \expandafter\ifx\csname pgf@sh@s@\pgfkeyscurrentname\endcsname\relax % is it the name of a shape?
            \sseq@passoptionto{/tikz/sseqpages/first pass}%
        \else
            \edef\tikz@shape{\pgfkeyscurrentname}% if so, store it
        \fi
    },
    /tikz/sseqpages/first pass/class/labels/.unknown/.code={},
    /tikz/sseqpages/first pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/struct line/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/second pass/.is family,
    /tikz/sseqpages/second pass/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages}},
    /tikz/sseqpages/second pass/scope/.is family,
    /tikz/sseqpages/second pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/class/.is family,
    /tikz/sseqpages/second pass/class/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/class/labels/.is family,
    /tikz/sseqpages/second pass/class/labels/.unknown/.code={\sseq@passoptionto{/tikz}},
    /tikz/sseqpages/second pass/class/node texts/.is family,
    /tikz/sseqpages/second pass/class/node texts/.unknown/.code={\sseq@passoptionto{/tikz}},
    /tikz/sseqpages/second pass/differential/.is family,
    /tikz/sseqpages/second pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/struct line/.is family,
    /tikz/sseqpages/second pass/struct line/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/tikz primitives/.is family,
    /tikz/sseqpages/second pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    % One off directories
    /tikz/sseqpages/foreach/.unknown/.code={\sseq@passoptionto{/pgf/foreach}},
    /tikz/sseqpages/class placement/.unknown/.code={\sseq@passoptionto{/tikz}}
}

\pgfqkeys{/tikz/sseqpages/first pass/class}{shape/.code={\edef\tikz@shape{\pgfkeyscurrentname}}} % shape=whatever shape passing


\pgfqkeys{/tikz/sseqpages/first pass/class/labels}{% maybe implement multipart node labels this way? No way!
    node/.code={\sseq@classlabelfalse},
    inside/.code={\sseq@classlabelfalse},
    above/.code={\sseq@classlabeltrue},
    below/.code={\sseq@classlabeltrue},
    left/.code={\sseq@classlabeltrue},
    right/.code={\sseq@classlabeltrue},
    above left/.code={\sseq@classlabeltrue},
    above right/.code={\sseq@classlabeltrue},
    below left/.code={\sseq@classlabeltrue},
    below right/.code={\sseq@classlabeltrue}
}

\pgfqkeys{/tikz/sseqpages/second pass/class/labels}{
    node/.code={},
    inside/.code={},
    above/.code=      {\sseq@class@positionlabel{above}{#1}},
    above/.default={},
    below/.code=      {\sseq@class@positionlabel{below}{#1}},
    below/.default={},
    left/.code=       {\sseq@class@positionlabel{left}{#1}},
    left/.default={},
    right/.code=      {\sseq@class@positionlabel{right}{#1}},
    right/.default={},
    above left/.code= {\sseq@class@positionlabel{above left}{#1}},
    above left/.default={},
    above right/.code={\sseq@class@positionlabel{above right}{#1}},
    above right/.default={},
    below left/.code= {\sseq@class@positionlabel{below left}{#1}},
    below left/.default={},
    below right/.code={\sseq@class@positionlabel{below right}{#1}}
    below right/.default={}
}

\pgfqkeys{/tikz/sseqpages/second pass/class/node texts}{
    node/.code={},
    inside/.code={},
    above/.code=      {},
    below/.code=      {},
    left/.code=       {},
    right/.code=      {},
    above left/.code= {},
    above right/.code={},
    below left/.code= {},
    below right/.code={}
}


\def\sseq@class@positionlabel#1#2{\pgfqkeys{/tikz}{#1=#2 of \sseq@thisnodename}}

%% Quote handling
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\def\sseq@handleclassquotes#1#2{% We use this via \let\tikz@quotes@as\sseq@handleclassquotes
    /utils/exec={% So it's called inside \pgfkeysalso{stuff}. Need to surround with /utils/exec={} to get out.
        \begingroup
        \sseq@temptoks{#1}
        \sseq@temptoks@ii{#2}
        \pgfqkeys{/tikz/sseqpages/first pass/class/labels}{/utils/exec={\the\sseq@classstyle\the\sseq@classlabelstyle},#2}%
        \ifsseq@classlabel
            \sseq@x@addto@macro@noctx\sseq@classlabelnodes{%
                \@nx\ifsseq@needstikz
                    node[
                        /tikz/sseqpages/second pass/class/labels,
                        /utils/exec={\sseq@thelabelstyle\sseq@theclasslabelstyle},\the\sseq@temptoks@ii,
                        /utils/exec={
                            \@nx\iftikz@fullytransformed\@nx\else 
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                         }                        
                    ]{\the\sseq@temptoks}%
                \@nx\else
                    \@nx\node[
                        /tikz/sseqpages/second pass/class/labels,
                        /utils/exec={\sseq@thelabelstyle\sseq@theclasslabelstyle},\the\sseq@temptoks@ii,
                        /utils/exec={
                            \@nx\iftikz@fullytransformed\@nx\else 
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                         }
                    ]{\the\sseq@temptoks};%
                \@nx\fi
            }%
        \else
            \gdef\sseq@classnodetext{#1}%
            \xdef\sseq@classnodetextoptions{
                \def\@nx\pgfkeysdefaultpath{/tikz/sseqpages/second pass/class/node texts}
                \sseq@thelabelstyle\sseq@theclasslabelstyle\the\sseq@temptoks@ii
            }%
        \fi
        \endgroup
    }%
}
\def\sseq@classnodetext{}
\def\sseq@classnodetextoptions{}
\def\sseq@classlabelnodes{}

\pgfkeys{%
    /tikz/sseqpages/first pass/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /tikz/sseqpages/first pass/class/handle quote/.code={%
        \begingroup
        \let\tikz@quotes@as\sseq@handleclassquotes
        \tikz@quote@parser{#1}
        \endgroup
    },
    /tikz/sseqpages/first pass/differential/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/first pass/struct line/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/second pass/class/handle quote/.code={},
    /tikz/sseqpages/handle quote/.code={\tikzset{every to/.append style={#1}}}
}

%% Parsing, background vs foreground, and context
\def\sseq@standardparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@old
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transformations
    \let\sseq@shifttransform\sseq@okaytransform
    \let\sseq@firstpass@shifttransform\@gobbletwo
    \def\place{\sseq@error{You cannot use \@nx\place\sseq@macroname in standard parse mode}{}}%
    \def\replace{\sseq@error{You cannot use \@nx\replace\sseq@macroname in standard parse mode}{}}%
    \def\d{\sseq@error{You cannot use \@nx\d\sseq@macroname in standard parse mode}{}}%
}

\def\sseq@nodeparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform
    \let\place\sseq@place
    \let\replace\sseq@replace
    \let\d\sseq@d
}

\def\sseq@errortikzprimsonly#1{\sseq@error{You can only use '#1' as an option for tikz primitives, not for \@nx\place, \@nx\replace\sseq@macroname\ or \@nx\d}{}}

\sseq@set{%
    standard parse/.code={\sseq@standardparse},
    node parse/.code={\sseq@nodeparse},
    background/.code={\pgfkeysalso{standard parse}},
    foreground/.code={\pgfkeysalso{node parse}} %TODO: track original mode (node parse vs standard parse) and restore it?
}


\pgfqkeys{/tikz/sseqpages/first pass}{%
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform},
    background/.code={\def\sseq@savedpaths{\sseq@savedbackgroundpaths}\pgfkeysalso{standard parse}},
    foreground/.code={\def\sseq@savedpaths{\sseq@savedforegroundpaths}\pgfkeysalso{node parse}}% is this okay?
}


\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/first pass/differentials}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ % This is only for scope and tikz primitives, but in other cases, it emits an error on first pass.
    needs tikz/.code={},
    class/transform shape/.code={\pgfsettransform{\savetransform}\pgfqkeys{/tikz/sseqpages/class transform}{transform shape}}
}

%% Needs tikz
% Force \place or \d to fall back to using tikz to render their output
% Rather than using the faster direct \pgf primitives (largely copied from tikz to maximize compatibility)
% Drawing with tikz is slower, but I don't want to reimplement these features

\pgfqkeys{/tikz/sseqpages/first pass}{%
    needs tikz/.code=\sseq@needstikztrue,
    shade/.code=\sseq@needstikztrue,
    blend mode/.code=\sseq@needstikztrue,
    pattern/.code=\sseq@needstikztrue,
    path picture/.code=\sseq@needstikztrue,
    path fading/.code=\sseq@needstikztrue,
    decorate/.code=\sseq@needstikztrue,
    pin/.code=\sseq@needstikztrue,
    label/.code=\sseq@needstikztrue
}

% multipart shapes and alignment to be done with tikz
\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    circle split/.code=\sseq@needstikztrue,
    circle solidus/.code=\sseq@needstikztrue,
    ellipse split/.code=\sseq@needstikztrue,
    rectangle split/.code=\sseq@needstikztrue,
    align/.code=\sseq@needstikztrue,
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\place' command. You should use 'alias' instead}{}}
}


% Force differential to be drawn with tikz if it is bent
\pgfqkeys{/tikz/sseqpages/first pass/differential}{%
    bend left/.code=\sseq@needstikztrue,
    bend right/.code=\sseq@needstikztrue,
    in/.code=\sseq@needstikztrue,
    out/.code=\sseq@needstikztrue,
    controls/.code=\sseq@needstikztrue,
    in control/.code=\sseq@needstikztrue,
    out control/.code=\sseq@needstikztrue,
    loop/.code=\sseq@needstikztrue,
    loop above/.code=\sseq@needstikztrue,
    loop below/.code=\sseq@needstikztrue,
    loop left/.code=\sseq@needstikztrue,
    loop right/.code=\sseq@needstikztrue
}


%% Style options

\bgroup\catcode` =\active
\gdef\sseq@activespace{ }
\egroup
\def\sseq@newstyles{\bgroup\catcode` =\active\sseq@newstyles@}
\def\sseq@newstyles@#1{\egroup\sseq@newstyles@@#1\sseq@nil}
\def\sseq@newstyles@@#1,{\sseq@newsseqstyle{#1}\sseq@newstyles@@goblespaces}
\def\sseq@newstyles@@goblespaces{\@xp\@ifnextchar\sseq@activespace{\@xp\sseq@newstyles@@goblespaces\@gobble}{\@ifnextchar\sseq@nil{\@gobble}{\sseq@newstyles@@}}}

\def\sseq@set@newstyle#1{\pgfqkeys{/tikz/sseqpages}{#1}\pgfqkeys{/tikz/sseqpages/global}{#1}\pgfqkeys{/tikz/sseqpages/first pass}{#1}}


\def\sseq@newsseqstyle#1{%
    \@xp\def\sseq@activespace{}
    \edef\sseq@tempcmd{\csname sseq@#1style\endcsname}%
    \@xp\edef\csname sseq@the#1style\endcsname{\@nx\the\sseq@tempcmd\@nx\@nx\@nx\the\sseq@tempcmd}
    \@xp\let\sseq@activespace\space
    \@xp\newtoks\sseq@tempcmd
    \sseq@set@newstyle{
        every #1/.ecode={\sseq@tempcmd{\@nx\pgfkeysalso{##1}}},
        #1s/.ecode={\sseq@tempcmd\@nx\@xp{\@nx\the\sseq@tempcmd\@nx\pgfkeysalso{##1}}}
    }%
}

\sseq@newstyles{ % Make sure to put a comma after the last entry
    sseq, path, node,
    class, permanent cycle, transient cycle, this page cycle,
    edge, differential, struct line, this page struct line,
    label, class label,  edge label, differential label, struct line label,
}

\sseq@set@newstyle{classes/.style={classs={#1}}}% "class" has a nonstandard plural

%% Global options
\def\sseq@xlabelstep{1}
\def\sseq@ylabelstep{1}
\pgfqkeys{/tikz/sseqpages/global/name only}{
    name/.code={\name{#1}},
    name/.value required
}
\pgfqkeys{/tikz/sseqpages/global}{%
    name/.code={},
    page/.code={\page{#1}},
    degree/.code 2 args={\sseq@degree{#1}{#2}},
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
% axes options:    
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    axes gap/.code={\def\sseq@xaxisgap{#1}\def\sseq@yaxisgap{#1}},
    x axis gap/.code={\def\sseq@xaxisgap{#1}},
    x axis gap/.value required,
    y axis gap/.code={\def\sseq@yaxisgap{#1}},
    y axis gap/.value required,
    no x axis/.code={\sseq@drawxaxisfalse},
    no x axis/.value forbidden,
    draw x axis/.is if=sseq@drawxaxis,
    no y axis/.code={\sseq@drawyaxisfalse},
    no y axis/.value forbidden,
    draw y axis/.is if=sseq@drawyaxis,
    no axes/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    no axes/.value forbidden,
    draw axes/.is choice,
    draw axes/true/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue},
    draw axes/false/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    draw axes/.default=true,
    no x axis labels/.code={\sseq@drawxaxislabelsfalse},
    no x axis labels/.value forbidden,
    draw x axis labels/.is if=sseq@drawxaxislabels,
    no y axis labels/.code={\sseq@drawyaxislabelsfalse},
    no y axis labels/.value forbidden,
    draw y axis labels/.is if=sseq@drawyaxislabels,
    no axes labels/.code={\sseq@drawxaxislabelsfalse\sseq@drawyaxislabelsfalse},
    no axes labels/.value forbidden,
    draw axes labels/.is choice,
    draw axes labels/true/.code={\sseq@drawxaxistrue\sseq@drawyaxistrue},
    draw axes labels/false/.code={\sseq@drawxaxisfalse\sseq@drawyaxisfalse},
    draw axes labels/.default=true,
    draw differentials/.is if=sseq@drawdifferentials,
    no differentials/.code={\sseq@drawdifferentialsfalse},
    no differentials/.value forbidden,
    draw struct lines/.is if=sseq@drawstructlines,
    no struct lines/.code={\sseq@drawstructlinesfalse},
    no struct lines/.value forbidden,
    rotate labels/.is if=sseq@rotatelabels,
    label step/.code={\def\sseq@xlabelstep{#1}\def\sseq@ylabelstep{#1}},
    label step/.value required,
    x label step/.store in=\sseq@xlabelstep,
    y label step/.store in=\sseq@ylabelstep,
    class placement transform/.code={%
        \bgroup
        \let\tikz@transform\pgfutil@empty
        \pgfqkeys{/tikz/sseqpages/class placement}{#1}%
        \global\let\sseq@classplacementtransform\tikz@transform
        \egroup
    },
    class placement transform/.value required
}
\sseq@addtostorelistopt\sseq@xaxisgap{0.5cm}\sseq@addtostorelistopt\sseq@yaxisgap{0.5cm}
\sseq@addiftostorelist@truedefault{drawxaxis}\sseq@addiftostorelist@truedefault{drawyaxis}
\sseq@addiftostorelist@truedefault{drawxaxislabels}\sseq@addiftostorelist@truedefault{drawyaxislabels}
\sseq@addiftostorelist@truedefault{drawdifferentials}\sseq@addiftostorelist@truedefault{drawstructlines}
\sseq@addiftostorelist@truedefault{rotatelabels}
\sseq@addtostorelistopt\sseq@xlabelstep{1}\sseq@addtostorelistopt\sseq@ylabelstep{1}
\sseq@addtostorelist\sseq@classplacementtransform


% Global transformations
\sseq@globaldetonetrue
\sseq@addtostorelist\sseq@globaldetonetransform
\sseq@addtostorelist\sseq@globalrotatetransform
\sseq@addtostorelist\sseq@globalscaletransform

\def\sseq@globaldetoneoption#1#2{%
    \ifsseq@globaldetone
        \@xp\gdef\@xp\sseq@globaldetonetransform\@xp{\sseq@globaldetonetransform #1}%
        #1
    \else
        \sseq@error{You cannot use the option '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option after using 'xscale', 'yscale', or 'scale'. Please move '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' before any scaling options}
    \fi
}
\def\sseq@globalscaleoption#1{%
    \sseq@globaldetonefalse
    \@xp\gdef\@xp\sseq@globalscaletransform\@xp{\sseq@globalscaletransform#1}#1
}
\pgfqkeys{/tikz/sseqpages/global}{%
    xshift/.code={\sseq@errorillegalasglobal{xshift}},
    yshift/.code={\sseq@errorillegalasglobal{yshift}},
    shift/.code={\sseq@errorillegalasglobal{shift}},
    scale around/.code={\sseq@errorillegalasglobal{scale around}},
    rotate around/.code={\sseq@errorillegalasglobal{rotate around}},
    rotate/.code={%
        \@xp\gdef\@xp\sseq@globalrotatetransform\@xp{\sseq@globalrotatetransform\pgftransformrotate{#1}}%
        \sseq@globaldetoneoption{\pgftransformrotate{#1}}{rotate}%
    },
    rotate/.value required,
    xslant/.code={\sseq@globaldetoneoption{\pgftransformxslant{#1}}{xslant}},
    xslant/.value required,
    yslant/.code={\sseq@globaldetoneoption{\pgftransformyslant{#1}}{yslant}},
    yslant/.value required,
    xmirror/.code={\sseq@globaldetoneoption{\pgftransformxscale{-1}}{xmirror}},
    xmirror/.value forbidden,
    ymirror/.code={\sseq@globaldetoneoption{\pgftransformyscale{-1}}{ymirror}},
    ymirror/.value forbidden,
    xscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax%
            \sseq@error{You said 'xscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'xmirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformxscale{#1}}%
    },
    xscale/.value required,
    yscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax
            \sseq@error{You said 'yscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'ymirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformyscale{#1}}%
    },
    yscale/.value required,
    scale/.code={\sseq@globalscaleoption{\pgftransformscale{#1}}},
    scale/.value required
}

\pgfqkeys{/tikz/sseqpages/class placement}{
    x shift/.code={\sseq@error@noclassplacementshift{x shift}{#1}},
    y shift/.code={\sseq@error@noclassplacementshift{y shift}{#1}},
    shift/.code={\sseq@error@noclassplacementshift{shift}{#1}}
}

\sseq@set{%
    name/.code={\sseq@error@optionglobalonly{name}},
    page/.code={\sseq@error@optionglobalonly{page}},
    x range/.code 2 args={\sseq@error@optionglobalonly{x range}},
    y range/.code 2 args={\sseq@error@optionglobalonly{y range}},
    grid/.code={\sseq@error@optionglobalonly{grid}},
    labels/.code={\sseq@error@optionglobalonly{labels}},
    x labels/.code={\sseq@error@optionglobalonly{x labels}},
    y labels/.code={\sseq@error@optionglobalonly{y labels}},
    label step/.code={\sseq@error@optionglobalonly{labelstep}},
    x label step/.code={\sseq@error@optionglobalonly{x labelstep}},
    y label step/.code={\sseq@error@optionglobalonly{y labelstep}}
}


%% setup for coordinate transformation keys
\sseq@set{%
    x/.code={\sseq@error@optionillegal{x}{#1}{}},
    y/.code={\sseq@error@optionillegal{y}{#1}{}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{xshift}{#1}},
    xshift/.value required,
    yshift/.code={\sseq@shifttransform{yshift}{#1}},
    yshift/.value required,
    shift/.code={\sseq@transform{shift}{#1}},
    shift/.value required,
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    xscale/.value required,
    yscale/.code={\sseq@transform{yscale}{#1}},
    yscale/.value required,
    scale/.code={\sseq@transform{scale}{#1}},
    scale/.value required,
    scale around/.code={\sseq@transform{scale around}{#1}},
    scale around/.value required,
    xslant/.code={\sseq@transform{xslant}{#1}},
    xslant/.value required,
    yslant/.code={\sseq@transform{yslant}{#1}},
    yslant/.value required,
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate/.value required,
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    rotate around/.value required,
    cm/.code={\sseq@transform{cm}{#1}},
    cm/.value required,
    reset cm/.code={\sseq@transform{reset cm}{}},
    reset cm/.value forbidden,
    transform canvas/.code={\sseq@transform{transform canvas}{#1}},
    transform canvas/.value required
}

% Catch shifts on first pass to update \sseq@x, \sseq@y
\pgfqkeys{/tikz/sseqpages/first pass}{%
    xshift/.code={\sseq@firstpass@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@firstpass@shifttransform{yshift}{#1}}
}

\pgfqkeys{/tikz/sseqpages/second pass/class}{%
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages/second pass/differential}{%
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages}{
    description/.code={
        \pgfkeysalso{/tikz/anchor=center}
        \def\sseq@edgeoptionhook{\pgfkeysalso{/tikz/fill=white}}
    }
}
\def\sseq@edgeoptionhook{}


\def\sseq@error@optionillegal#1#2#3{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}%
}

\def\sseq@error@optionglobalonly#1{%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]')%
    }{}%
}

\def\sseq@error@illegalasglobal#1{
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option, but option '#1' is illegal as a global option
    }
}


\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@error@illegaltransform#1#2{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}%
}

\def\sseq@firstpass@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
    }{\sseq@error@illegaltransform{#1}{#2}}%
}
\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform

\def\sseq@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
        \edef\sseq@temp{\@nx\sseq@okaytransform{#1}{#2 cm}}%
        \sseq@temp
    }{\sseq@error@illegaltransform{#1shift}{#2}}%
}

\def\sseq@okayshifttransform#1#2{%
    \pgfmathparse{#2}
    \ifpgfmathunitsdeclared
        \def\temp{/tikz/#1=#2}
    \else
        \def\temp{/tikz/#1=#2cm}
    \fi
    \@xp\pgfkeysalso\@xp{\temp}%
}



\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%%% Internal utilities
\def\sseq@iffullcoord(#1){\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

% apparently only works for full
\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){%
    \@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}%
        {\@firstoftwo}%
        {\ifnum#3<\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}%
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}


\def\sseq@whichclass#1#2#3#4#5{%
    \edef#1{#4}%
    \ifx#1\pgfutil@empty % If no index is provided, just use 1
        \edef#1{1}%
        %\@ifundefined{sseq@coord\sseq@thename(#2,#3)@numnodes}
        %    {\edef#1{1}}%
        %    {\edef#1{\csname sseq@coord\sseq@thename(#2,#3)@numnodes\endcsname}}%
    \else
        \ifnum#4<0% Negative case -- why this command exists
            \@ifundefined{sseq@coord\sseq@thename(#2,#3)@numnodes}{% TODO: Consider suppressing this error if #1=-1? (probably not a good idea).
                \sseq@error{Error: negative index #4 provided for #5 of \sseq@thiscmdname '\sseq@thiscall' but no classes yet exist in #5 position (#2,#3).
                    Negative indices count from the most recent class in the given position; in particular, there must be at least one existing class}{}
            }{%
                \sseq@tempcount=\csname sseq@coord\sseq@thename(#2,#3)@numnodes\endcsname\relax
                \advance\sseq@tempcount#4\relax
                \advance\sseq@tempcount1\relax
                \ifnum\sseq@tempcount<1\relax
                    \sseq@error{Error: index #4 provided for the #5 of \sseq@thiscmdname '\sseq@thiscall' is out of bounds -- fewer than \@gobble#4 classes exist at #5 position (#2,#3)}{}
                \fi
                \edef#1{\the\sseq@tempcount}%
            }%
        \fi
    \fi % TODO: Check here whether the given class is dead and throw an error
}

%% Parsers
% These are very internal commands. They work. I should probably never touch or look at them again.

% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\pgfmathparse{#2}\edef\sseq@temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\sseq@temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax
    \ifnum\sseq@commacount<4 % This causes an error without a space I think?
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1\relax
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%% Command redefinition commands

% Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@
    \fi %
}

% Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@tikzcommands{%
        \clip\coordinate\draw\fill\filldraw
        \graph\matrix\node\path\pattern
        \shade\shadedraw\useasboundingbox
}

\def\sseq@modtikzcommands@defer{%
    \let\scope\sseq@scope
    \let\endscope\sseq@endscope
    \@xp\sseq@modtikzcommands@defer@\sseq@tikzcommands\sseq@nil
}
\def\sseq@modtikzcommands@defer@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@defer@\fi}
\def\sseq@defer@tikzcommand#1#2;{%
    \begingroup
    \sseq@temptoks{}%
    \sseq@changeoptiondirectory{#1}#2;[\sseq@nil]%
    \edef\temp{\@nx\pgfqkeys{/tikz/sseqpages/first pass/tikz primitives}{\the\sseq@temptoks}}\temp
    \sseq@x@addtosavedpaths@ctx{\the\sseq@temptoks@ii}%@ctx variant so that tikz primitives always "use context"
    \endgroup
}

\def\sseq@defer@tikzcommand@getoptions#1[#2]{\ifx#2\sseq@nil\else\sseq@temptoks\@xp{\the\sseq@temptoks#2,}\@xp\sseq@defer@tikzcommand@getoptions\fi}

\def\sseq@changeoptiondirectory#1#2[#3]{
    \ifx\sseq@nil#3%
        \sseq@temptoks@ii{#1#2}%
    \else
        \sseq@temptoks\@xp{\the\sseq@temptoks,#3}%
        \sseq@ifhop{\sseq@changeoptiondirectory{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%
    \fi
}


\def\sseq@modtikzcommands@options{}%\let\sseq@path@stored\path\def\path##1;{\sseq@changeoptiondirectory{\sseq@path@stored}##1;[\sseq@nil]}}

\def\sseq@modtikzcommands@options@#1{%
    \ifx\sseq@nil#1\else
        \@xp\let\csname sseq@\sseq@macroname#1@stored\endcsname#1%
        \edef#1##1;{\@nx\sseq@changeoptiondirectory{\@xp\@nx\csname sseq@\sseq@macroname#1@stored\endcsname}##1;[\@nx\sseq@nil]}%
        \@xp\sseq@modtikzcommands@options@
    \fi
}

% TODO: deal with the style "every scope" (by emptying it defensively I think)
\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{%
    \pgfqkeys{/tikz/sseqpages/first pass/scope}{#1}%
    \sseq@scopeoptions\@xp{\the\sseq@scopeoptions\pgfkeysalso{#1}}%
    \sseq@g@addtosavedpaths{\begin{scope}[/tikz/sseqpages/second pass/scope,#1]}%
}
\def\sseq@endscope{\sseq@g@addtosavedpaths{\end{scope}}}



%% Environment definitions

\sseq@addtostorelist\sseq@savedbackgroundpaths 
\sseq@addtostorelist\sseq@savedforegroundpaths
\sseq@addtostorelist\sseq@xmin\sseq@addtostorelist\sseq@xmax 
\sseq@addtostorelist\sseq@ymin\sseq@addtostorelist\sseq@ymax 
\sseq@addtostorelistopt\sseq@maxpage{0}

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]#2{%
%
    \sseq@storelist@setdefaults
%
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
    % These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    %
    % These are used to decide whether to add a certain node to savedpaths.
    % In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    % If the user doesn't specify a range, all nodes should be rendered
    % To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
    % copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\replace\d\degree %
        \structline %
    }%
    \@ifundefined{sseq@targetx}{\let\d\sseq@d@error@nodegree}{}
%
    \sseq@data@name{#2}%
    \gdef\sseq@compilesseq{}%    
%
    % the default option handler for /tikz/sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \pgfqkeys{/tikz/sseqpages/global}{{\sseq@thename} options/.code={},#1}%
    %To give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \edef\temp{\global\let\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname}%
    \temp
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
%
    \@xp\gdef\csname sseq@savednodes@\sseq@thename infty\endcsname{}%
    \@xp\gdef\csname sseq@savedfeatures@\sseq@thename infty\endcsname{}%
    % Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \sseq@tempcount=0\relax
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@saveddiffs@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
    }%
%
    \sseq@modtikzcommands@defer % Defer evaluation of tikz primitives
    \sseq@patchfor % patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} % install quotes parsing
    \selectfont\nullfont
    \def\par{}%
}

% Store the savedpaths and ranges
\def\endsseqdata{%
    %\@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
    \sseq@compilesseq
    \bgroup
    \sseq@storecmds
    \egroup
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{%
    % Copy commands into user namespace
    \sseq@copypagecommands{\name\page\classoptions\doptions\xrange\yrange}%
%
    \gdef\sseqpage@cleanup{} % For undoing local option settings
    \pgfqkeys{/tikz/sseqpages/global/name only}{#1}
    \def\sseq@currentoptionpath{this page}%
    \pgfqkeys{/tikz/sseqpages/global}{{this page} options/.code={},#1}%
    %
    % Defer evaluation of all tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}%
    \sseq@patchfor %
    \selectfont\nullfont
    \def\par{}%
}

\def\endsseqpage{%
    % Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \pgfkeys{%
      /tikz/edge quotes mean={%
        edge node={node [%execute at begin node=$,%$
                         %execute at end node=$,%$
                         auto=right,/tikz/sseqpages,
                         /utils/exec={\let\sseq@shifttransform\sseq@okayshifttransform\let\sseq@transform\sseq@okaytransform\the\sseq@thislabelstyle},
                         ##2,
                         /utils/exec={
                            \ifsseq@rotatelabels\iftikz@fullytransformed\else \tikz@fullytransformedtrue\tikz@addtransform{\pgftransformresetnontranslations\sseq@globalrotatetransform}\fi\fi
                            \sseq@edgeoptionhook
                         }
                   ]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform % Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \edef\temp{\@nx\begin{tikzpicture}[/tikz/sseqpages,/utils/exec={\the\sseq@sseqstyle},/tikz/sseqpages/global/{\sseq@thename} options,/tikz/sseqpages/global/{this page} options]}%
    \temp    
    \sseq@globaldetonetransform
    \sseq@globalscaletransform
    \tikzset{%
        z=0pt,
        every path/.style={},
        every node/.style={}
    }%
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
    %
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    \begingroup % for \sseq@modtikzcommands@options
    \sseq@modtikzcommands@options
    \sseq@savedbackgroundpaths
    \endgroup
    
    \ifsseq@drawxaxis 
        \sseq@drawxaxis
        \ifsseq@drawxaxislabels
            \sseq@drawxlabels    
        \fi
    \fi
    \ifsseq@drawyaxis
        \sseq@drawyaxis
        \ifsseq@drawyaxislabels
            \sseq@drawylabels
        \fi
    \fi
    \sseq@clip
%
%
    % Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
%
    % Insert nodes from all pages on or after the current one
        \sseq@tempcount=\sseq@thepage\relax
        \sseq@thispagetrue
        \csname sseq@savednodes@\sseq@thename\the\sseq@tempcount\endcsname
        \sseq@thispagefalse
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@savednodes@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
        \csname sseq@savednodes@\sseq@thename infty\endcsname
%
%
    \ifsseq@drawstructlines
        \sseq@tempcount=\sseq@thepage\relax
        \sseq@thispagetrue
        \csname sseq@savedfeatures@\sseq@thename\the\sseq@tempcount\endcsname
        \sseq@thispagefalse
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@savedfeatures@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
        \csname sseq@savedfeatures@\sseq@thename infty\endcsname
    \fi
%
    % Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    \ifsseq@drawdifferentials    
    \csname sseq@saveddiffs@\sseq@thename\sseq@thepage\endcsname %
    \fi
%
    % dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@modtikzcommands@options
    \sseq@savedforegroundpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup % blank any options special to this page
    \let\sseq@thename\relax %
}

\def\sseq@xlabelgap{0.5cm}
\def\sseq@ylabelgap{0.5cm}
\def\sseq@xaxis@start@extend{0.4cm}
\def\sseq@yaxis@start@extend{0.4cm}
\def\sseq@xaxis@end@extend{0.5cm}
\def\sseq@yaxis@end@extend{0.5cm}
\def\sseq@xclip@axisgap{0.1cm}
\def\sseq@yclip@axisgap{0.1cm}
\def\sseq@xclip@extend{0.1cm}
\def\sseq@yclip@extend{0.2cm}



\def\sseq@drawxaxis{%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    %
    \bgroup
    \pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}%
    \egroup
    \bgroup
    \pgftransformxshift{-\sseq@yaxisgap}
    \pgftransformxshift{-\sseq@ylabelgap}
    \pgftransformxshift{-\sseq@xaxis@start@extend}
    \pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfusepath{stroke}%
}
\def\sseq@drawyaxis{%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    \bgroup
    \pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \pgftransformyshift{-\sseq@xaxisgap}
    \pgftransformyshift{-\sseq@xlabelgap}
    \pgftransformyshift{-\sseq@yaxis@start@extend}
    \pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfusepath{stroke}%
%   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}

\def\sseq@drawxlabels{%
    \sseq@tempy=\sseq@ymin\relax
    %\advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}%
    \sseq@tempx=\sseq@xmin\relax
    \loop
        \bgroup
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformyshift{-\sseq@xlabelgap}\pgftransformyshift{-\sseq@xaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempx$}%
        \egroup
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}

\def\sseq@drawylabels{%
    \sseq@tempx=\sseq@xmin\relax
    %\advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@temp{\the\sseq@tempy}%
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \bgroup
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformxshift{-\sseq@ylabelgap}\pgftransformxshift{-\sseq@yaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempy$}%
        \egroup
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@temp\repeat
}



\def\sseq@clip{%
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    \def\xmin{\pgftransformxshift{-\sseq@yaxisgap}\pgftransformxshift{\sseq@xclip@axisgap}}
    \def\ymin{\pgftransformyshift{-\sseq@xaxisgap}\pgftransformyshift{\sseq@yclip@axisgap}}
    \def\xmax{\pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformxshift{\sseq@xclip@extend}}
    \def\ymax{\pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformyshift{\sseq@yclip@extend}}
    \bgroup
    \xmin\ymin\sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \egroup
    \bgroup
    \xmin\ymax\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \xmax\ymax\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymax cm}}%
    \egroup
    \bgroup
    \xmax\ymin\sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}%
    \egroup
    \egroup
    \pgfpathclose
    \pgfgetpath\sseq@theclippath % This stores the clipping so I can find intersections later
    \pgfusepath{clip}% This has to be after the egroup or else the clipping gets screwed up
}

\def\printpage[#1]{%
    \begin{sseqpage}[#1]%
    \end{sseqpage}%
}


%% Options and primitives for sseqdata and sseqpage
\def\sseq@data@name#1{\def\sseq@thename{#1}}
% When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@getcmds
    \let\xmin\sseq@xmin\let\xmax\sseq@xmax
    \let\ymin\sseq@ymin\let\ymax\sseq@ymax
}

\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobble % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

\def\sseq@newmaxpage#1{%
    \ifnum#1>\sseq@maxpage\gdef\sseq@maxpage{#1}\fi
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1{%
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax@active#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

% Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}\let\d\sseq@d}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\sseq@thepage}
\def\sseq@page@page@{\let\sseqthepage\sseq@thepage\sseq@tempcount=\sseq@thepage\advance\sseq@tempcount-1\edef\sseq@thepagemm{\the\sseq@tempcount}}

\def\sseq@classoptions(#1)#2{%
    \def\temp{#1}%
    \sseq@iffullcoord(#1){%
        \@ifundefined{sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes}{\sseq@error{There are no classes at \sseq@fullcoord@to@partialcoord(#1)}{}}%
        \ifnum\csname sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes\endcsname=1\relax
            \sseq@error{%
                There is only one node at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                '\string\classoptions\sseq@fullcoord@to@partialcoord(#1){#2}'%
            }%
        \fi
    }{%
        \@ifundefined{sseq@coord\sseq@thename(#1)@numnodes}{\sseq@error{There are no classes at (#1)}{}}%
        \ifnum\csname sseq@coord\sseq@thename(#1)@numnodes\endcsname=1\relax
            \edef\temp{\temp,1}%
        \else
            \sseq@error{%
                There are multiple nodes at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                '\string\classoptions(#1,n){#2}' where 'n' is the number of the node you are referring to%
            }%
        \fi
    }%
    \sseq@ifdead(\temp){%
        \ifnum\sseq@thepage>\sseq@getdeathpage(\temp)\relax
            \sseq@error{The node (#1) perished on page \sseq@getdeathpage(\temp) so there is no reason to add an option to it on page \sseq@thepage}{}%
        \fi
    }{}%
    \@xp\ifx\csname sseq@classstyle\sseq@thename(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@classstyle\sseq@thename(\temp)\endcsname{}}%
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@classstyle\sseq@thename(\temp)\endcsname{\pgfkeysalso{#2}}%
}

\def\sseq@doptions#1(#2){%
    \sseq@tempcount=#1%%
    \edef\temp{\@nx\sseq@doptions@{\the\sseq@tempcount}{#2}}\temp%
}


\def\sseq@doptions@#1#2#3{%
    \def\temp{#2}%
    \sseq@iffullcoord(#2){%
        \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
            \sseq@error{%
                There is only one node at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                '\string\doptions#1\sseq@fullcoord@to@partialcoord(#2){#3}'%
            }%
            \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
        \fi
    }{%
        \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
            \edef\temp{\temp,1}%
            \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
        \else
            \sseq@error{%
                There are multiple nodes at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                '\string\doptions#1(#2,n){#3}' where 'n' is the number of the node you are referring to%
            }%
            \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
        \fi
    }%
    \@ifundefined{sseq@thepage}{}{\ifnum\sseq@thepage=#1\relax\else\ifnum\sseq@thepage=0\else
        \sseq@error{Adding an option to a differential on page #1 when the current page is \sseq@thepage\sseq@macroname\ has no effect}{}%
    \fi\fi}%
%
    \@xp\ifx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{}}%
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{\pgfkeysalso{#3}}%
}



%% Placement
% TODO: Maybe add error checking for whether x,y are integers? any other error checking?
\def\sseq@place{\@ifnextchar[{\sseq@place@}{\sseq@place@[]}}%}
\def\sseq@place@[#1](#2,#3){%
    \begingroup
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecoords\temp{#2,#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}%
    \edef\next{\@nx\sseq@place@@(\temp){\the\sseq@temptoks}}%
    \next{#1}%
}
\def\sseq@place@@(#1,#2)#3#4{%
    \sseq@tempx=#1\relax
    \advance\sseq@tempx\sseq@x\relax
    \sseq@tempy=#2\relax
    \advance\sseq@tempy\sseq@y\relax
    \edef\tempcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \@xp\sseq@xminmax\@xp{\the\sseq@tempx}\@xp\sseq@yminmax\@xp{\the\sseq@tempy}%
    \sseq@tempcount=\@ifundefined{sseq@coord\sseq@thename(\tempcoord)@numnodespp}{1}{\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname}%
    \edef\tempnodenum{\the\sseq@tempcount}%
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodes\endcsname{\the\sseq@tempcount}%
    \advance\sseq@tempcount1\relax
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname{\the\sseq@tempcount}
%
    \sseq@temptoks\@xp{\@xp\def\@xp\sseq@classnodetext\@xp{\sseq@classnodetext}}
    \sseq@temptoks@ii\@xp{\@xp\def\@xp\sseq@classnodetextoptions\@xp{\sseq@classnodetextoptions}}
    \edef\temp{\sseq@temptoks{\the\sseq@temptoks\the\sseq@temptoks@ii}}\temp
    \sseq@temptoks@ii\@xp{\@xp\def\@xp\sseq@classlabelnodes\@xp{\sseq@classlabelnodes}}
    \edef\temp{\sseq@temptoks{\the\sseq@temptoks\the\sseq@temptoks@ii}}\temp
%
    \sseq@temptoks@ii{\pgfkeysalso{#4}}% local options
%
    \@xp\gdef\csname sseq@placenum\sseq@thename(\tempcoord,\tempnodenum)\endcsname{0}% to make \replace work correctly
%
    % Classes that eventually die
    % we use deforaddto@macro here because this macro gets moved, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename(\tempcoord,\tempnodenum)0}{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}{%
            \the\sseq@scopeoptions
            \sseq@thepathstyle\sseq@thenodestyle\sseq@theclassstyle\sseq@thetransientcyclestyle\@nx\ifsseq@thispage\sseq@thethispagecyclestyle\@nx\fi
            \the\sseq@temptoks@ii
            \@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname
        }%
        \endgroup
    }%
%
    % Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}{%
            \the\sseq@scopeoptions
            \sseq@thepathstyle\sseq@thenodestyle\sseq@theclassstyle\sseq@thepermanentcyclestyle
            \the\sseq@temptoks@ii
            \@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname
        }%
        \endgroup
    }%
%
    \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\tempcoord,\tempnodenum)}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname\relax}%
    \@xp\gdef\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname{}%
    \sseq@x@addto@macro\sseq@compilesseq{\@nx\sseq@setoffsets{\the\sseq@tempx}{\the\sseq@tempy}}%
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{% no need for defor since infty page initialized at begin{sseqdata}%
        \@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname %
    }%
    \endgroup
}

\def\sseq@replace{\@ifnextchar[{\sseq@replace@}{\sseq@replace@[]}}%}

\def\sseq@replace@[#1](#2,#3){%
    \begingroup
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecommas(#2,#3)%
    \sseq@replace@@{#1}%
}

\def\sseq@replace@@#1{%
    \sseq@arg@checkpresent\replace1%
    \sseq@arg@checkpresent\replace2%
    \edef\coord{(\sseq@arg1,\sseq@arg2,\sseq@optarg{1}3)}%
    \edef\coordname{(\sseq@arg1,\sseq@arg2\sseq@optargc3)}%
    \sseq@ifundefcoord\coord{\sseq@error{There never was a class at \coordname\sseq@macroname\ so I cannot replace it}{}}{}%
    \sseq@ifdead\coord{}{\sseq@error{I cannot replace the class at \coordname\sseq@macroname\ because it seems to be alive and well}{}}%
    \sseq@tempcount=\csname sseq@placenum\sseq@thename\coord\endcsname\relax
    \advance\sseq@tempcount1\relax
    \edef\tempclassversion{\the\sseq@tempcount}%
    \@xp\xdef\csname sseq@placenum\sseq@thename\coord\endcsname{\the\sseq@tempcount}%
%
    \sseq@temptoks\@xp{\@xp\def\@xp\sseq@classnodetext\@xp{\sseq@classnodetext}}
    \sseq@temptoks@ii\@xp{\@xp\def\@xp\sseq@classnodetextoptions\@xp{\sseq@classnodetextoptions}}
    \edef\temp{\sseq@temptoks{\the\sseq@temptoks\the\sseq@temptoks@ii}}\temp
    \sseq@temptoks@ii\@xp{\@xp\def\@xp\sseq@classlabelnodes\@xp{\sseq@classlabelnodes}}
    \edef\temp{\sseq@temptoks{\the\sseq@temptoks\the\sseq@temptoks@ii}}\temp
%
    \sseq@temptoks@ii{\pgfkeysalso{#1}}% local options
%
    % Classes that eventually die
    % we use deforaddto@macro here because this macro gets moved around, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename\coord\tempclassversion}{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}{%
            \the\sseq@scopeoptions
            \sseq@thepathstyle\sseq@thenodestyle\sseq@theclassstyle
            \sseq@thetransientcyclestyle\@nx\ifsseq@thispage\sseq@thethispagecyclestyle\@nx\fi
            \the\sseq@temptoks@ii
            \@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname
        }%
        \endgroup
        \@nx\fi
    }%
%
    % Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}{%
            \the\sseq@scopeoptions
            \sseq@thepathstyle\sseq@thenodestyle\sseq@theclassstyle\sseq@thepermanentcyclestyle
            \the\sseq@temptoks@ii\@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname%
        }%
        \endgroup
        \@nx\fi
    }%
%
    \sseq@x@deforaddto@macro{sseq@clearinfty\sseq@thename\coord}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname\relax}%
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{% no need for defor since infty page initialized at begin{sseqdata}%
        \@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname %
    }%
    \sseq@cleardeathpage\coord
    \endgroup
}


% #1 -- x
% #2 -- \sseq@x shift (change name of node but position already accounted for)
% #3 -- y
% #4 -- \sseq@y
% #5 -- n
% #6 -- node text
% #7 -- options
\def\sseq@place@drawnode#1#2#3#4#5#6#7{%
    \begingroup
    \sseq@tempx=#1\relax
    \advance\sseq@tempx#2\relax
    \sseq@tempy=#3\relax
    \advance\sseq@tempy#4\relax
    \edef\sseq@thiscoord{\the\sseq@tempx,\the\sseq@tempy,#5}%
    \edef\sseq@thisnodename{sseq@{\sseq@thiscoord}}
    #6% defines \sseq@classnodetext, \sseq@classnodetextoptions, and \sseq@classlabelnodes
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \ifsseq@needstikz
            \sseq@temptoks{\sseq@classnodetext}
            \sseq@temptoks@ii{#7}%
            \pgftransformshift{\pgfpoint{#1 cm}{#3 cm}}%
            \pgftransformshift{\pgfpoint{#2 cm}{#4 cm}}%
            \pgfgettransform{\savetransform}%
            \pgftransformresetnontranslations
            \sseq@globalrotatetransform
            \sseq@classplacementtransform
            \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\csname sseq@xoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}{\csname sseq@yoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}}}%
            \temp
            \pgftransformresetnontranslations
            \tikzset{every text node part/.code/.expand once={\sseq@globalrotatetransform\sseq@classnodetextoptions}}%
            \edef\temp{%
                \@nx\node[
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote,
                    /tikz/sseqpages/second pass/class,
                    /utils/exec={\the\sseq@temptoks@ii
                        \@nx\ifsseq@rotatelabels\@nx\iftikz@fullytransformed\@nx\else \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                        \@nx\fi\@nx\fi
                    }
                ] (\sseq@thisnodename) {\the\sseq@temptoks}
                [every text node part/.code={}]
                \@nx\sseq@classlabelnodes;
            }%
            \temp
        \else
            \pgfscope
            \let\tikz@options\pgfutil@empty
            \let\tikz@alias=\pgfutil@empty
            \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/}% Not sure why this shouldn't be in /second pass/class (but putting it there breaks things).
            #7%
            \pgftransformshift{\pgfpoint{#1 cm}{#3 cm}}%
            \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
            \pgftransformresetnontranslations
            \sseq@globalrotatetransform
            \sseq@classplacementtransform
            \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@xoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}{0\csname sseq@yoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}}}%
            \temp
            \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\ifsseq@rotatelabels\sseq@globalrotatetransform\fi\fi
            \tikz@options
            \tikz@node@textfont
            \sseq@setnodetext
            \let\tikz@fig@name\sseq@thisnodename%
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
            \sseq@classlabelnodes
            \endpgfscope
        \fi
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}%
        \temp
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\csname sseq@xoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}{\csname sseq@yoffset@\sseq@thename(\sseq@thiscoord)\endcsname cm}}}%
        \temp
        \pgfcoordinate{\sseq@thisnodename}{\pgfpointorigin}%
    \fi
    \endgroup
}

\def\sseq@setnodetext{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        \tikzset{every text node part/.try}%
        %\@xp\tikzset\@xp{\sseq@classnodetextoptions}
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          \sseq@classnodetext%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    \iftikz@mode@clip \sseq@error{Clip shouldn't happen here, but this error should be caught earlier}{}\fi % TODO: catch this and similar errors?
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \edef\temp{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}\temp%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%% Offsets TODO: This section is pretty unfinished
\def\sseq@setoffsets#1#2{%
    \@ifundefined{sseq@xoffset@\sseq@thename(#1,#2,1)}{\sseq@setoffsets@{#1}{#2}}{\sseq@checkoffsets{#1}{#2}}%
}
\def\sseq@setoffsets@#1#2{%
    \sseq@tempcount=\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname\relax
    \ifcase\sseq@tempcount\relax
        \sseq@error{Internal error. This should never happen}{}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{1}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{2}%
        \sseq@usestdoffsets{#1}{#2}{2}{2}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{3}%
        \sseq@usestdoffsets{#1}{#2}{2}{3}%
        \sseq@usestdoffsets{#1}{#2}{3}{3}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{4}%
        \sseq@usestdoffsets{#1}{#2}{2}{4}%
        \sseq@usestdoffsets{#1}{#2}{3}{4}%
        \sseq@usestdoffsets{#1}{#2}{4}{4}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{5}%
        \sseq@usestdoffsets{#1}{#2}{2}{5}%
        \sseq@usestdoffsets{#1}{#2}{3}{5}%
        \sseq@usestdoffsets{#1}{#2}{4}{5}%
        \sseq@usestdoffsets{#1}{#2}{5}{5}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{6}%
        \sseq@usestdoffsets{#1}{#2}{2}{6}%
        \sseq@usestdoffsets{#1}{#2}{3}{6}%
        \sseq@usestdoffsets{#1}{#2}{4}{6}%
        \sseq@usestdoffsets{#1}{#2}{5}{6}%
        \sseq@usestdoffsets{#1}{#2}{6}{6}%
    \else
        \sseq@error{Too many nodes at coordinate (#1,#2). Improve this error message}{}%
    \fi
}%

\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}
\def\sseq@checkoffsets#1#2{} %TODO: Implement this?

\sseq@setstdoffsets11{0}{0}%
%
\sseq@setstdoffsets12{-0.13}{0}
\sseq@setstdoffsets22{0.13}{0}
%
\sseq@setstdoffsets13{-0.2}{0}
\sseq@setstdoffsets23{0}{0}
\sseq@setstdoffsets33{0.2}{0}
%
\sseq@setstdoffsets14{-0.13}{-0.13}
\sseq@setstdoffsets24{0.13}{-0.13}
\sseq@setstdoffsets34{-0.13}{0.13}
\sseq@setstdoffsets44{0.13}{0.13}
%
\sseq@setstdoffsets15{-0.16}{-0.16}
\sseq@setstdoffsets25{0.16}{-0.16}
\sseq@setstdoffsets35{-0.16}{0.16}
\sseq@setstdoffsets45{0.16}{0.16}
\sseq@setstdoffsets55{0}{0}
%
\sseq@setstdoffsets16{-0.13}{-0.2}
\sseq@setstdoffsets26{-0.13}{0}
\sseq@setstdoffsets36{-0.13}{0.2}
\sseq@setstdoffsets46{0.13}{-0.2}
\sseq@setstdoffsets56{0.13}{0}
\sseq@setstdoffsets66{0.13}{0.2}



\def\sseq@usestdoffsets#1#2#3#4{%
    \@xp\global\@xp\let\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdxoffset#3/#4\endcsname
    \@xp\global\@xp\let\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdyoffset#3/#4\endcsname
}

\bgroup\lccode`@=`\#\lccode`Y=`Y\lccode`S=`S \lowercase{\egroup
    \def\sseq@d@error@nodegree{
        \sseq@error{
            You must specify the degree of your spectral sequence if you want to use the differential command \string\d.
            Specify the degree by providing '\string\degree={f(@1)}{g(@1)}' as an option to '\string\begin{sseqdata}',
            where f(@1) and g(@1) compute the x and y degree of the @1th page differential%
        }
    }
}
\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp(#3)%
}

\def\sseq@d@@#1#2(#3,#4){%
%
    \begingroup
    \def\sseq@thiscmdname{differential }
    \def\sseq@thiscall{\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)}%
    \sseq@newmaxpage{#2}%
    \pgfqkeys{/tikz/sseqpages/first pass/differential}{#1}%
    \sseq@parsecommas(#3,#4)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{source}%
    \edef\sourcecoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}%
    \edef\source{(\sourcecoord,\tempn)}%
%
%
    \pgfmathparse{int(\the\sseq@tempx+\sseq@targetx{#2})}%
    \sseq@tempx=\pgfmathresult\relax
    \pgfmathparse{int(\the\sseq@tempy+\sseq@targety{#2})}%
    \sseq@tempy=\pgfmathresult\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}4}{target}%
    \edef\targetcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}%
    \edef\target{(\targetcoord,\tempn)}%
%
%   Errors:
    \sseq@ifundefcoord\source{%
        \sseq@error{%
            Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \sseq@ifundefcoord\target{%
        \sseq@error{%
            Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \sseq@ifdead\source{%
        \ifnum\sseq@getdeathpage\source=#2\else
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
                a differential because it already perished on page \sseq@getdeathpage\source %
            }{}%
        \fi
    }{}%
    \sseq@ifdead\target{%
        \ifnum\sseq@getdeathpage\target=#2\else
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
                a differential because it already perished on page \sseq@getdeathpage\target %
            }{}%
        \fi
    }{}%
%
    \ifnum\csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname=1\relax
%            \@ifundefined{sseq@arg3}{}{\sseq@error{%
%                There is only one node at source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
%                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)'%
%            }{}}
    \else
        \@ifundefined{sseq@arg3}{\sseq@error{%
            There are multiple nodes at source coordinate (\sourcecoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
            \csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname\sseq@macroname\ nodes at (\sourcecoord) should be the source%
        }{}}{}%
    \fi
    \ifnum\csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname=1\relax
%            \@ifundefined{sseq@arg4}{}{\sseq@error{%
%                There is only one node at target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
%                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)'%
%            }{}}%
    \else
        \@ifundefined{sseq@arg4}{\sseq@error{%
            There are multiple nodes at target coordinate (\targetcoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
            \csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname\sseq@macroname\ nodes at (\targetcoord) should be the target%
        }{}}{}%
    \fi
%
    \sseq@temptoks{\pgfkeysalso{#1}}% local options
%
    \sseq@x@deforaddto@macro{sseq@saveddiffs@\sseq@thename#2}{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@drawedge\source\target{differential}{%
                \sseq@thislabelstyle{\sseq@thelabelstyle\sseq@theedgelabelstyle\sseq@thedifferentiallabelstyle}%
                \the\sseq@scopeoptions
                \sseq@thepathstyle\sseq@theedgestyle\sseq@thedifferentialstyle
                \the\sseq@temptoks
                \@xp\@nx\csname sseq@dstyle\sseq@thename#2\source\endcsname
        }%
        \endgroup
    }%
%
    \@xp\gdef\csname sseq@dstyle\sseq@thename#2\source\endcsname{}%
%
    % Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} % This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\source\endcsname%
    \csname sseq@clearinfty\sseq@thename\target\endcsname%
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\source\endcsname\relax
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\target\endcsname\relax
%
    % Add placement on appropriate page
    \sseq@x@deforaddto@macro@noctx{sseq@savednodes@\sseq@thename#2}{%
        \sseq@ifdead\source{}{\@xp\@nx\csname sseq@place\sseq@thename\source\csname sseq@placenum\sseq@thename\source\endcsname\endcsname}%
        \sseq@ifdead\target{}{\@xp\@nx\csname sseq@place\sseq@thename\target\csname sseq@placenum\sseq@thename\target\endcsname\endcsname}%
    }%
%
    \sseq@setdeathpage\source{#2}%
    \sseq@setdeathpage\target{#2}%
    \endgroup
}

%
\pgfdeclarearrow{
    name = ...,
    parameters = { \the\pgfarrowlength\the\pgflinewidth},
    setup code = {
        % The different end values:
        \pgfarrowssetlineend{-\pgfarrowlength}
        \pgfarrowssetbackend{-0.6\pgfarrowlength}
        % The hull
        \pgfarrowshullpoint{-\pgfarrowlength}{0pt}
        \pgfarrowshullpoint{\pgfarrowlength}{0pt}
        % Saves: Only the length:
        \pgfarrowssavethe\pgfarrowlength
        \pgfarrowssavethe\pgflinewidth
    },
    drawing code = {
        \pgfpathcircle{\pgfpoint{-0.7\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.4\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.1\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathclose
        \pgfusepathqfill
    },
    defaults = { length = 0.3cm }
}

\def\sseq@ifinrange(#1){\sseq@ifinrange@#1,\sseq@nil}

\def\sseq@ifinrange@#1,#2,#3\sseq@nil{%
    \sseq@tempx=#1\relax\sseq@tempy=#2\relax
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
    \sseq@outofrangefalse
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \@xp\pgfutil@secondoftwo
    \else
        \@xp\pgfutil@firstoftwo
    \fi
}

% #1 -- source (full)
% #2 -- target (full)
% #3 -- which type of edge (not used, TODO: remove?)
% #4 -- options
\def\sseq@drawedge(#1)(#2)#3#4{%
    % First calculate actual start and end of the edge
    \begingroup\pgfscope
    \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid % Check if source is a named coordinate
        \def\tempa{\pgfpointanchor{sseq@{#1}}{center}}% if so, start by taking the center of that coordinate
    \else
        \def\tempa{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#1)}% else, just take the coordinate in question
        \let\tempaf\tempa
    \fi
    \@xp\ifx\csname pgf@sh@pi@sseq@{#2}\endcsname\pgfpictureid % Check if the target is a named coordinate
        \def\tempb{\pgfpointanchor{sseq@{#2}}{center}}
        \def\tempbf{\pgfpointshapeborder{sseq@{#2}}{\tempa}}%also ta
    \else
        \def\tempb{\pgfpoint\sseq@fullcoord@to@partialcoordb(#2)}%
        \let\tempbf\tempb
    \fi
    \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
        \def\tempaf{\pgfpointshapeborder{sseq@{#1}}{\tempb}}%
    \fi
%
    \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/differential/}
    #4%
    \tikz@options
    \tikz@mode
    \pgfpathmoveto{\tempaf}%
    \pgfpathlineto{\tempbf}%
    \pgfgetpath\thispath
    \pgfusepath{discard}
    \sseq@ifinrange(#1){\sseq@ifinrange(#2){\sseq@outofrangefalse}{\sseq@outofrangetrue}}{\sseq@outofrangetrue}
    \ifsseq@outofrange
        \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}
    \else
        \def\pgfintersectionsolutions{0}
    \fi
    \def\temparrowstartspec{}
    \def\temparrowendspec{}
    \ifcase\pgfintersectionsolutions\relax
    \or
        \sseq@ifinrange(#1){
            \def\tempbf{\pgfpointintersectionsolution{1}}
            \def\temparrowendspec{\pgfsetarrowsend{...}}
        }{
            \def\tempaf{\pgfpointintersectionsolution{1}}
            \def\temparrowstartspec{\pgfsetarrowsstart{...}}
        }
    \or
            \def\tempaf{\pgfpointintersectionsolution{1}}
            \def\tempbf{\pgfpointintersectionsolution{2}}
            \def\temparrowstartspec{\pgfsetarrowsstart{...}}
            \def\temparrowendspec{\pgfsetarrowsend{...}}
    \else
        \sseq@error{This shouldn't happen.}
    \fi
    \pgftransformreset
    % TODO: Decide whether this code should be here
    % Don't draw dots on very short segments
    \tempbf\pgf@xa=\pgf@x\pgf@ya=\pgf@y
    \tempaf\advance\pgf@xa-\pgf@x\advance\pgf@ya-\pgf@y
    \pgfmathveclen{\pgf@xa}{\pgf@ya}
    \@xp\pgfmathint\@xp{\pgfmathresult}
    \ifnum\pgfmathresult<17\relax
        \tikzset{every text node part/.append code={\pgfsetcolor{white}}}
        \ifx\temparrowstartspec\pgfutil@empty
        \else
            \def\temparrowstartspec{\pgfsetarrowsstart{}}
        \fi
        \ifx\temparrowendspec\pgfutil@empty
        \else
            \def\temparrowendspec{\pgfsetarrowsend{}}
        \fi
    \fi
    \ifsseq@needstikz
        \pgfcoordinate{tempa}{\tempaf}
        \pgfcoordinate{tempb}{\tempbf}
        \edef\temp{\@nx\draw[/tikz/sseqpages/second pass/differential,
            /utils/exec={\@xp\@nx\temparrowstartspec\@xp\@nx\temparrowendspec}
        ] (tempa) to (tempb);}%        
        \temp
    \else
        \temparrowstartspec
        \temparrowendspec
        \pgfpathmoveto{\tempaf}
        \pgfpathlineto{\tempbf}
        \pgfusepath{stroke}
    \fi
    \endpgfscope\endgroup
}

\def\sseq@addcontingentfeature#1#2{%
    \sseq@g@deforaddto@macro{sseq@feature\the\sseq@featurecount}{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    \@xp\sseq@x@addto@macro\csname sseq@savedfeatures@\sseq@thename infty\endcsname{%
        \@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
%        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
%            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
%        \@nx\fi %
    }%
    %
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        %\sseq@temppage is defined by \d before it calls this.
        \@nx\sseq@g@deforaddto@macro@noctx{sseq@savedfeatures@\sseq@thename\@nx\sseq@temppage}{% needs to be defor in case this is placed before the nodes it connects.
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil,)%
    \global\advance\sseq@featurecount1\relax
}

\def\sseq@addcontingentfeature@(#1,#2){%
    \ifx\sseq@nil#1\else %
        \sseq@parsecoords\temp{#1,#2}%
        \@xp\sseq@iffullcoord\@xp(\temp){}{%
            \edef\temp{\temp,\@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}{1}{\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname}}%
        }%
        \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\temp)}{% should be deforaddto, so that it will work even if this is called before the node is placed
            \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname
        }%
    %
        \@xp\sseq@addcontingentfeature@
    \fi
}

\def\sseq@structline{\@ifnextchar[{\sseq@structline@}{\sseq@structline@[]}}%]
\def\sseq@structline@[#1](#2)(#3){%
    \edef\temp{\@nx\sseq@structline@@\sseq@anchorsplit{#2}\sseq@anchorsplit{#3}}%
    \temp{#1}{\string\structline\ifx\sseq@nil#1\sseq@nil \else[#1]\fi(#2)(#3)}%
}
\def\sseq@structline@@#1#2#3#4#5#6{%
    \begingroup
    \def\sseq@thiscmdname{structure line }% To pass error information to \sseq@whichclass
    \def\sseq@thiscall{#6}%
    \sseq@parsecoords\source{#1}%
    %\@xp\sseq@iffullcoord\@xp(\source){}{\edef\source{\source,1}}%
    \sseq@parsecoords\target{#3}%
    %\def\temp{#4}%
    %\@xp\sseq@iffullcoord\@xp(\target){}{\edef\target{\target,1}}%
    \edef\temp{%
        \@nx\sseq@structline@@@
            \@xp\sseq@iffullcoord\@xp(\source)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\source){\@xp\sseq@fullcoord@lastelt\@xp(\source)}}%
                {(\source){}}%{\@ifundefined{sseq@coord\sseq@thename(\source)@numnodes}{}{,\csname sseq@coord\sseq@thename(\source)@numnodes\endcsname}}}%
            {#2}%
            \@xp\sseq@iffullcoord\@xp(\target)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\target){\@xp\sseq@fullcoord@lastelt\@xp(\target)}}%
                {(\target){}}%{\@ifundefined{sseq@coord\sseq@thename(\target)@numnodes}{}{,\csname sseq@coord\sseq@thename(\target)@numnodes\endcsname}}}%
            {#4}%
    }%
    \temp{#5}%
    \endgroup
}
\def\sseq@structline@@@(#1,#2)#3#4(#5,#6)#7#8#9{%
    \pgfqkeys{/tikz/sseqpages/first pass/struct line}{#9}%
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#5\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#6\relax
    \sseq@temptoks{\pgfkeysalso{#9}}%
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source}%
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#7}{target}%
    \edef\temp{\@nx\sseq@addcontingentfeature{(\the\sseq@tempx,\the\sseq@tempy)(\the\sseq@tempxb,\the\sseq@tempyb)}{%
            \begingroup
                \ifsseq@needstikz\@nx\sseq@needstikztrue\fi
                \@nx\sseq@drawedge (\the\sseq@tempx,\the\sseq@tempy,\sseq@na)(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)%
                    {struct line}{
                        \sseq@thislabelstyle{\sseq@thelabelstyle\sseq@theedgelabelstyle\sseq@thestructlinelabelstyle}
                        \the\sseq@scopeoptions
                        \sseq@thepathstyle\sseq@theedgestyle\sseq@thestructlinestyle\@nx\ifsseq@thispage\sseq@thethispagestructlinestyle\@nx\fi
                        \the\sseq@temptoks
                    }%
            \endgroup
        }
    }%
    \temp
}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


%% Redo tikz parsing rules for interpreting coordinates
% We want to intepret (x,y) as the name of a node.		
%
% Original behavior:
% The original parsing rule said roughly:
%   if there's a cs: treat it like a coordinate shift
%     if there's the word intersection: treat it as an intersection
%       ...
%        if there's a comma treat it as a literal coordinate
%          else treat it as the name of a node
%
% We replace the second to last step with:
%    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%      if there is such a node, treat it as refering to sseq@{x,y}
%      else treat it as a literal coordinate
%
% Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{%
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}


\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}%
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{%
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}%
    \@xp\sseq@iffullcoord\@xp(\temp){}{%
        \@ifundefined{sseq@coord\sseq@thename(\temp)@numnodes}{}%
            {\ifnum\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname=1\relax\edef\temp{\temp,1}\fi}%
            %{\edef\temp{\temp,\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname}}
    }%
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid % Check if a node with name sseq@{x,y} is defined in this picture
        \def\tikztotarget{sseq@{\temp}}% fixes the bend left and bend right options (probably others)
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}%
    \else %( % No such node exists
        \ifx&#4& % make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3})}% Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor '\@gobble#4'. In order to accept an anchor, there must be a node at the given location}{}%
        \fi
    \fi
    \next
}

%% Patch \foreach to use sseq@context
% TODO: Add stuff for when this fails
\def\sseq@pgffor@@vars@opt[#1]{\pgfkeys{/tikz/sseqpages/foreach/.cd,#1}\pgffor@vars}
\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{%
    \let\pgffor@@vars@opt\sseq@pgffor@@vars@opt
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\patchcmd\sseq@pgffor@invokebody % store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % store setting before
    {\ifx\pgffor@assign@before@code}
    {\sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}%
     \ifx\pgffor@assign@before@code}
    {}{\no}
\patchcmd\sseq@pgffor@invokebody % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}
\patchcmd\sseq@pgffor@doloop % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@addtosavedtoks{\def#2{#4}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}


\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@xaddtosavedtoks{\def\@nx#1{\the#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@xaddtosavedtoks\@xp{\@xp\def\@xp#1\@xp{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@xaddtosavedtoks{\def\@nx#2{#1}}}}
    {}{\no}


\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@currentvar{\pgffor@temp}}}
    {}{\no}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@once@expanded}}
    {}{\no}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@expanded}}
    {}{\no}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\no}