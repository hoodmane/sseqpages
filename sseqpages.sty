%^^A -*- TeX:UTF-8:Soft -*-
%\ifthenelse{1=0}{%
%<*never>
%\documentclass{ltxdoc}
%\usepackage{sseqpages}
%\usepackage{ifthen}
%\usepackage{amssymb}
%\usepackage{verbatim}
%\parskip=10pt
%\parindent=0pt
%\begin{document}
%\DocInput{sseqpages.dtx}
%\end{document}
%</never>
%}{}

%^^A \title{Typesetting spectral sequences in \LaTeX\ with sseqpages.sty}
%^^A \author{Hood Chatham}
%^^A \maketitle
% \MakeShortVerb{\|}
%
% \section{Introduction}
%
% The |sseqpages| package is specifically intended for drawing spectral sequences when it is desirable to display multiple different pages of a spectral sequence.
% It is built on top of pgf/tikz and is designed to be closely integrated with tikz.
% It defines two environments, |sseqdata| and |sseqpage|.
%
% The purpose of the |sseqdata| environment is to give a named collection of raw data for a spectral sequence,
% including classes, differentials, structure lines, as well as any tikz code and drawing options that are intended to appear on every page of the spectral sequence.
% The |sseqdata| environment typesets nothing. It saves all of the data that it is given to be typeset later in |sseqpage| environments.
%
% The purpose of the |sseqpage| environment is to typeset a particular page of a spectral sequence already specified in the |sseqdata| environment.
% In particular, the |sseqpage| environment typesets all classes that are still alive on the given page $r$, as well as the differentials of length $r$.
% The user may also specify additional features to be drawn just on this particular page, or late options to change the drawing of a specific differential or class.
%
% Each page consists of the following components, drawn in the given order:
% \begin{enumerate}
% \item The background layer
% \item The axes
% \item A clipping
% \item The classes
% \item Stucture lines (and potentially other features)
% \item Differentials
% \item The foreground layer
% \end{enumerate}
%
% The background layer consists of arbitrary |tikz| code, specified with the option |background|.
% The axes and clipping are automatically included, unless the user specifies that they should be suppressed in which case replacement features can be added into the background layer.
% The classes are specified using the |\place| command,
%
% \DescribeEnv{sseqdata}
% The data for a spectral sequence is specified using the code
% \begin{quote}
% |\begin{sseqdata}[name=|\meta{name},\meta{options}|]|
%
% \meta{commands...}
%
% |\end{sseqdata}|
% \end{quote}
%
% The \meta{commands...} consist of the following:
%
% \DescribeMacro{\place}
% The command |\place[|\meta{options}|]|\meta{coordinate} will place a class at \meta{coordinate},
% which must be of the form (\meta{x-coord},\meta{y-coord}) where \meta{x-coord} and \meta{y-coord} are integers.
%
% The options for |\place| are as follows:
% \begin{description}
% \item[|"|\meta{label}|"|\opt{\meta{options}}] This specifies the content of the node. For instance |\place["$\mathbb{Z}$"](0,0)| would place a node with contents $\mathbb{Z}$.
%
% \item Any tikz options that you might pass to a node. These include things such as a shape name, for instance |circle| or |rectangle|, colors, such as |green| or |text=blue|.
%   The one type of option that is significantly restricted is coordinate transformations. More on this below.
% \end{description}
%
% \DescribeMacro{\d}
% The command |\d[|\meta{options}|]|\meta{page}\meta{coordinate} will place a differential on page \meta{page} starting at \meta{coordinate}.
% \begin{description}
%   \item[|"|\meta{label}|"|\opt{\meta{options}}] This specifies a label for the differential. The \meta{options} are the same as for standard tikz edge quotes.
%
%   \item
% \end{description}
%
% \DescribeMacro{\structline}
% The command |\structline[|\meta{options}|]|\meta{start coordinate}\meta{end coordinate} will place a ``structure line'' starting at \meta{start coordinate} and ending at \meta{end coordinate}.
%
%
% \section{Global options}
% \begin{description}
% \item[|name=|\meta{\textmd{name}}] Specifies the name of the current spectral sequence. Specifying a name is mandatory for both the |sseqdata| and the |sseqpage| environment.
%   When used for the |sseqdata| environment, it must be distinct from any \meta{name} of any previous |sseqdata| environment.
%   When used for the |sseqpage| environment, it must be the name of a previous |sseqdata| environment.
%   The \meta{name} may contain any characters with the following caveats (assuming normal catcodes): It may not include the pound character \#.
%   It may not include any command or active character that isn't fully expandable. Typically, this means that it may not include the tilde character $\sim$.
%   It may include braces as long as they are balanced. Lastly, any comma or equals signs must be enclosed in braces in order to hide it from pgfkeys.
%
% \item[|page=|\meta{\textmd{page}}] This is a mandatory option for the |sseqpage| environment but does not exist for the |sseqdata| environment.
%   \meta{page} must be a nonnegative integer, and specifies what page to display. Setting |page=0| instructs |sseqpage| to print all differentials (and also all classes).
%   If you want the infinity page, just set the page to be very large, like |page=1000|.
%
% \item[|x range=|\meta{xmin}\meta{xmax}] Specifies the $x$-range of the spectral sequence to be drawn.
%   When used in |sseqdata|, indicates the default range, when used in |sseqpage|, specifies the range for just this page.
%
% \item[|y range=|\meta{ymin}\meta{ymax}] Specifies the $y$-range of the spectral sequence to be drawn.
% \end{description}



%\begin{comment}
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{sseqpages}

\RequirePackage{tikz}
\@ifpackagelater{tikz}{2015/08/07}{%
    %^^A Current version of tikz
}{%
    %^^A not current version of tikz
}
\RequirePackage{etoolbox}

%^^A TODO:
%^^A How should global/.unknown work? The current version isn't quite right.
%^^A   Add a separate global/sseqset directory? Or a special version of global/.unknown for \sseqset? Or what?
%^^A Fix it so that updating saying e.g., "classes={stuff}" as an option to "\begin{sseqpage}" does something.
%^^A Add better error when user doesn't specify degree.
%^^A
%^^A Is the option handling getting too complicated?
%^^A
%^^A Is labels / every label broken?
%^^A option not to render axes
%^^A options to add space to the right and on the top of the picture (like y axis gap and x axis gap except mirrored)
%^^A offset patterns
%^^A Check if modifications to tikz are alright
%^^A Special options for rendering of nodes that are hit on this particular page

\usetikzlibrary{quotes}
\usepackage{trace}

%^^A Ensure \@xp and \@nx have the correct values in case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} %^^A This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} %^^A Larger than any coordinate anyone will ever use.
\def\sseq@ifhop#1#2\fi{\fi#1} %^^A so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} %^^A Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} %^^A used in parsecoords
\def\sseq@uptocomma#1,#2\sseq@nil{#1}
\def\sseq@fullcoord@to@partialcoord(#1,#2,#3){(#1,#2)}
\def\sseq@fullcoord@to@partialcoordb(#1,#2,#3){{#1cm}{#2cm}}
\def\sseq@fullcoord@lastelt(#1,#2,#3){#3}


%^^A% Declarations
\newif\ifsseq@fastmode
\newif\ifsseq@needstikz
\newif\ifsseq@outofrange
\newif\ifsseq@inprogress

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@thepermcyclestyle
\newtoks\sseq@thetranscyclestyle
\newtoks\sseq@classoptionslist
\newtoks\sseq@doptionslist
\newtoks\sseq@structlineoptionslist


\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@featurecount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempx
\newcount\sseq@tempy
\newcount\sseq@tempxb
\newcount\sseq@tempyb
\newdimen\sseq@tempxdim
\newdimen\sseq@tempydim
\sseq@context@depth\z@
\sseq@context@tempcount\z@
\sseq@featurecount\z@
\sseq@x\z@ \sseq@y\z@
\sseq@tempcount\z@


\newdimen\sseq@tempdimen
\newdimen\sseq@tempdimen@ii


%^^A% \sseq@--@--addto@macro and friends.
%^^A My own variants of \pgfutil@g@addto@macro.
%^^A \sseq@x@addto@macro recursively expands the argument and then adds it.
%^^A \sseq@g/x@deforaddto@macro checks first whether the macro is defined or not, if not it used \gdef or \xdef, else it uses \sseq@g/x@addto@macro
%^^A The "ctx" variants are \let equal to the foreach versions when inside of \foreach or when the context command (not named yet) is used
%^^A The "noctx" variants never are set equal to the foreach versions. These are primarily for use in defining internals, to prevent infinite loops
%^^A The standard variants are \def'd to expand to a "ctx" variant when the "use context" option is requested
%^^A They also add saved state information to the macro the first time they add data to that macro
%^^A TODO: Make context command / environment
\def\sseq@g@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1#2}\xdef#1{\the\pgfutil@toks@}\endgroup} %^^A copy of \pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} %^^A let #2 be expanded

\let\sseq@g@addto@macro@ctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@ctx\sseq@x@addto@macro
\let\sseq@g@addto@macro@noctx\sseq@g@addto@macro
\let\sseq@x@addto@macro@noctx\sseq@x@addto@macro


\def\sseq@g@deforaddto@macro#1{\@ifundefined{#1}{\@xp\gdef\csname#1\endcsname}{\@xp\sseq@g@addto@macro@noctx\csname#1\endcsname}}
\def\sseq@x@deforaddto@macro#1{\@ifundefined{#1}{\@xp\xdef\csname#1\endcsname}{\@xp\sseq@x@addto@macro@noctx\csname#1\endcsname}}

\let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro
\let\sseq@g@deforaddto@macro@noctx\sseq@g@deforaddto@macro
\let\sseq@x@deforaddto@macro@noctx\sseq@x@deforaddto@macro


\def\sseq@g@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@g@addto@macro@noctx#1%
}

\def\sseq@x@addto@macro@foreach#1{%
    \sseq@gx@addto@macro@foreach@#1%
    \sseq@x@addto@macro@noctx#1%
}

\def\sseq@g@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@g@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@x@deforaddto@macro@foreach#1{%
    \@ifundefined{#1}{\@xp\gdef\csname #1\endcsname{}}{}%
    \@xp\sseq@gx@addto@macro@foreach@\csname #1\endcsname
    \@xp\sseq@x@addto@macro@noctx\csname #1\endcsname%
}

\def\sseq@gx@addto@macro@foreach@#1{%
    \@ifundefined{sseq@context@\sseq@macroname#1}%
        {\sseq@context@tempcount=0\relax}%
        {\sseq@context@tempcount=\csname sseq@context@\sseq@macroname#1\endcsname\relax}%
    \ifnum\sseq@context@tempcount<\sseq@context@depth\relax %
        \loop %
            \advance\sseq@context@tempcount1\relax
            \sseq@for@addsavedtoksntomacro{\the\sseq@context@tempcount}{#1}%
        \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
        \@xp\edef\csname sseq@context@\sseq@macroname#1\endcsname{\the\sseq@context@depth}%
    \fi %
}

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@addtosavedtoks{\@xp\sseq@g@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@xaddtosavedtoks{\@xp\sseq@x@addto@macro@noctx\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname}
\def\sseq@for@addsavedtoksntomacro#1#2{\@xp\@xp\@xp\sseq@g@addto@macro@noctx\@xp\@xp\@xp#2\@xp\@xp\@xp{\csname sseq@for@savedtoks#1\endcsname}}

\def\sseq@g@addtosavedpaths{\@xp\sseq@g@addto@macro\sseq@savedpaths}
\def\sseq@x@addtosavedpaths{\@xp\sseq@x@addto@macro\sseq@savedpaths}
\def\sseq@g@addtosavedpaths@ctx{\@xp\sseq@g@addto@macro@ctx\sseq@savedpaths}
\def\sseq@x@addtosavedpaths@ctx{\@xp\sseq@x@addto@macro@ctx\sseq@savedpaths}
\def\sseq@savedpaths{\sseq@savedforegroundpaths}

%^^A%% Set up keys
%^^A TODO: Check that this section is consistent

\def\sseqset#1{\ifsseq@inprogress\pgfqkeys{/tikz/sseqpages}{#1}\else \pgfqkeys{/tikz/sseqpages/global}{#1}\fi\sseq@redooptions}
\def\sseq@set{\pgfqkeys{/tikz/sseqpages}}
\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\edef\sseq@temp{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname=\the\sseq@temptoks}}\sseq@temp}

\pgfkeys{%
    /tikz/sseqpages/.is family,
    /tikz/sseqpages/.unknown/.code={\sseq@passoptionto{/tikz}},
    %^^A \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    %^^A TODO: fix global so that unknown options cause errors at the begining of the environment
    %^^A It should check that the option is defined somewhere before deferring it?
    /tikz/sseqpages/global/.unknown/.code={%
        \let\sseq@tempa\pgfkeyscurrentname
        \let\sseq@tempb\pgfkeyscurrentvalue
        \pgfkeysalso{{\sseq@currentoptionpath} options/.append style/.expand twice={\@xp\sseq@tempa\@xp=\@xp{\sseq@tempb}}}%
    },
    /tikz/sseqpages/first pass/.unknown/.code={},
    /tikz/sseqpages/first pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/class/.unknown/.code={%
        \expandafter\ifx\csname pgf@sh@s@\pgfkeyscurrentname\endcsname\relax %^^A is it the name of a shape?
            \sseq@passoptionto{/tikz/sseqpages/first pass}%
        \else
            \edef\tikz@shape{\pgfkeyscurrentname}%^^A if so, store it
        \fi
    },
    /tikz/sseqpages/first pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/struct line/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/first pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/first pass}},
    /tikz/sseqpages/second pass/.is family,
    /tikz/sseqpages/second pass/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages}},
    /tikz/sseqpages/second pass/scope/.is family,
    /tikz/sseqpages/second pass/scope/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/class/.is family,
    /tikz/sseqpages/second pass/class/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/differential/.is family,
    /tikz/sseqpages/second pass/differential/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/struct line/.is family,
    /tikz/sseqpages/second pass/struct line/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    /tikz/sseqpages/second pass/tikz primitives/.is family,
    /tikz/sseqpages/second pass/tikz primitives/.unknown/.code={\sseq@passoptionto{/tikz/sseqpages/second pass}},
    % One off directories
    /tikz/sseqpages/foreach/.unknown/.code={\sseq@passoptionto{/pgf/foreach}},
    /tikz/sseqpages/class placement/.unknown/.code={\sseq@passoptionto{/tikz}}
}

\pgfqkeys{/tikz/sseqpages/first pass/class}{shape/.code={\edef\tikz@shape{\pgfkeyscurrentname}}} %^^A shape=whatever shape passing

%^^A% Quote handling
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\def\sseq@removequotes"#1"{#1}
\def\sseq@classnodetext{}

\pgfkeys{%
    /tikz/sseqpages/first pass/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /tikz/sseqpages/first pass/class/handle quote/.code={\@xp\def\@xp\sseq@classnodetext\@xp{\sseq@removequotes#1}},
    /tikz/sseqpages/first pass/differential/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/first pass/struct line/handle quote/.code=\sseq@needstikztrue,
    /tikz/sseqpages/second pass/class/handle quote/.code={},
    /tikz/sseqpages/handle quote/.code={\tikzset{every to/.append style={#1}}}
}

%^^A% Parsing, background vs foreground, and context
\def\sseq@standardparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular@old
    \let\sseq@transform\sseq@okaytransform %^^A Allow all coordinate transformations
    \let\sseq@shifttransform\sseq@okaytransform
    \let\sseq@firstpass@shifttransform\@gobbletwo
    \def\place{\sseq@error{You cannot use \@nx\place\sseq@macroname in standard parse mode}{}}%
    \def\replace{\sseq@error{You cannot use \@nx\replace\sseq@macroname in standard parse mode}{}}%
    \def\d{\sseq@error{You cannot use \@nx\d\sseq@macroname in standard parse mode}{}}%
}

\def\sseq@nodeparse{%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\sseq@transform\sseq@error@illegaltransform %^^A Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform
    \let\place\sseq@place
    \let\replace\sseq@replace
    \let\d\sseq@d
}

\def\sseq@errortikzprimsonly#1{\sseq@error{You can only use '#1' as an option for tikz primitives, not for \@nx\place, \@nx\replace\sseq@macroname\ or \@nx\d}{}}

\sseq@set{%
    standard parse/.code={\sseq@standardparse},
    node parse/.code={\sseq@nodeparse},
    background/.code={\pgfkeysalso{standard parse}},
    foreground/.code={\pgfkeysalso{node parse}} %^^ATODO: track original mode and restore it?
}

\pgfqkeys{/tikz/sseqpages/foreach}{%
    use context/.code={%^^A\def rather than \let because until a \foreach loop occurs, \sseq@g@addto@macro@ctx is vanilla variant
        \def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}%
        \def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}%
        \def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}%
        \def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}%
    }
}

\pgfqkeys{/tikz/sseqpages/first pass}{%
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform},
    background/.code={\def\sseq@savedpaths{\sseq@savedbackgroundpaths}\pgfkeysalso{standard parse}},
    foreground/.code={\def\sseq@savedpaths{\sseq@savedforegroundpaths}\pgfkeysalso{node parse}},%^^A is this okay?
    use context/.code={%^^A\def rather than \let because until a \foreach loop occurs, \sseq@g@addto@macro@ctx is vanilla variant
        \def\sseq@g@addto@macro{\sseq@g@addto@macro@ctx}%
        \def\sseq@x@addto@macro{\sseq@x@addto@macro@ctx}%
        \def\sseq@g@deforaddto@macro{\sseq@g@deforaddto@macro@ctx}%
        \def\sseq@x@deforaddto@macro{\sseq@x@deforaddto@macro@ctx}%
    }
}


\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/first pass/differentials}{%
    standard parse/.code={\sseq@errortikzprimsonly{standard parse}},
    background/.code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ %^^A This is only for scope and tikz primitives, but in other cases, it emits an error on first pass.
    use context/.code={},
    needs tikz/.code={},
    class/transform shape/.code={\pgfsettransform{\savetransform}\pgfqkeys{/tikz/sseqpages/class transform}{transform shape}}
}

%^^A% Needs tikz
%^^A Force \place or \d to fall back to using tikz to render their output
%^^A Rather than using the faster direct \pgf primitives (largely copied from tikz to maximize compatibility)
%^^A Drawing with tikz is slower, but I don't want to reimplement these features

\pgfqkeys{/tikz/sseqpages/first pass}{%
    needs tikz/.code=\sseq@needstikztrue,
    shade/.code=\sseq@needstikztrue,
    blend mode/.code=\sseq@needstikztrue,
    pattern/.code=\sseq@needstikztrue,
    path picture/.code=\sseq@needstikztrue,
    path fading/.code=\sseq@needstikztrue,
    decorate/.code=\sseq@needstikztrue,
    pin/.code=\sseq@needstikztrue,
    label/.code=\sseq@needstikztrue
}

%^^A multipart shapes and alignment to be done with tikz
\pgfqkeys{/tikz/sseqpages/first pass/class}{%
    circle split/.code=\sseq@needstikztrue,
    circle solidus/.code=\sseq@needstikztrue,
    ellipse split/.code=\sseq@needstikztrue,
    rectangle split/.code=\sseq@needstikztrue,
    align/.code=\sseq@needstikztrue,
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\place' command. You should use 'alias' instead}{}}
}


%^^A Force differential to be drawn with tikz if it is bent
\pgfqkeys{/tikz/sseqpages/first pass/differential}{%
    bend left/.code=\sseq@needstikztrue,
    bend right/.code=\sseq@needstikztrue,
    in/.code=\sseq@needstikztrue,
    out/.code=\sseq@needstikztrue,
    controls/.code=\sseq@needstikztrue,
    in control/.code=\sseq@needstikztrue,
    out control/.code=\sseq@needstikztrue,
    loop/.code=\sseq@needstikztrue,
    loop above/.code=\sseq@needstikztrue,
    loop below/.code=\sseq@needstikztrue,
    loop left/.code=\sseq@needstikztrue,
    loop right/.code=\sseq@needstikztrue
}


%^^A% Style options
\def\sseq@cyclestyles#1#2{\sseq@permanentcyclestyle{#1}\sseq@transientcyclestyle{#2}}
\def\sseq@permanentcyclestyle#1{\sseq@thepermcyclestyle{\pgfkeysalso{#1}}}
\def\sseq@transientcyclestyle#1{\sseq@thetranscyclestyle{\pgfkeysalso{#1}}}

\def\sseq@redooptions{\sseq@redoclassoptions\sseq@redodifferentialoptions\sseq@redopermtranscycleoptions\sseq@redostructlineoptions}%\sseq@redogenoptions}
\def\sseq@redoclassoptions{%
    \sseq@classoptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}%
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every path}%
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every node}%
    \sseq@addstylecmdtotoks\sseq@classoptionslist{every class}%
}
\def\sseq@redodifferentialoptions{%
    \sseq@doptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}%
    \sseq@addstylecmdtotoks\sseq@doptionslist{every path}%
    \sseq@addstylecmdtotoks\sseq@doptionslist{every differential}%
}
\def\sseq@redopermtranscycleoptions{%
    \sseq@thepermcyclestyle{}\sseq@thetranscyclestyle{}%
    \sseq@addstylecmdtotoks\sseq@thepermcyclestyle{every permanent cycle}%
    \sseq@addstylecmdtotoks\sseq@thetranscyclestyle{every transient cycle}%
}

\def\sseq@redostructlineoptions{%
    \sseq@structlineoptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}%
    \sseq@addstylecmdtotoks\sseq@structlineoptionslist{every struct line}%
}

%\def\sseq@redogenoptions{%
%    \sseq@genoptionslist\@xp{\@xp\pgfkeysalso\@xp{\sseq@scopeoptions}}
%    \sseq@addstylecmdtotoks\sseq@genoptionslist{every path}
%    \sseq@addstylecmdtotoks\sseq@genoptionslist{every node}
%}

\def\sseq@addstylecmdtotoks#1#2{%
    \pgfkeysgetvalue{/tikz/sseqpages/#2/.@cmd}{\sseq@tempcmd}%
    \ifx\sseq@tempcmd\relax\else
        \@xp\def\@xp\sseq@temp\@xp{\sseq@tempcmd\pgfeov}%
        \ifx\sseq@temp\pgfutil@empty\else
            #1\@xp\@xp\@xp{\@xp\the\@xp#1\sseq@tempcmd\pgfeov}%
        \fi
    \fi
}

\def\sseq@addsetstylecmdtotoks#1#2{%
    \pgfkeysgetvalue{/tikz/sseqpages/#2/.@cmd}{\sseq@tempcmd}%
    \ifx\sseq@tempcmd\relax\else
        \@xp\def\@xp\sseq@temp\@xp{\sseq@tempcmd\pgfeov}%
        \ifx\sseq@temp\pgfutil@empty\else
            \sseq@temptoks\@xp{\sseq@tempcmd\pgfeov}%
            \edef\sseq@temp{\@nx#1{\the#1\@nx\pgfkeysalso{#2/.code={\the\sseq@temptoks}}}}%
            \sseq@temp
        \fi
    \fi
}

\sseq@set{%
    every sseq/.code={},
    every page/.code={},
    every path/.code={},
    every node/.code={},
    every differential/.code={},
    every class/.style={draw},
    every permanent cycle/.code={},
    every transient cycle/.code={},
    every struct line/.code={},
    every label/.style={ %^^A TODO? make changes to every label work correctly? (maybe?)
            /tikz/auto,
            /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},
            /tikz/inner sep=+0.5ex
    },
    sseqs/.code=           {\pgfkeysalso{every sseq/.append style={#1}}}, %^^A TODO: should sseqs and pages have different handling? (probably)
    pages/.code=           {\pgfkeysalso{every page/.append style={#1}}},
    paths/.code=           {\pgfkeysalso{every path/.append style={#1}}\sseq@redooptions},
    nodes/.code=           {\pgfkeysalso{every node/.append style={#1}}\sseq@redooptions},
    differentials/.code=   {\pgfkeysalso{every differential/.append style={#1}}\sseq@redodifferentialoptions},
    classes/.code=         {\pgfkeysalso{every class/.append style={#1}}\sseq@redoclassoptions},
    labels/.code=          {\pgfkeysalso{every label/.append style={#1}}},%^^A{\sseq@redodifferentialoptions},
    permanent cycles/.code={\pgfkeysalso{every permanent cycle/.append style={#1}}\sseq@redopermtranscycleoptions},
    transient cycles/.code={\pgfkeysalso{every transient cycle/.append style={#1}}\sseq@redopermtranscycleoptions},
    struct lines/.code={\pgfkeysalso{every struct line/.append style={#1}}\sseq@redostructlineoptions},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/global}{%
    sseqs/.code=           {\sseq@set{every sseq/.append style={#1}}},
    pages/.code=           {\sseq@set{every page/.append style={#1}}},
    paths/.code=           {\sseq@set{every path/.append style={#1}}},
    nodes/.code=           {\sseq@set{every node/.append style={#1}}},
    differentials/.code=   {\sseq@set{every differential/.append style={#1}}},
    classes/.code=         {\sseq@set{every class/.append style={#1}}},
    labels/.code=          {\sseq@set{every label/.append style={#1}}},
    degree/.code 2 args={\sseq@degree{#1}{#2}},
    permanent cycles/.code={\sseq@set{every permanent cycle/.append style={#1}}},
    transient cycles/.code={\sseq@set{every transient cycle/.append style={#1}}},
    struct lines/.code={\sseq@set{every struct line/.append style={#1}}},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/first pass}{%
    sseqs/.code=           {\sseq@set{every sseq/.append style={#1}}},
    pages/.code=           {\sseq@set{every page/.append style={#1}}},
    paths/.code=           {\sseq@set{every path/.append style={#1}}\sseq@redooptions},
    nodes/.code=           {\sseq@set{every node/.append style={#1}}\sseq@redooptions},
    differentials/.code=   {\sseq@set{every differential/.append style={#1}}\sseq@redodifferentialoptions},
    classes/.code=         {\sseq@set{every class/.append style={#1}}\sseq@redoclassoptions},
    labels/.code=          {\sseq@set{every label/.append style={#1}}},%^^A{\sseq@redodifferentialoptions},
    permanent cycles/.code={\sseq@set{every permanent cycle/.append style={#1}}\sseq@redopermtranscycleoptions},
    transient cycles/.code={\sseq@set{every transient cycle/.append style={#1}}\sseq@redopermtranscycleoptions},
    struct lines/.code={\sseq@set{every struct line/.append style={#1}}\sseq@redostructlineoptions},
    cycle styles/.code 2 args={\sseq@cyclestyles{#1}{#2}}
}

\pgfqkeys{/tikz/sseqpages/second pass}{ %^^A Is this right?
    sseqs/.code=           {},
    pages/.code=           {},
    paths/.code=           {},
    nodes/.code=           {},
    differentials/.code=   {},
    classes/.code=         {},
    labels/.code=          {},
    permanent cycles/.code={},
    transient cycles/.code={},
    struct lines/.code={},
    cycle styles/.code 2 args={}
}


%^^A% Global options
\def\sseq@xlabelstep{1}
\def\sseq@ylabelstep{1}

\pgfqkeys{/tikz/sseqpages/global}{%
    name/.code={\name{#1}},
    page/.code={\page{#1}},
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
    grid/.code={},
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    axes gap/.code={\def\sseq@xaxisgap{#1}\def\sseq@yaxisgap{#1}},
    x axis gap/.code={\def\sseq@xaxisgap{#1}},
    y axis gap/.code={\def\sseq@yaxisgap{#1}},
    label step/.code={\def\sseq@xlabelstep{#1}\def\sseq@ylabelstep{#1}},
    x label step/.store in=\sseq@xlabelstep,
    y label step/.store in=\sseq@ylabelstep,
    class placement transform/.code={%
        \let\tikz@transform\pgfutil@empty
        \pgfqkeys{/tikz/sseqpages/class placement}{#1}%
        \global\let\sseq@classplacementtransform\tikz@transform
    }
}

\pgfqkeys{/tikz/sseqpages/class placement}{
    x shift/.code={\sseq@error@noclassplacementshift{x shift}{#1}},
    y shift/.code={\sseq@error@noclassplacementshift{y shift}{#1}},
    shift/.code={\sseq@error@noclassplacementshift{shift}{#1}}
}

\sseq@set{%
    name/.code={\sseq@error@optionglobalonly{name}},
    page/.code={\sseq@error@optionglobalonly{page}},
    x range/.code 2 args={\sseq@error@optionglobalonly{x range}},
    y range/.code 2 args={\sseq@error@optionglobalonly{y range}},
    grid/.code={\sseq@error@optionglobalonly{grid}},
    labels/.code={\sseq@error@optionglobalonly{labels}},
    x labels/.code={\sseq@error@optionglobalonly{x labels}},
    y labels/.code={\sseq@error@optionglobalonly{y labels}},
    label step/.code={\sseq@error@optionglobalonly{labelstep}},
    x label step/.code={\sseq@error@optionglobalonly{x labelstep}},
    y label step/.code={\sseq@error@optionglobalonly{y labelstep}}
}


%^^A% setup for coordinate transformation keys
\sseq@set{%
    x/.code={\sseq@transform{x}{#1}}, %^^A TODO: Check what happens if you try to use x or y -- actually should probably make this illegal?? would require work not to I think
    y/.code={\sseq@transform{y}{#1}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.code={\sseq@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@shifttransform{yshift}{#1}},
    shift/.code={\sseq@transform{shift}{#1}},
    shift only/.code={\sseq@transform{shift only}{}},
    xscale/.code={\sseq@transform{xscale}{#1}},
    yscale/.code={\sseq@transform{yscale}{#1}},
    scale/.code={\sseq@transform{scale}{#1}},
    scale around/.code={\sseq@transform{scale around}{#1}},
    xslant/.code={\sseq@transform{xslant}{#1}},
    yslant/.code={\sseq@transform{yslant}{#1}},
    rotate/.code={\sseq@transform{rotate}{#1}},
    rotate around/.code={\sseq@transform{rotate around}{#1}},
    cm/.code={\sseq@transform{cm}{#1}},
    reset cm/.code={\sseq@transform{reset cm}{}},
    transform canvas/.code={\sseq@transform{transform canvas}{#1}}
}

%^^A Catch shifts on first pass to update \sseq@x, \sseq@y
\pgfqkeys{/tikz/sseqpages/first pass}{%
    xshift/.code={\sseq@firstpass@shifttransform{xshift}{#1}},
    yshift/.code={\sseq@firstpass@shifttransform{yshift}{#1}}
}

\pgfqkeys{/tikz/sseqpages/second pass/class}{%
    xshift/.code={},
    yshift/.code={}
}

\pgfqkeys{/tikz/sseqpages/second pass/differential}{%
    xshift/.code={},
    yshift/.code={}
}

\def\sseq@error@optionillegal#1#2#3{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}%
}

\def\sseq@error@optionglobalonly#1{%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi]')%
    }{}%
}

\def\sseq@okaytransform#1#2{\pgfkeysalso{/tikz/#1=#2}}
\def\sseq@error@illegaltransform#1#2{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}%
}

\def\sseq@firstpass@checkshifttransform#1#2{%
    \pgfmathparse{int(#2)}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
    }{\sseq@error@illegaltransform{#1}{#2}}%
}
\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform

\def\sseq@checkshifttransform#1#2{%^^A TODO: on second pass, usually shouldn't have to check?
    \pgfmathparse{int(#2)}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
        \edef\sseq@temp{\@nx\sseq@okaytransform{shift}{{(\pgfmathresult\csname pgf@\sseq@getfirstchar#1\sseq@nil x\endcsname,\pgfmathresult\csname pgf@\sseq@getfirstchar#1\sseq@nil y\endcsname)}}}%
        \sseq@temp
    }{\sseq@error@illegaltransform{#1shift}{#2}}%
}

\def\sseq@okayshifttransform#1#2{%
    \pgfkeysalso{/tikz/#1=#2cm}%
}



\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%^^A% (What should this section be titled?)
\def\sseq@iffullcoord(#1){\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

%^^A apparently only works for full
\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){%
    \@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}%
        {\@firstoftwo}%
        {\ifnum#3<\csname sseq@coord\sseq@thename(#1,#2)@numnodespp\endcsname\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}%
}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}


\def\sseq@whichclass#1#2#3#4#5{%
    \edef#1{#4}%
    %\message{\sseq@thiscall}
    %\@xp\show\csname sseq@coord\sseq@thename(#2,#3)@numnodes\endcsname
    \ifx#1\pgfutil@empty % If no index is provided, just use 1
        \edef#1{1}%
        %\@ifundefined{sseq@coord\sseq@thename(#2,#3)@numnodes}
        %    {\edef#1{1}}%
        %    {\edef#1{\csname sseq@coord\sseq@thename(#2,#3)@numnodes\endcsname}}%
    \else
        \ifnum#4<0% Negative case -- why this command exists
            \@ifundefined{sseq@coord\sseq@thename(#2,#3)@numnodes}{% TODO: Consider suppressing this command if #1=-1? (probably not a good idea).
                \sseq@error{Error: negative index #4 provided for #5 of \sseq@thiscmdname '\sseq@thiscall' but no classes yet exist in #5 position (#2,#3). 
                    Negative indices count from the most recent class in the given position; in particular, there must be at least one existing class}{}
            }{%
                \sseq@tempcount=\csname sseq@coord\sseq@thename(#2,#3)@numnodes\endcsname\relax
                \advance\sseq@tempcount#4\relax
                \advance\sseq@tempcount1\relax
                \ifnum\sseq@tempcount<1\relax 
                    \sseq@error{Error: index #4 provided for the #5 of \sseq@thiscmdname '\sseq@thiscall' is out of bounds -- fewer than \@gobble#4 classes exist at #5 position (#2,#3)}{}
                \fi
                \edef#1{\the\sseq@tempcount}%
            }%
        \fi
    \fi % TODO: Check here whether the given class is dead
}

%^^A% Parsers

%^^A \sseq@parsecoords:
%^^A #1 -- output command
%^^A #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
%^^A Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\conditionally@traceoff\pgfmathparse{#2}\conditionally@traceon\edef\sseq@temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\sseq@temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@parsecoords@@@uptopt#2\sseq@nil\fi\fi}
\def\sseq@parsecoords@@@uptopt#1.#2\sseq@nil{#1}


%^^A \sseq@parsecommas:
%^^A (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
%^^A The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax
    \ifnum\sseq@commacount<4 % This causes an error without a space I think?
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@pc@stdslsl#1{%^^A This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1\relax
    \ifx&#1& %^^A This without a space before the %^^A breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

%^^A These are for accessing the output of \sseq@parsecommas

%^^A #1 -- callback to apply to the argument if it is present
%^^A #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%^^A       if we don't want to throw an error, this argument should generally end in \@gobbletwo
%^^A #3 -- the name of the command
%^^A #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%^^A% Command redefinition commands

%^^A Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@
    \fi %
}

%^^A Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@
    \fi %
}

%^^A Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@tikzcommands{%
        \clip\coordinate\draw\fill\filldraw
        \graph\matrix\node\path\pattern
        \shade\shadedraw\useasboundingbox
}

\def\sseq@modtikzcommands@defer{%
    \let\scope\sseq@scope
    \let\endscope\sseq@endscope
    \@xp\sseq@modtikzcommands@defer@\sseq@tikzcommands\sseq@nil
}
\def\sseq@modtikzcommands@defer@#1{\ifx#1\sseq@nil\else\def#1{\sseq@defer@tikzcommand#1}\@xp\sseq@modtikzcommands@defer@\fi}
\def\sseq@defer@tikzcommand#1#2;{%
    \begingroup
    \sseq@temptoks{}%
    \sseq@changeoptiondirectory@{#1}#2;[\sseq@nil]%
    \edef\temp{\@nx\pgfqkeys{/tikz/sseqpages/first pass/tikz primitives}{\the\sseq@temptoks}}\temp
    \sseq@x@addtosavedpaths@ctx{\the\sseq@temptoks@ii}%^^A@ctx variant so that tikz primitives always "use context"
    \endgroup
}

\def\sseq@defer@tikzcommand@getoptions#1[#2]{\ifx#2\sseq@nil\else\sseq@temptoks\@xp{\the\sseq@temptoks#2,}\@xp\sseq@defer@tikzcommand@getoptions\fi}

%^^A Ensure that \sseq@scopeoptions gets inserted exactly once, before all other options.
\def\sseq@changeoptiondirectory#1#2[#3]{%
    \ifx\sseq@nil#3%
        \sseq@temptoks{}%
        \sseq@temptoks@ii{#1[/tikz/sseqpages/second pass/tikz primitives]#2}%^^A\sseq@scopeoptions
    \else
        \sseq@temptoks{#3}%
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%^^A\sseq@scopeoptions,
    \fi
}
\def\sseq@changeoptiondirectory@#1#2[#3]{%^^A same as the first part except no need to insert \sseq@scopeoptions
    \ifx\sseq@nil#3%
        \sseq@temptoks@ii{#1#2}%
    \else
        \sseq@temptoks\@xp{\the\sseq@temptoks,#3}%
        \sseq@ifhop{\sseq@changeoptiondirectory@{#1#2[/tikz/sseqpages/second pass/tikz primitives,#3]}}%
    \fi
}


\def\sseq@modtikzcommands@options{}%^^A\let\sseq@path@stored\path\def\path##1;{\sseq@changeoptiondirectory{\sseq@path@stored}##1;[\sseq@nil]}}

\def\sseq@modtikzcommands@options@#1{%
    \ifx\sseq@nil#1\else
        \@xp\let\csname sseq@\sseq@macroname#1@stored\endcsname#1%
        \edef#1##1;{\@nx\sseq@changeoptiondirectory{\@xp\@nx\csname sseq@\sseq@macroname#1@stored\endcsname}##1;[\@nx\sseq@nil]}%
        \@xp\sseq@modtikzcommands@options@
    \fi
}

%^^A TODO: respect the style "every scope"
\def\sseq@scopeoptions{}
\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}
\def\sseq@scope@[#1]{%
    \pgfqkeys{/tikz/sseqpages/first pass/scope}{#1}%
    \@xp\def\@xp\sseq@scopeoptions\@xp{\sseq@scopeoptions#1,}%
    \sseq@redooptions
    \sseq@g@addtosavedpaths{\begin{scope}[/tikz/sseqpages/second pass/scope,#1]}%
}
\def\sseq@endscope{\sseq@g@addtosavedpaths{\end{scope}}}

%^^A transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@store#1{\edef\sseq@temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\sseq@temp}
\def\sseq@get#1{\ifx#1\sseq@novalue\edef\sseq@temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\sseq@temp\fi}


%^^A% Environment definitions

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%^^A}

\def\sseqdata@[#1]#2{%
    \sseq@inprogresstrue
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
    %^^A These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    %
    %^^A These are used to decide whether to add a certain node to savedpaths.
    %^^A In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    %^^A If the user doesn't specify a range, all nodes should be rendered
    %^^A To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
    %^^A copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\replace\d\degree %
        \structline %
    }%
%
    \sseq@data@name{#2}%
    \def\sseq@xaxisgap{0.5cm}%
    \def\sseq@yaxisgap{0.5cm}%
    \def\sseq@maxpage{0}%
    \gdef\sseq@classplacementtransform{}%
%
    %^^A the default option handler for /tikz/sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \pgfqkeys{/tikz/sseqpages/global}{{\sseq@thename} options/.code={},#1}%
    \sseq@redooptions
    %^^ATo give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \edef\temp{\global\let\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname\@xp\@nx\csname pgfk@/tikz/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname}%
    \temp
    \gdef\sseq@savedbackgroundpaths{}%
    \gdef\sseq@savedforegroundpaths{}%
    \gdef\sseq@compilesseq{}%
%
    \@xp\gdef\csname sseq@savednodes@\sseq@thename infty\endcsname{}%
    \@xp\gdef\csname sseq@savedfeatures@\sseq@thename infty\endcsname{}%
    %^^A Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \sseq@tempcount=0\relax
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@saveddiffs@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
    }%
%
    \sseq@modtikzcommands@defer %^^A Defer evaluation of tikz primitives
    \sseq@patchfor %^^A patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} %^^A install quotes parsing
    \selectfont\nullfont
    \def\par{}%
}

%^^A Store the savedpaths and ranges
\def\endsseqdata{%
    %^^A\@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
    \sseq@compilesseq
    \sseq@store\sseq@savedbackgroundpaths %
    \sseq@store\sseq@savedforegroundpaths
    \sseq@store\sseq@classplacementtransform
%
    \sseq@store\sseq@thepermcyclestyle\sseq@store\sseq@thetranscyclestyle %
%
    \sseq@store\sseq@xlabelstep\sseq@store\sseq@ylabelstep %
    \sseq@store\sseq@xaxisgap\sseq@store\sseq@yaxisgap %
    \sseq@store\sseq@xmin\sseq@store\sseq@xmax %
    \sseq@store\sseq@ymin\sseq@store\sseq@ymax %
    \sseq@store\sseq@maxpage
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %^^A}

\def\sseqpage@[#1]{%
    \sseq@inprogresstrue
    \let\sseq@savedbackgroundpaths\sseq@novalue
    \let\sseq@savedforegroundpaths\sseq@novalue
    \let\sseq@xaxisgap\sseq@novalue
    \let\sseq@yaxisgap\sseq@novalue
    \let\sseq@xlabelstep\sseq@novalue
    \let\sseq@ylabelstep\sseq@novalue
    \let\sseq@xmin\sseq@novalue\let\sseq@xmax\sseq@novalue
    \let\sseq@ymin\sseq@novalue\let\sseq@ymax\sseq@novalue
    %^^A Copy commands into user namespace
    \sseq@copypagecommands{\name\page\classoptions\doptions\xrange\yrange}%
%
    \gdef\sseqpage@cleanup{} %^^A For undoing local option settings
    \def\sseq@currentoptionpath{this page}%
    \pgfqkeys{/tikz/sseqpages/global}{#1}%
    \
    %
    %^^A Defer evaluation of all tikz primitives
    \sseq@modtikzcommands@defer %
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}%
    \sseq@patchfor %
    \selectfont\nullfont
    \def\par{}%
}

\def\endsseqpage{%
    %^^A Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \pgfkeys{%
      /tikz/edge quotes mean={%
        edge node={node [%^^Aexecute at begin node=$,%^^A$
                         %^^Aexecute at end node=$,%^^A$
                         auto=right,/tikz/sseqpages,every label,##2]{##1}}}}%
%
    %^^A Set it up so that options are dumped out but not expanded
    %^^A So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \let\sseq@transform\sseq@okaytransform %^^A Allow all coordinate transforms in global options
    \let\sseq@shifttransform\sseq@okaytransform
    %
    \edef\temp{\@nx\begin{tikzpicture}[/tikz/sseqpages,every sseq,/tikz/sseqpages/global/{\sseq@thename} options,/tikz/sseqpages/global/{this page} options]}%
    \temp
    \tikzset{%
        z=0pt,
        every path/.style={},
        every node/.style={}
    }%
    \sseq@redooptions % This is actually completely pointless...
    %
    \let\sseq@transform\sseq@error@illegaltransform %^^A Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform %^^A Allow shifts as long as they are by integers and have no units.
%
    \begingroup %^^A for \sseq@modtikzcommands@options
    \sseq@modtikzcommands@options
    \sseq@savedbackgroundpaths
    \endgroup
    %^^A Axes -- eventually incorporate \axesstyle, label options, changing the increment between the numbers, etc
    \sseq@drawaxes
    \sseq@drawxlabels
    \sseq@drawylabels
    \sseq@clip
%
%
    %^^A Patch in modified tikz parsing rule
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
%
%^^A    \@xp\sho\csname sseq@savednodes@\sseq@thename2\endcsname
    %^^A Insert nodes from all pages on or after the current one
        \sseq@tempcount=\sseq@thepage\relax
        \advance\sseq@tempcount-1\relax
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@savednodes@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
        \csname sseq@savednodes@\sseq@thename infty\endcsname
%
%
        \sseq@tempcount=\sseq@thepage\relax
        \advance\sseq@tempcount-1\relax
        \loop
            \advance\sseq@tempcount1\relax
            \csname sseq@savedfeatures@\sseq@thename\the\sseq@tempcount\endcsname %
        \ifnum\sseq@tempcount<\sseq@maxpage\repeat
        \csname sseq@savedfeatures@\sseq@thename infty\endcsname
%
    %^^A Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    \csname sseq@saveddiffs@\sseq@thename\sseq@thepage\endcsname %
%
    %^^A dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@modtikzcommands@options
    \sseq@savedforegroundpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup %^^A blank any options special to this page
    \let\sseq@thename\relax %
}

\def\sseq@drawaxes{%
    %\pgftransformationadjustments
    \bgroup
    \pgfgettransformentries{\a}{\b}{\c}{\d}{\sx}{\sy}\pgfsettransformentries{\a}{\b}{\c}{\d}{\sx}{-\sseq@xaxisgap+\sy}%
    \pgfpathmoveto{\pgfpoint{\sseq@xmax cm+0.5cm}{\sseq@ymin cm}}%
    \pgftransformshift{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \pgftransformresetnontranslations
    \pgfpathlineto{\pgfpoint{-0.9cm-\sseq@yaxisgap}{0cm}}%
    \egroup
    \bgroup
    \pgfgettransformentries{\a}{\b}{\c}{\d}{\sx}{\sy}\pgfsettransformentries{\a}{\b}{\c}{\d}{-\sseq@yaxisgap+\sx}{\sy}%
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm+0.5cm}}%
    \pgftransformshift{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \pgftransformresetnontranslations
    \pgfpathlineto{\pgfpoint{0cm}{-0.85cm-\sseq@xaxisgap}}%
    \egroup
    \pgfusepath{stroke}%
%^^A   \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
%^^A          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
}


\def\sseq@drawxlabels{%
    \sseq@tempy=\sseq@ymin\relax
    %^^A\advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}%
    \sseq@tempx=\sseq@xmin\relax
    \loop
        \bgroup
        %^^A\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \pgftext[at=\pgfpoint{0cm}{-0.5cm-\sseq@xaxisgap}]{$\the\sseq@tempx$}%
        \egroup
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}

\def\sseq@drawylabels{%
    \sseq@tempx=\sseq@xmin\relax
    %^^A\advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@temp{\the\sseq@tempy}%
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %^^A\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \bgroup
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}%
        \pgftransformresetnontranslations
        \pgftext[at=\pgfpoint{-0.5cm-\sseq@yaxisgap}{0cm}]{$\the\sseq@tempy$}%
        \egroup
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@temp\repeat
}

\def\sseq@clip{%
    %^^A\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \bgroup
    \pgfgettransformentries{\a}{\b}{\c}{\d}{\sx}{\sy}%
    \sseq@tempxdim=-\sseq@yaxisgap\relax
    \advance\sseq@tempxdim\sx\relax
    \advance\sseq@tempxdim0.1cm\relax
    \sseq@tempydim=-\sseq@xaxisgap\relax
    \advance\sseq@tempydim\sy\relax
    \advance\sseq@tempydim0.1cm\relax
    \pgfsettransformentries{\a}{\b}{\c}{\d}{\sseq@tempxdim}{\sseq@tempydim}%
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}%
    \pgfsettransformentries{\a}{\b}{\c}{\d}{\sseq@tempxdim}{0.5cm+\sy}%
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}%
    \pgfsettransformentries{\a}{\b}{\c}{\d}{0.5cm+\sx}{0.5cm+\sy}%
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymax cm}}%
    \pgfsettransformentries{\a}{\b}{\c}{\d}{0.5cm+\sx}{\sseq@tempydim}%
    \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}%
    \egroup
    \pgfusepath{clip}%^^A This has to be after the egroup or else the clipping gets screwed up
}

\def\printpage[#1]{%
    \begin{sseqpage}[#1]%
    \end{sseqpage}%
}


%^^A% Options and primitives for sseqdata and sseqpage
\def\sseq@data@name#1{\def\sseq@thename{#1}}
%^^A When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@get\sseq@savedbackgroundpaths %
    \sseq@get\sseq@savedforegroundpaths
    \sseq@get\sseq@classplacementtransform
    \sseq@get\sseq@xlabelstep\sseq@get\sseq@ylabelstep
    \sseq@get\sseq@xaxisgap\sseq@get\sseq@yaxisgap
    \sseq@get\sseq@xmin  \sseq@get\sseq@xmax %
    \sseq@get\sseq@ymin  \sseq@get\sseq@ymax %
    \sseq@get\sseq@maxpage
    \let\xmin\sseq@xmin\let\xmax\sseq@xmax
    \let\ymin\sseq@ymin\let\ymax\sseq@ymax
}

\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobble %^^A Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    %^^A Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

\def\sseq@newmaxpage#1{%
    \ifnum#1>\sseq@maxpage\gdef\sseq@maxpage{#1}\fi
}

%^^A If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
%^^A Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1{%
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax@active#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

%^^A Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\sseq@thepage}
\def\sseq@page@page@{\let\sseqthepage\sseq@thepage\sseq@tempcount=\sseq@thepage\advance\sseq@tempcount-1\edef\sseq@thepagemm{\the\sseq@tempcount}}

\def\sseq@classoptions(#1)#2{%
    \def\temp{#1}%
    \ifsseq@fastmode
        \sseq@iffullcoord(#1){}{\edef\temp{\temp,1}}%
    \else
        \sseq@iffullcoord(#1){%
            \@ifundefined{sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes}{\sseq@error{There are no classes at \sseq@fullcoord@to@partialcoord(#1)}{}}%
            \ifnum\csname sseq@coord\sseq@thename\sseq@fullcoord@to@partialcoord(#1)@numnodes\endcsname=1\relax
                \sseq@error{%
                    There is only one node at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                    '\string\classoptions\sseq@fullcoord@to@partialcoord(#1){#2}'%
                }%
            \fi
        }{%
            \@ifundefined{sseq@coord\sseq@thename(#1)@numnodes}{\sseq@error{There are no classes at (#1)}{}}%
            \ifnum\csname sseq@coord\sseq@thename(#1)@numnodes\endcsname=1\relax
                \edef\temp{\temp,1}%
            \else
                \sseq@error{%
                    There are multiple nodes at coordinate (#1) so instead of '\string\classoptions(#1){#2}' you should say
                    '\string\classoptions(#1,n){#2}' where 'n' is the number of the node you are referring to%
                }%
            \fi
        }%
        \sseq@ifdead(\temp){%
            \ifnum\sseq@thepage>\sseq@getdeathpage(\temp)\relax
                \sseq@error{The node (#1) perished on page \sseq@getdeathpage(\temp) so there is no reason to add an option to it on page \sseq@thepage}{}%
            \fi
        }{}%
    \fi
    \@xp\ifx\csname sseq@classstyle\sseq@thename(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@classstyle\sseq@thename(\temp)\endcsname{}}%
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@classstyle\sseq@thename(\temp)\endcsname{#2,}%
}

\def\sseq@doptions#1(#2){%
    \sseq@tempcount=#1%^^A%
    \edef\temp{\@nx\sseq@doptions@{\the\sseq@tempcount}{#2}}\temp%
}


\def\sseq@doptions@#1#2#3{%
    \def\temp{#2}%
    \ifsseq@fastmode
        \sseq@iffullcoord(#2){}{\edef\temp{\temp,1}}%
    \else
        \sseq@iffullcoord(#2){%
            \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
                \sseq@error{%
                    There is only one node at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                    '\string\doptions#1\sseq@fullcoord@to@partialcoord(#2){#3}'%
                }%
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
            \fi
        }{%
            \ifnum\csname sseq@coord\sseq@thename(#2)@numnodes\endcsname=1\relax
                \edef\temp{\temp,1}%
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
            \else
                \sseq@error{%
                    There are multiple nodes at coordinate (#2) so instead of '\string\doptions#1(#2){#3}' you should say
                    '\string\doptions#1(#2,n){#3}' where 'n' is the number of the node you are referring to%
                }%
                \@ifundefined{sseq@dstyle\sseq@thename#1(\temp)}{\sseq@error{There is no differential of the form '\string\d#1(#2)' so I can't add options to it}{}}{}%
            \fi
        }%
        \@ifundefined{sseq@thepage}{}{\ifnum\sseq@thepage=#1\relax\else\ifnum\sseq@thepage=0\else
            \sseq@error{Adding an option to a differential on page #1 when the current page is \sseq@thepage\sseq@macroname\ has no effect}{}%
        \fi\fi}%
    \fi
%
    \@xp\ifx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname\pgfutil@empty
        \sseq@x@addto@macro\sseqpage@cleanup{\gdef\@xp\@nx\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{}}%
    \fi
    \@xp\sseq@g@addto@macro\csname sseq@dstyle\sseq@thename#1(\temp)\endcsname{#3,}%
}



%^^A% Placement
% TODO: Maybe add error checking for whether x,y are integers? any other error checking?
\def\sseq@place{\@ifnextchar[{\sseq@place@}{\sseq@place@[]}}%^^A}
\def\sseq@place@[#1](#2,#3){%
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecoords\temp{#2,#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}%
    \edef\next{\@nx\sseq@place@@(\temp){\the\sseq@temptoks}}%
    \next{#1}%
}
\def\sseq@place@@(#1,#2)#3#4{%
    \sseq@tempx=#1\relax
    \advance\sseq@tempx\sseq@x\relax
    \sseq@tempy=#2\relax
    \advance\sseq@tempy\sseq@y\relax
    \edef\tempcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \@xp\sseq@xminmax\@xp{\the\sseq@tempx}\@xp\sseq@yminmax\@xp{\the\sseq@tempy}%
    \sseq@tempcount=\@ifundefined{sseq@coord\sseq@thename(\tempcoord)@numnodespp}{1}{\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname}%
    \edef\tempnodenum{\the\sseq@tempcount}%
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodes\endcsname{\the\sseq@tempcount}%
    \advance\sseq@tempcount1\relax
    \@xp\xdef\csname sseq@coord\sseq@thename(\tempcoord)@numnodespp\endcsname{\the\sseq@tempcount}
%
    \sseq@temptoks{#3}%^^A node text
%
    \sseq@temptoks@ii{\pgfkeysalso{#4}}%^^A local options
%
    \@xp\gdef\csname sseq@placenum\sseq@thename(\tempcoord,\tempnodenum)\endcsname{0}%^^A to make \replace work correctly
    %^^A Classes that eventually die
    %^^A we use deforaddto@macro here because this macro gets moved, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename(\tempcoord,\tempnodenum)0}{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}%
            {\the\sseq@classoptionslist\the\sseq@thetranscyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname}}%
        \endgroup
    }%
%
    %^^A Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{#1}{\the\sseq@x}{#2}{\the\sseq@y}{\tempnodenum}{\the\sseq@temptoks}%
            {\the\sseq@classoptionslist\the\sseq@thepermcyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname}}%
        \endgroup
    }%
%
    \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\tempcoord,\tempnodenum)}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname\relax}%
    \@xp\gdef\csname sseq@classstyle\sseq@thename(\tempcoord,\tempnodenum)\endcsname{}%
    \sseq@x@addto@macro\sseq@compilesseq{\@nx\sseq@setoffsets{\the\sseq@tempx}{\the\sseq@tempy}}%
    %^^A\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2,\tempnodenum)\endcsname}}%
    %^^A\sseq@x@addto@macro\sseq@compilesseq{\xdef\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname{\@nx\@xp\@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname}}%
%
    %^^A TODO: out of range nodes that eventually get hit get rendered anyways right now. Fix this.
    %^^A TODO: add a print anyways option
%%    \ifnum\sseq@tempx<\sseq@xmaxpp\ifnum\sseq@tempx>\sseq@xminmm\ifnum\sseq@tempy<\sseq@ymaxpp\ifnum\sseq@tempy>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%^^A no need for defor since infty page initialized at begin{sseqdata}%
%^^A            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
%^^A                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
%^^A            \@nx\fi %
            \@xp\@nx\csname sseq@placeinfty\sseq@thename(\tempcoord,\tempnodenum)0\endcsname %
        }%
%%    \fi\fi\fi\fi %
    \endgroup
}

\def\sseq@replace{\@ifnextchar[{\sseq@replace@}{\sseq@replace@[]}}%^^A}

\def\sseq@replace@[#1](#2,#3){%
    \begingroup
    \pgfqkeys{/tikz/sseqpages/first pass/class}{#1}%
    \sseq@parsecommas(#2,#3)%
    \@xp\sseq@replace@@\@xp{\sseq@classnodetext}{#1}%
}

\def\sseq@replace@@#1#2{%
    \sseq@arg@checkpresent\replace1%
    \sseq@arg@checkpresent\replace2%
    \edef\coord{(\sseq@arg1,\sseq@arg2,\sseq@optarg{1}3)}%
    \edef\coordname{(\sseq@arg1,\sseq@arg2\sseq@optargc3)}%
    \sseq@ifundefcoord\coord{\sseq@error{There never was a class at \coordname\sseq@macroname\ so I cannot replace it}{}}{}%
    \sseq@ifdead\coord{}{\sseq@error{I cannot replace the class at \coordname\sseq@macroname\ because it seems to be alive and well}{}}%
    \sseq@tempcount=\csname sseq@placenum\sseq@thename\coord\endcsname\relax
    \advance\sseq@tempcount1\relax
    \edef\tempclassversion{\the\sseq@tempcount}%
    \@xp\xdef\csname sseq@placenum\sseq@thename\coord\endcsname{\the\sseq@tempcount}%
%
    \sseq@temptoks{#1}%^^A node text
%
    \sseq@temptoks@ii{\pgfkeysalso{#2}}%^^A local options
%
    %^^A Classes that eventually die
    %^^A we use deforaddto@macro here because this macro gets moved around, so any context needs to be installed as part of the sseq@place command
    \sseq@x@deforaddto@macro{sseq@place\sseq@thename\coord\tempclassversion}{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}%
            {\the\sseq@classoptionslist\the\sseq@thetranscyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname}}%
        \endgroup
        \@nx\fi
    }%
%
    %^^A Classes that live forever
    \@xp\xdef\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname{%
        \@nx\ifnum\@nx\sseq@thepage>\sseq@getdeathpage\coord\relax
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue \edef\@nx\tikz@shape{\tikz@shape}\fi
        \@nx\sseq@place@drawnode{\sseq@arg1}{\the\sseq@x}{\sseq@arg2}{\the\sseq@y}{\sseq@optarg{1}3}{\the\sseq@temptoks}%
            {\the\sseq@classoptionslist\the\sseq@thepermcyclestyle\the\sseq@temptoks@ii\@nx\pgfkeysalso{\@xp\@nx\csname sseq@classstyle\sseq@thename\coord\endcsname}}%
        \endgroup
        \@nx\fi
    }%
%
    \sseq@x@deforaddto@macro{sseq@clearinfty\sseq@thename\coord}{\global\let\@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname\relax}%
%%    \ifnum\sseq@arg1<\sseq@xmaxpp\ifnum\sseq@arg1>\sseq@xminmm\ifnum\sseq@arg2<\sseq@ymaxpp\ifnum\sseq@arg2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%^^A no need for defor since infty page initialized at begin{sseqdata}%
%^^A            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname\relax\@nx\else %
%^^A                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2,\tempnodenum)\endcsname %
%^^A            \@nx\fi %
            \@xp\@nx\csname sseq@placeinfty\sseq@thename\coord\tempclassversion\endcsname %
        }%
%%    \fi\fi\fi\fi %
    \sseq@cleardeathpage\coord
    \endgroup
}


%^^A #1 -- x
%^^A #2 -- \sseq@x shift (change name of node but position already accounted for)
%^^A #3 -- y
%^^A #4 -- \sseq@y
%^^A #5 -- n
%^^A #6 -- node text
%^^A #7 -- options
\def\test#1#2#3#4#5#6#7{}
\def\sseq@place@drawnode#1#2#3#4#5#6#7{%
    \begingroup
    %^^A\tracingall
    \sseq@tempx=#1\relax
    \advance\sseq@tempx#2\relax
    \sseq@tempy=#3\relax
    \advance\sseq@tempy#4\relax
    \edef\tempcoord{\the\sseq@tempx,\the\sseq@tempy,#5}%
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \ifsseq@needstikz
            %^^A\let\tikz@quote@parser\sseq@handlequote
            \sseq@temptoks{#6}%
            \sseq@temptoks@ii{#7}%
            \pgftransformshift{\pgfpoint{#1 cm}{#3 cm}}%
            \pgftransformshift{\pgfpoint{#2 cm}{#4 cm}}%
            \pgfgettransform{\savetransform}%
            \pgftransformresetnontranslations
            \sseq@classplacementtransform
            \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\csname sseq@xoffset@\sseq@thename(\tempcoord)\endcsname cm}{\csname sseq@yoffset@\sseq@thename(\tempcoord)\endcsname cm}}}%
            \temp
            \pgftransformresetnontranslations
            \edef\temp{%
                \@nx\node[
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote,
                    /tikz/sseqpages/second pass/class,
                    /utils/exec={\the\sseq@temptoks@ii}%
                ] (sseq@{\tempcoord}) {\the\sseq@temptoks};
            }%
            \temp
        \else
            \pgfscope
            \let\tikz@options\pgfutil@empty
            \let\tikz@alias=\pgfutil@empty
            \def\pgfkeysdefaultpath{/tikz/sseqpages/second pass/}%
            #7%
            \pgftransformshift{\pgfpoint{#1 cm}{#3 cm}}%
            \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
            \pgftransformresetnontranslations
            \sseq@classplacementtransform
            \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@xoffset@\sseq@thename(\tempcoord)\endcsname cm}{0\csname sseq@yoffset@\sseq@thename(\tempcoord)\endcsname cm}}}%
            \temp
            \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\fi
            \tikz@options
            \tikz@node@textfont
            \sseq@setnodetext{#6}%
            \edef\tikz@fig@name{sseq@{\tempcoord}}%
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
            \endpgfscope
        \fi
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}%
        \temp
        \pgftransformresetnontranslations
        \sseq@classplacementtransform
        \edef\temp{\@nx\pgftransformshift{\@nx\pgfpoint{\csname sseq@xoffset@\sseq@thename(\tempcoord)\endcsname cm}{\csname sseq@yoffset@\sseq@thename(\tempcoord)\endcsname cm}}}%
        \temp
        \pgftransformresetnontranslations
        \pgfcoordinate{sseq@{\tempcoord}}{\pgfpointorigin}%
    \fi
    \endgroup
}

\def\sseq@setnodetext#1{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        \tikzset{every text node part/.try}%
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          #1%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    \iftikz@mode@clip \sseq@error{Clip shouldn't happen here, but this error should be caught earlier}{}\fi %^^A TODO: catch this and similar errors?
    \iftikz@mode@draw%
        \iftikz@mode@double%
        %^^A Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    %^^A Step 10: Do stroke/fill as needed
    %
    \edef\temp{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}\temp%
    %
    %^^A Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%^^A% Offsets TODO: This section is pretty unfinished
\def\sseq@setoffsets#1#2{%
    \@ifundefined{sseq@xoffset@\sseq@thename(#1,#2,1)}{\sseq@setoffsets@{#1}{#2}}{\sseq@checkoffsets{#1}{#2}}%
}
\def\sseq@setoffsets@#1#2{%
    \sseq@tempcount=\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname\relax
    \ifcase\sseq@tempcount\relax
        \sseq@error{Internal error. This should never happen}{}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{1}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{2}%
        \sseq@usestdoffsets{#1}{#2}{2}{2}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{3}%
        \sseq@usestdoffsets{#1}{#2}{2}{3}%
        \sseq@usestdoffsets{#1}{#2}{3}{3}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{4}%
        \sseq@usestdoffsets{#1}{#2}{2}{4}%
        \sseq@usestdoffsets{#1}{#2}{3}{4}%
        \sseq@usestdoffsets{#1}{#2}{4}{4}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{5}%
        \sseq@usestdoffsets{#1}{#2}{2}{5}%
        \sseq@usestdoffsets{#1}{#2}{3}{5}%
        \sseq@usestdoffsets{#1}{#2}{4}{5}%
        \sseq@usestdoffsets{#1}{#2}{5}{5}%
    \or
        \sseq@usestdoffsets{#1}{#2}{1}{6}%
        \sseq@usestdoffsets{#1}{#2}{2}{6}%
        \sseq@usestdoffsets{#1}{#2}{3}{6}%
        \sseq@usestdoffsets{#1}{#2}{4}{6}%
        \sseq@usestdoffsets{#1}{#2}{5}{6}%
        \sseq@usestdoffsets{#1}{#2}{6}{6}%
    \else
        \sseq@error{Too many nodes at coordinate (#1,#2). Improve this error message}{}%
    \fi
}%

\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}
\def\sseq@checkoffsets#1#2{} %^^ATODO: Implement this

\sseq@setstdoffsets11{0}{0}%
%
\sseq@setstdoffsets12{-0.13}{0}
\sseq@setstdoffsets22{0.13}{0}
%
\sseq@setstdoffsets13{-0.2}{0}
\sseq@setstdoffsets23{0}{0}
\sseq@setstdoffsets33{0.2}{0}
%
\sseq@setstdoffsets14{-0.13}{-0.13}
\sseq@setstdoffsets24{0.13}{-0.13}
\sseq@setstdoffsets34{-0.13}{0.13}
\sseq@setstdoffsets44{0.13}{0.13}
%
\sseq@setstdoffsets15{-0.16}{-0.16}
\sseq@setstdoffsets25{0.16}{-0.16}
\sseq@setstdoffsets35{-0.16}{0.16}
\sseq@setstdoffsets45{0.16}{0.16}
\sseq@setstdoffsets55{0}{0}
%
\sseq@setstdoffsets16{-0.13}{-0.2}
\sseq@setstdoffsets26{-0.13}{0}
\sseq@setstdoffsets36{-0.13}{0.2}
\sseq@setstdoffsets46{0.13}{-0.2}
\sseq@setstdoffsets56{0.13}{0}
\sseq@setstdoffsets66{0.13}{0.2}



\def\sseq@usestdoffsets#1#2#3#4{%
    \@xp\global\@xp\let\csname sseq@xoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdxoffset#3/#4\endcsname
    \@xp\global\@xp\let\csname sseq@yoffset@\sseq@thename(#1,#2,#3)\@xp\endcsname\csname sseq@stdyoffset#3/#4\endcsname
}


\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %^^A}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp(#3)%
}

\def\sseq@d@@#1#2(#3,#4){%
%
    \begingroup
    \def\sseq@thiscmdname{differential }
    \def\sseq@thiscall{\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)}%
    \sseq@newmaxpage{#2}%
    \pgfqkeys{/tikz/sseqpages/first pass/differential}{#1}%
    \sseq@parsecommas(#3,#4)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{source}%
    \edef\sourcecoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}%
    \edef\source{(\sourcecoord,\tempn)}%
%
%
    \pgfmathparse{int(\the\sseq@tempx+\sseq@targetx{#2})}%
    \sseq@tempx=\pgfmathresult\relax
    \pgfmathparse{int(\the\sseq@tempy+\sseq@targety{#2})}%
    \sseq@tempy=\pgfmathresult\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}4}{target}%
    \edef\targetcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \edef\targetname{(\targetcoord\sseq@optargc4)}%
    \edef\target{(\targetcoord,\tempn)}%
%
%^^A   Errors:
    \ifsseq@fastmode\else
        \sseq@ifundefcoord\source{%
            \sseq@error{%
                Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifundefcoord\target{%
            \sseq@error{%
                Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
                a differential because a class in that position never existed%
            }{}%
        }{}%
        \sseq@ifdead\source{%
            \ifnum\sseq@getdeathpage\source=#2\else
                \sseq@error{%
                    Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
                    a differential because it already perished on page \sseq@getdeathpage\source %
                }{}%
            \fi
        }{}%
        \sseq@ifdead\target{%
            \ifnum\sseq@getdeathpage\target=#2\else
                \sseq@error{%
                    Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
                    a differential because it already perished on page \sseq@getdeathpage\target %
                }{}%
            \fi
        }{}%
%
        \ifnum\csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname=1\relax
%^^A            \@ifundefined{sseq@arg3}{}{\sseq@error{%
%^^A                There is only one node at source coordinate (\sourcecoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
%^^A                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optarggen{,,\sseq@id}{\@gobbletwo}{}4)'%
%^^A            }{}}
        \else
            \@ifundefined{sseq@arg3}{\sseq@error{%
                There are multiple nodes at source coordinate (\sourcecoord) so instead of '\sseq@thiscall' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\sourcecoord)@numnodes\endcsname\sseq@macroname\ nodes at (\sourcecoord) should be the source%
            }{}}{}%
        \fi
        \ifnum\csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname=1\relax
%^^A            \@ifundefined{sseq@arg4}{}{\sseq@error{%
%^^A                There is only one node at target coordinate (\targetcoord) so instead of '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3,#4)' you should say
%^^A                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord\sseq@optargc3)'%
%^^A            }{}}%
        \else
            \@ifundefined{sseq@arg4}{\sseq@error{%
                There are multiple nodes at target coordinate (\targetcoord) so instead of '\sseq@thiscall' you should say
                '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
                \csname sseq@coord\sseq@thename(\targetcoord)@numnodes\endcsname\sseq@macroname\ nodes at (\targetcoord) should be the target%
            }{}}{}%
        \fi
    \fi
%
    \sseq@temptoks{\pgfkeysalso{#1}}%^^A local options
%
    \sseq@x@deforaddto@macro{sseq@saveddiffs@\sseq@thename#2}{%
        \begingroup
        \ifsseq@needstikz \@nx\sseq@needstikztrue\fi
        \@nx\sseq@d@drawedge\source\target{differential}{\the\sseq@doptionslist\the\sseq@temptoks\@nx\pgfkeysalso{\@xp\@nx\csname sseq@dstyle\sseq@thename#2\source\endcsname}}%
        \endgroup
    }%
%
    \@xp\gdef\csname sseq@dstyle\sseq@thename#2\source\endcsname{}%
%
    %^^A Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} %^^A This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\source\endcsname%
    \csname sseq@clearinfty\sseq@thename\target\endcsname%
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\source\endcsname\relax
    \@xp\global\@xp\let\csname sseq@clearinfty\sseq@thename\target\endcsname\relax
%
    %^^A Add placement on appropriate page
    \sseq@x@deforaddto@macro@noctx{sseq@savednodes@\sseq@thename#2}{%
        \sseq@ifdead\source{}{\@xp\@nx\csname sseq@place\sseq@thename\source\csname sseq@placenum\sseq@thename\source\endcsname\endcsname}%
        \sseq@ifdead\target{}{\@xp\@nx\csname sseq@place\sseq@thename\target\csname sseq@placenum\sseq@thename\target\endcsname\endcsname}%
    }%
%
    \sseq@setdeathpage\source{#2}%
    \sseq@setdeathpage\target{#2}%
    \endgroup
}

%^^A #1 -- source
%^^A #2 -- target
%^^A #3 -- options
\def\sseq@d@drawedge(#1)(#2)#3#4{%
    \ifsseq@needstikz
        \sseq@temptoks{#4}%
        \edef\temp{\@nx\draw[draw,/tikz/sseqpages/second pass/differential,/utils/exec={\the\sseq@temptoks}] (#1) to (#2);}%
        \temp
    \else
        \pgfscope
        \pgfqkeysalso{/tikz/sseqpages/second pass/differential}{draw}%
        #4%
        \tikz@options
        \tikz@mode
        \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
            \def\tempa{\@nx\pgfpointanchor{sseq@{#1}}{center}}%
        \else
            \def\tempa{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#1)}%
            \let\tempaf\tempa
        \fi
        \@xp\ifx\csname pgf@sh@pi@sseq@{#2}\endcsname\pgfpictureid
            \def\tempb{\@nx\pgfpointanchor{sseq@{#2}}{center}}%
            \def\tempbf{\@nx\pgfpointshapeborder{sseq@{#2}}{\tempa}}%
        \else
            \def\tempb{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#2)}%
            \let\tempbf\tempb
        \fi
        \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
            \def\tempaf{\@nx\pgfpointshapeborder{sseq@{#1}}{\tempb}}%
        \fi
        \edef\temp{%
            \@nx\pgfpathmoveto{\tempaf}%
            \@nx\pgfpathlineto{\tempbf}%
        }\temp
        %^^A\xdef\tikz@timer@end{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}
        \edef\temp{\noexpand\pgfusepath{%
            \iftikz@mode@fill fill,\fi%
            \iftikz@mode@draw draw,\fi%
        }}\temp
        %^^A\tikz@node@textfont
        %^^A\def\tikz@time{0.5}%
        %^^A\tikz@do@auto@anchor%
        %^^A\tikz@timer%
        %^^A\tikz@timer@line
        %^^A\tikz@transform
        %^^A\pgfnode{rectangle}{\tikz@anchor}{hi}{}{\pgfusepath{draw}}%
        \endpgfscope
    \fi
}

\def\sseq@addcontingentfeature#1#2{%
    \sseq@g@deforaddto@macro{sseq@feature\the\sseq@featurecount}{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    \@xp\sseq@x@addto@macro\csname sseq@savedfeatures@\sseq@thename infty\endcsname{%
        \@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname
%^^A        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
%^^A            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
%^^A        \@nx\fi %
    }%
    %
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        %^^A\sseq@temppage is defined by \d before it calls this.
        \@nx\sseq@g@deforaddto@macro@noctx{sseq@savedfeatures@\sseq@thename\@nx\sseq@temppage}{%^^A needs to be defor in case this is placed before the nodes it connects.
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil,)%
    \global\advance\sseq@featurecount1\relax
}

\def\sseq@addcontingentfeature@(#1,#2){%
    \ifx\sseq@nil#1\else %
        \sseq@parsecoords\temp{#1,#2}%
        \@xp\sseq@iffullcoord\@xp(\temp){}{%
            \edef\temp{\temp,\@ifundefined{sseq@coord\sseq@thename(#1,#2)@numnodes}{1}{\csname sseq@coord\sseq@thename(#1,#2)@numnodes\endcsname}}%
        }%
        \sseq@x@deforaddto@macro@noctx{sseq@clearinfty\sseq@thename(\temp)}{%^^A should be deforaddto, so that it will work even if this is called before the node is placed
            \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname
        }%
    %
        \@xp\sseq@addcontingentfeature@
    \fi
}

\def\sseq@structline{\@ifnextchar[{\sseq@structline@}{\sseq@structline@[]}}%]
\def\sseq@structline@[#1](#2)(#3){%
    \edef\temp{\@nx\sseq@structline@@\sseq@anchorsplit{#2}\sseq@anchorsplit{#3}}%
    \temp{#1}{\string\structline\ifx\sseq@nil#1\sseq@nil \else[#1]\fi(#2)(#3)}%
}
\def\sseq@structline@@#1#2#3#4#5#6{%
    \begingroup
    \def\sseq@thiscmdname{structure line }% To pass error information to \sseq@whichclass
    \def\sseq@thiscall{#6}%
    \sseq@parsecoords\source{#1}%
    %^^A\@xp\sseq@iffullcoord\@xp(\source){}{\edef\source{\source,1}}%
    \sseq@parsecoords\target{#3}%
    %^^A\def\temp{#4}%
    %^^A\@xp\sseq@iffullcoord\@xp(\target){}{\edef\target{\target,1}}%
    \edef\temp{%
        \@nx\sseq@structline@@@
            \@xp\sseq@iffullcoord\@xp(\source)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\source){\@xp\sseq@fullcoord@lastelt\@xp(\source)}}%
                {(\source){}}%^^A{\@ifundefined{sseq@coord\sseq@thename(\source)@numnodes}{}{,\csname sseq@coord\sseq@thename(\source)@numnodes\endcsname}}}%
            {#2}%
            \@xp\sseq@iffullcoord\@xp(\target)%
                {\@xp\sseq@fullcoord@to@partialcoord\@xp(\target){\@xp\sseq@fullcoord@lastelt\@xp(\target)}}%
                {(\target){}}%^^A{\@ifundefined{sseq@coord\sseq@thename(\target)@numnodes}{}{,\csname sseq@coord\sseq@thename(\target)@numnodes\endcsname}}}%
            {#4}%
    }%
    \temp{#5}%
    \endgroup
}
\def\sseq@structline@@@(#1,#2)#3#4(#5,#6)#7#8#9{%
    \pgfqkeys{/tikz/sseqpages/first pass/struct line}{#9}%
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#5\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#6\relax
    \sseq@temptoks{\pgfkeysalso{#9}}%
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source}%
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#7}{target}%
    \edef\temp{\@nx\sseq@addcontingentfeature{(\the\sseq@tempx,\the\sseq@tempy)(\the\sseq@tempxb,\the\sseq@tempyb)}{%
            \begingroup
                \ifsseq@needstikz\@nx\sseq@needstikztrue\fi\@nx
                \sseq@d@drawedge (\the\sseq@tempx,\the\sseq@tempy,\sseq@na)(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)%
                    {struct line}{\the\sseq@structlineoptionslist\the\sseq@temptoks}%
            \endgroup
        }
    }%
    \temp
}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}


%^^A% Redo tikz parsing rules for interpreting coordinates
%^^A We want to intepret (x,y) as the name of a node.		
%
%^^A Original behavior:
%^^A The original parsing rule said roughly:
%^^A   if there's a cs: treat it like a coordinate shift
%^^A     if there's the word intersection: treat it as an intersection
%^^A       ...
%^^A        if there's a comma treat it as a literal coordinate
%^^A          else treat it as the name of a node
%
%^^A We replace the second to last step with:
%^^A    if there's a comma, check if there's a node named sseq@{x,y} (alternatively sseq@{x,y,z})
%^^A      if there is such a node, treat it as refering to sseq@{x,y}
%^^A      else treat it as a literal coordinate
%
%^^A Note that we name the cell nodes sseq@{x,y,z}.


\def\sseq@testpt#1.#2\sseq@nil{\ifx&#2&{#1}{}\else
    \sseq@ifnum#2\sseq@nil{\sseq@testpt@{#1}#2\sseq@nil}{{#1}{.\sseq@gobblept#2\sseq@nil}}\fi}
\def\sseq@testpt@#1#2.#3\sseq@nil{{#1.#2}\ifx&#3&{}\else{.\sseq@gobblept#3\sseq@nil}\fi}

\def\sseq@gobblept#1.\sseq@nil{#1}
\def\sseq@ifnum#1#2\sseq@nil{%
    \ifx#10\sseq@ifnum@first\fi\ifx#11\sseq@ifnum@first\fi\ifx#12\sseq@ifnum@first\fi
    \ifx#13\sseq@ifnum@first\fi\ifx#14\sseq@ifnum@first\fi\ifx#15\sseq@ifnum@first\fi
    \ifx#16\sseq@ifnum@first\fi\ifx#17\sseq@ifnum@first\fi\ifx#18\sseq@ifnum@first\fi\ifx#19\sseq@ifnum@first\fi
    \@secondoftwo
}
\def\sseq@ifnum@first#1\@secondoftwo{\fi\@firstoftwo}


\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%^^A(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\sseq@nil}%
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4{%
    \sseq@parsecoords\temp{\sseq@x+#2,\sseq@y+#3}%
    \@xp\sseq@iffullcoord\@xp(\temp){}{%
        \@ifundefined{sseq@coord\sseq@thename(\temp)@numnodes}{}%
            {\ifnum\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname=1\relax\edef\temp{\temp,1}\fi}%
            %^^A{\edef\temp{\temp,\csname sseq@coord\sseq@thename(\temp)@numnodes\endcsname}}
    }%
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid %^^A Check if a node with name sseq@{x,y} is defined in this picture
        \def\tikztotarget{sseq@{\temp}}%^^A fixes the bend left and bend right options (probably others)
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}%
    \else %^^A( %^^A No such node exists
        \ifx&#4& %^^A make sure there is no anchor
            \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3})}%^^A Parse it as the coordinate (x,y) (not a node)
        \else
            \sseq@error{There is no node at (\temp), but you specified the anchor '\@gobble#4'. In order to accept an anchor, there must be a node at the given location}{}%
        \fi
    \fi
    \next
}

%^^A% Patch \foreach to use sseq@context
%^^A TODO: Add stuff for when this fails
\def\sseq@pgffor@@vars@opt[#1]{\pgfkeys{/tikz/sseqpages/foreach/.cd,#1}\pgffor@vars}
\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{%
    \let\pgffor@@vars@opt\sseq@pgffor@@vars@opt
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@g@addto@macro@ctx\sseq@g@addto@macro@foreach %
    \let\sseq@x@addto@macro@ctx\sseq@x@addto@macro@foreach %
    \let\sseq@g@deforaddto@macro@ctx\sseq@g@deforaddto@macro@foreach %
    \let\sseq@x@deforaddto@macro@ctx\sseq@x@deforaddto@macro@foreach %
    \advance\sseq@context@depth1\relax %
    \sseq@for@clearsavedtoks %
}

\patchcmd\sseq@pgffor@invokebody %^^A store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}}
    {}{\no}
\patchcmd\sseq@pgffor@doloop %^^A store setting before
    {\ifx\pgffor@assign@before@code}
    {\sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@var{\pgffor@var}}%
     \ifx\pgffor@assign@before@code}
    {}{\no}
\patchcmd\sseq@pgffor@invokebody %^^A reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}
\patchcmd\sseq@pgffor@doloop %^^A reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\no}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@addtosavedtoks{\def#2{#4}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@addtosavedtoks{\def#1{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@xaddtosavedtoks{\def\@nx#1{\pgfmathresult}}}}
    {}{\no}


\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@xaddtosavedtoks{\def\@nx#1{\the#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@xaddtosavedtoks\@xp{\@xp\def\@xp#1\@xp{#2}}}}
    {}{\no}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@xaddtosavedtoks{\def\@nx#2{#1}}}}
    {}{\no}


\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \sseq@for@xaddtosavedtoks{\def\@xp\@nx\pgffor@currentvar{\pgffor@temp}}}
    {}{\no}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@once@expanded}}
    {}{\no}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \sseq@for@addtosavedtoks{\pgffor@remember@expanded}}
    {}{\no}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\no}
%}{}
%\end{comment}
