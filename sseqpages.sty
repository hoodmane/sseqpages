%%
%
% Sseqpages 0.9
% A package for drawing spectral sequences
% Written by Hood Chatham
%
%%

% TODO:
% manual
%
% Improve errors
% Check \sseqset used inside environments
% Figure out whether e.g., "change classes" could have a better name
% Maybe modify "change classes" mechanism
% Fix name or make synonym for struct lines? Abbreviation seems not obvious
% Structline only appears between most recent version of each class
%
% Add ifdead(class) and ifalive(class) as predicates for "page constraint" for Tikz primitives
% Make naming of commands more consistent
%
% improve robustness of modified tikz code (add file to check original values)
%
% named standard offset patterns with options
% improve axes options? allow axis to be centered on coordinate or centered between coordinates
% User interface to control arrow head for edges that go off page (option to turn ellipses off)
% automated grids
%
% Make "rotate" on labels rotate in place
% Make transform shape default for labels?
%
% Make shift={coord} work
% "page range" option for tikz primitives

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{sseqpages}

\newif\ifsseq@versionwarn
\newcount\sseq@errormode
\sseq@errormode=1\relax

\RequirePackage{tikz}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usetikzlibrary{positioning}
\usetikzlibrary{intersections}
\usetikzlibrary{backgrounds}
\usepgflibrary{arrows.meta}
%\usetikzlibrary{profiler}

\def\sseq@authorname#1{Hood Chatham}
\def\sseq@authoremail#1{hood@mit.edu}

\DeclareOption{versionwarn}{\sseq@versionwarntrue}
\DeclareOption{fasterrors}{\sseq@fasterrorstrue}
\ProcessOptions\relax
\@ifpackagelater{tikz}{2015/07/08}{%
    \@ifpackagelater{tikz}{2015/08/08}{%
    \ifsseq@versionwarn
        \expandafter\PackageWarning
     \else
        \expandafter\PackageError
     \fi
     {sseqpages}{You are using a version of Tikz later than the version sseqpages was developed for. Something might go wrong. Please say
     '\string\usepackage[version warn]{sseqpages}' to suppress this error message and email me at \sseq@authoremail{} if you find any bugs}{}
    }{%
        % Current version of tikz
    }
}{%
    \ifsseq@versionwarn
        \PackageWarning{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a.}
     \else
        \PackageError{sseqpages}{I'm not sure that the sseqpages package will work with Tikz versions earlier than 3.0.1a. Please say
        '\string\usepackage[version warn]{sseqpages}' to suppress this error message, and email me at \sseq@authoremail{} to let me know whether sseqpages works with your version of Tikz. Or just update Tikz}{}
     \fi

}

% Ensure \@xp and \@nx have the correct values in case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand
\def\@xptwo{\@xp\@xp\@xp}
\def\@xpthree{\@xp\@xp\@xp\@xp\@xp\@xp\@xp}

\def\sseq@macroname{\@xp\@gobble\string}
\def\sseq@gobble@to@nil#1\sseq@nil{}
\def\sseq@nil{\sseq@thisshouldnthappen@nil unique expansion} % This expansion text should be unique so that \ifx\sseq@nil\othercommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use.
\def\sseq@eval#1{\bgroup\edef\sseq@temp{#1}\@xp\egroup\sseq@temp}% I got this from sseq.sty
\def\sseq@eval@show#1{\bgroup\edef\sseq@temp{#1}\show\sseq@temp\@xp\egroup\sseq@temp}
\def\sseq@profilenew#1#2{\pgfprofilenew{#1}\pretocmd#2{\pgfprofilestart{#1}}{}{\error}\apptocmd#2{\pgfprofileend{#1}}{}{\error}}

%% Error messages
\newtoks\sseq@thiscalltoks
\def\sseq@thiscall{\the\sseq@thiscalltoks}
\def\sseq@setthiscall{\let\sseq@error@annotation\sseq@error@annotation@call\sseq@thiscalltoks}
\def\sseq@esetthiscall#1{\let\sseq@error@annotation\sseq@error@annotation@call\sseq@eval{\sseq@thiscalltoks{#1}}}

\def\sseq@error@annotation{^^J(I\@xp\@gobble\sseq@errorinfo)}
\def\sseq@error@annotation@call{.^^J(Error occurred during call \sseq@thiscall\space \sseq@errorinfo)}

\let\sseq@errmessage@std\errmessage
\def\sseq@errmessage#1{\sseq@builderrorinfo\sseq@errmessage@std{#1\sseq@error@annotation}}
\def\sseq@errorwithinfo#1{\let\errmessage\sseq@errmessage@std\sseq@builderrorinfo\pgfutil@packageerror{sseqpages}{#1\sseq@error@annotation}{}}
\def\sseq@errornoinfo#1{\let\errmessage\sseq@errmessage@std\sseq@builderrorinfo\pgfutil@packageerror{sseqpages}{#1}{}}
\let\sseq@error\sseq@errornoinfo
\def\sseq@errorinfo{on input line \sseq@inputlineno}% Changed during \foreach
\def\sseq@inputlineno{\the\inputlineno}
\def\sseq@builderrorinfo{}% Changed during \foreach
\def\sseq@errorinfo@foreach{in the \@nx\foreach block that ends on line \the\inputlineno, with variable values:}

\def\sseq@error@internal#1{\sseq@error{Internal error: #1. Contact package author \sseq@authorname{} at \sseq@authoremail{}}{}}
\def\sseq@error@range{\sseq@error{Empty spectral sequence. For every spectral sequence you must either specify both the "x range" and "y range" or include at least one \string\class}}
\def\sseq@error@standardparse#1{\sseq@error{You cannot use \string#1 inside a scope that has coordinate transformations other than integer shifts or the background key}}

\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces, "identity," used with parsecommas
\def\sseq@getfirstchar#1#2\sseq@nil{#1} % used in parsecoords
\def\sseq@uptocomma#1,#2\sseq@nil{#1}
\def\sseq@fullcoord@to@partialcoord(#1,#2,#3){(#1,#2)}
\def\sseq@fullcoord@to@partialcoordb(#1){\sseq@fullcoord@to@partialcoordb@#1,\@nil}
\def\sseq@fullcoord@to@partialcoordb@#1,#2,#3\@nil{{#1cm}{#2cm}}
\def\sseq@fullcoord@lastelt(#1,#2,#3){#3}


%% Declarations
\newif\ifsseq@hasname
\newif\ifsseq@updateexisting
\newif\ifsseq@ispageenv
\newif\ifsseq@keepchanges
\newif\ifsseq@globaldetone

\newif\ifsseq@needstikz
\newif\ifsseq@thispage
\newif\ifsseq@outofrange
\newif\ifsseq@classlabel
\newif\ifsseq@draworphanedges
\newif\ifsseq@drawedge
\newif\ifsseq@tikzprims@integershift
\sseq@tikzprims@integershifttrue

\newif\ifsseq@tempif
\sseq@drawedgetrue

\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@temptoks@iii
\newtoks\sseq@thislabelstyle

\newcount\sseq@anonsseqcount
\newcount\sseq@commacount
\newcount\sseq@context@depth
\newcount\sseq@context@tempcount
\newcount\sseq@x
\newcount\sseq@y
\newcount\sseq@tempcount
\newcount\sseq@tempcountb
\newcount\sseq@tempx
\newcount\sseq@tempy
\newcount\sseq@tempxb
\newcount\sseq@tempyb
\sseq@context@depth\z@
\sseq@x\z@ \sseq@y\z@

%%% Commands to help the user define "groups" of commands to be reused
\def\sseqnewgroup{\@ifnextchar*{\sseqnewgroup@}{\sseqnewgroup@{}}}
\def\sseqnewgroup@#1#2{\@ifnextchar[{\sseqnewgroup@@{#1}#2}{\sseqnewgroup@@{#1}#2[0]}}%]
\long\def\sseqnewgroup@@#1#2[#3]#4{
    \sseqnewcmd#1#2(\sseq@macrox,\sseq@macroy)[#3]{%
        \bgroup
        \def\sseq@newgroup@temp{}
        \sseq@tempiffalse
        \sseq@temptoks{\options}
        \ifx\sseq@nil\options\sseq@nil\else\sseq@tempiftrue\fi
        \pgfmathparse{int(\sseq@macrox)}
        \sseq@tempcount=\pgfmathresult\relax
        \pgfmathparse{int(\sseq@macroy)}
        \sseq@tempcountb=\pgfmathresult\relax
        \ifnum\sseq@tempcount=0\relax\else\sseq@tempiftrue\fi
        \ifnum\sseq@tempcountb=0\relax\else\sseq@tempiftrue\fi
        \ifsseq@tempif\sseq@eval{\@nx\begin{scope}[xshift=\the\sseq@tempcount,yshift=\the\sseq@tempcountb,\the\sseq@temptoks]}\def\sseq@newgroup@temp{\end{scope}}\fi
            #4% This % is necessary for some reason. Investigate?
        \sseq@newgroup@temp
        \egroup
    }
}

\def\sseqnewcmd{\@ifnextchar*{\@xp\sseqnewcmd@@\@gobble}{\sseqnewcmd@}}
\def\sseqnewcmd@#1{%
    \@ifundefined{\sseq@macroname #1}{}{%
        \sseq@error{%
            A command named \string#1\sseq@macroname\ already exists. If you want to overwrite an existing command, say
            '\string\sseqnewcmd*\string#1...' or '\string\sseqnewgroup*\string#1...' as appropriate
        }{}%
    }%
    \sseqnewcmd@@#1
}
\def\sseqnewcmd@@#1{\@ifnextchar({\sseqnewcmd@@@#1}{\sseqnewcmd@@@#1(\x,\y)}}%)
\def\sseqnewcmd@@@#1(#2,#3){
    \@ifnextchar[{\sseqnewcmd@@@@#1(#2,#3)}{\sseqnewcmd@@@@#1(#2,#3)[0]}%]
}
\bgroup\lccode`\*=`\#\lccode`C=`C\lowercase{\egroup
    \long\def\sseqnewcmd@@@@#1(#2,#3)[#4]#5{%
        \ifnum#4>6 \sseq@error{Commands defined using '\string\sseqnewcmd' or '\string\sseqnewgroup' can take at most six arguments}\fi
        \edef\helpera{\@xp\@nx\csname \sseq@macroname#1@\endcsname}%
        \edef\helperb{\@xp\@nx\csname \sseq@macroname#1@@\endcsname}%
        \xdef#1{\@nx\@ifnextchar[{\@xp\@nx\helpera}{\@xp\@nx\helpera[]}}%]
        \@xp\xdef\helpera[##1](##2,##3){\@xp\@nx\helperb{##1}{##2}{##3}}%
        \def\temp##1##2##3##4##5##6{#5}%
        \sseq@temptoks\@xp{\temp\ppfour\ppfive\ppsix\ppseven\ppeight\ppnine}%
        \bgroup
            \aftergroup\@xp\aftergroup\edef\aftergroup\helperb\aftergroup##\aftergroup1\aftergroup##\aftergroup2\aftergroup##\aftergroup3%
            \ifnum#4>0\relax
                \sseq@tempcount=0\relax
                \sseq@tempcountb=3\relax
                \loop
                    \advance\sseq@tempcount1\relax\advance\sseq@tempcountb1\relax
                    \aftergroup####\@xp\aftergroup\the\sseq@tempcountb
                \ifnum\sseq@tempcount<#4\repeat
            \fi
            \aftergroup{%
                \aftergroup\the\aftergroup\sseq@temptoks
            \aftergroup}%
        \egroup
%
        \bgroup
        \def\etb@ifscanable##1{\@firstoftwo}% This hack might cause me grief later, but it prevents whitespace woes
        \@xp\sseq@patchrepeat\helperb{\options}{*1}
        \@xp\sseq@patchrepeat\helperb{#2}{*2}%
        \@xp\sseq@patchrepeat\helperb{#3}{*3}%
        \@xp\sseq@patchrepeat\helperb{\ppfour}{*4}%
        \@xp\sseq@patchrepeat\helperb{\ppfive}{*5}%
        \@xp\sseq@patchrepeat\helperb{\ppsix}{*6}%
        \@xp\sseq@patchrepeat\helperb{\ppseven}{*7}%
        \@xp\sseq@patchrepeat\helperb{\ppeight}{*8}%
        \@xp\sseq@patchrepeat\helperb{\ppnine}{*9}%
        \sseq@eval{\global\let\@xp\@nx\helperb\@xp\@nx\helperb}
        \egroup
    }
}
\def\sseq@patchrepeat#1#2#3{\patchcmd#1{#2}{#3}{\sseq@patchrepeat#1{#2}{#3}}{}}

%%% Load/store
% These are attributes that come with a given spectral sequence (by name)
% All of these values are loaded at the beginning of sseqpage (and of sseqdata if an existing sseq is being modified).
% They are then stored together at the end of sseqdata (and of sseqpage if "keep changes" option is present).
\def\sseq@storelist{}
\def\sseq@storelist@setdefaults{}
\def\sseq@addtostorelist#1#2{%
    \sseq@g@addto@macro\sseq@storelist{\\#1}%
    \sseq@x@addto@macro\sseq@storelist@setdefaults{\global\let\@nx#1\@xp\@nx\csname \sseq@macroname#1@default\endcsname}%
    \@xp\gdef\csname\sseq@macroname#1@default\endcsname{#2}%
}
\def\sseq@addiftostorelist#1{\sseq@addiftostorelistopt{#1}{false}}
\def\sseq@addiftostorelist@truedefault#1{\sseq@addiftostorelistopt{#1}{true}}
\def\sseq@addiftostorelistopt#1#2{%
    \@xp\newif\csname ifsseq@#1\endcsname
    \sseq@g@addto@macro\sseq@storelist{\sseq@storelistif{#1}}
    \sseq@x@addto@macro\sseq@storelist@setdefaults{\@xp\@nx\csname sseq@#1@default\endcsname}%
    \@xp\xdef\csname sseq@#1@default\endcsname{\global\@xp\@nx\csname sseq@#1#2\endcsname}
}

% transfer data about the current spectral sequence between \<command> and \<command><sseqname>
\def\sseq@storelist@store#1{\edef\sseq@temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\sseq@temp}
\def\sseq@storelist@get#1{\edef\sseq@temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\sseq@temp}

\def\sseq@storelistif@store#1{%
    \@xp\edef\csname sseq@storeif@#1\endcsname{\csname ifsseq@#1\endcsname \@xp\@nx\csname sseq@#1true\endcsname\else\@xp\@nx\csname sseq@#1false\endcsname\fi}%
    \@xp\sseq@storelist@store\csname sseq@storeif@#1\endcsname
}
\def\sseq@storelistif@get#1{
    \@xp\sseq@storelist@get\csname sseq@storeif@#1\endcsname
    \csname sseq@storeif@#1\endcsname
}

\def\sseq@storecmds{\let\\\sseq@storelist@store\let\sseq@storelistif\sseq@storelistif@store\sseq@storelist}
\def\sseq@getcmds{\let\\\sseq@storelist@get\let\sseq@storelistif\sseq@storelistif@get\sseq@storelist}

%%% New "poor man's OOP" Load/Store
% Directly stores things into commands that are annotated with the name of the spectral sequence.
% I use this primarily for commands that won't necessarily exist for every spectral sequence
% for instance because it has the description of a particular class or differential as part of its name
\def\sseq@obj@fullname#1{sseq.\sseq@thename.#1}
\def\sseq@obj#1{\csname sseq.\sseq@thename.#1\endcsname}
\def\sseq@obj@gdef#1{\@xptwo\gdef\sseq@obj{#1}}
\def\sseq@obj@xdef#1{\@xptwo\xdef\sseq@obj{#1}}
\def\sseq@obj@xodef#1{\@xp\gdef\csname \sseq@obj@fullname{#1}\@xp\endcsname\@xp}
\def\sseq@obj@let#1{\@xptwo\let\sseq@obj{#1}}
\def\sseq@obj@gletcsname#1#2{\global\@xp\let\csname\sseq@obj@fullname{#1}\@xp\endcsname\csname#2\endcsname}
\def\sseq@obj@gletobj#1#2{\global\@xp\let\csname\sseq@obj@fullname{#1}\@xp\endcsname\csname\sseq@obj@fullname{#1}\endcsname}
\def\sseq@obj@undef#1{\@xptwo\let\sseq@obj{#1}\relax}
\def\sseq@obj@show#1{\@xptwo\show\sseq@obj{#1}}
\def\sseq@obj@ifundef#1#2#3{\@ifundefined{\sseq@obj@fullname{#1}}{#2}{#3}}
\def\sseq@obj@inc#1{\bgroup\sseq@tempcount\sseq@obj{#1}\relax\advance\sseq@tempcount1\relax\sseq@obj@xdef{#1}{\the\sseq@tempcount}\egroup}
\def\sseq@obj@gaddto#1#2{\@xptwo\sseq@g@addto@macro\sseq@obj{#1}{#2}} % TODO: either gaddto or g@addto
\def\sseq@obj@xaddto#1#2{\@xptwo\sseq@x@addto@macro\sseq@obj{#1}{#2}}
\def\sseq@obj@xoaddto#1{\@xp\sseq@g@addto@macro\csname \sseq@obj@fullname{#1}\@xp\endcsname\@xp}
\def\sseq@obj@gaddtolist#1#2{\@xptwo\sseq@g@addto@macro\sseq@obj{#1}{\\{#2}}}
\def\sseq@obj@xaddtolist#1#2{\@xptwo\sseq@x@addto@macro\sseq@obj{#1}{\@nx\\{#2}}}
\def\sseq@obj@map#1#2{\def\\##1{#2}\sseq@obj{#1}}

\def\sseq@obj@new#1{
    \sseq@obj@xdef{#1.page}{\sseq@infinity}
}

\def\sseq@obj@ifchanged#1#2#3{\sseq@obj@ifundef{#1.changed}{#3}{#2}}
\def\sseq@obj@changedtrue#1{\sseq@obj@gdef{#1.changed}{}}
\def\sseq@obj@changedfalse#1{\sseq@obj@undef{#1.changed}}

\def\sseq@cleanup@obj#1{
    \ifsseq@keepchanges\else
        \sseq@obj@ifchanged{#1}{}{
            \sseq@obj@changedtrue{#1}
            \sseq@temptoks\@xpthree{\sseq@obj{#1}}
            \sseq@x@addto@macro\sseq@pagecleanup{
                \@nx\sseq@obj@gdef{#1}{\the\sseq@temptoks}
                \@nx\sseq@obj@changedfalse{#1}
            }
        }
    \fi
}

%%% add to macro commands
\def\sseq@d@addto@macro#1#2{\@xp\def\@xp#1\@xp{#1#2}}
\def\sseq@e@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\sseq@eval{\pgfutil@toks@{\the\pgfutil@toks@#2}}\@xp\endgroup\@xp\def\@xp#1\@xp{\the\pgfutil@toks@}} % let #2 be expanded
\def\sseq@g@addto@macro#1#2{\@xp\gdef\@xp#1\@xp{#1#2}}
\def\sseq@x@addto@macro#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup} % let #2 be expanded

%% Saved paths, temporary saved paths, background saved paths
% \sseq@savedpaths@whatever is redefined to be \sseq@savedpaths@whatever@standard or \sseq@savedpaths@whatever@temporary depending on context
% This simplifies the code a lot because I don't have to check again where I should put things.
\sseq@addtostorelist\sseq@savedpaths{}
\def\sseq@tempsavedpaths{}
\def\sseq@savedpaths@addclass@standard#1{\sseq@x@addto@macro\sseq@savedpaths{\@nx\sseq@class@draw@ifpage{#1}}}
\def\sseq@savedpaths@adddifferential@standard#1{\sseq@x@addto@macro\sseq@savedpaths{\@nx\sseq@differential@draw@ifpage{#1}}}
\def\sseq@savedpaths@addstructline@standard#1{\sseq@x@addto@macro\sseq@savedpaths{\@nx\sseq@structline@draw@ifpage{#1}}}
\def\sseq@savedpaths@add@standard{\sseq@g@addto@macro\sseq@savedpaths}
\def\sseq@savedpaths@xadd@standard{\sseq@x@addto@macro\sseq@savedpaths}
\def\sseq@savedpaths@show@standard{\show\sseq@savedpaths}
\def\sseq@scope@savedpaths@add@standard#1{\sseq@savedpaths@add@standard{#1}\sseq@savedpaths@add@background{#1}}

\def\sseq@savedpaths@addclass@temporary#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@class@draw@ifpage{#1}}}
\def\sseq@savedpaths@adddifferential@temporary#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@differential@draw@ifpage{#1}}}
\def\sseq@savedpaths@addstructline@temporary#1{\sseq@x@addto@macro\sseq@tempsavedpaths{\@nx\sseq@structline@draw@ifpage{#1}}}
\def\sseq@savedpaths@add@temporary{\sseq@g@addto@macro\sseq@tempsavedpaths}
\def\sseq@savedpaths@xadd@temporary{\sseq@x@addto@macro\sseq@tempsavedpaths}
\def\sseq@savedpaths@show@temporary{\show\sseq@tempsavedpaths}
\def\sseq@scope@savedpaths@add@temporary#1{\sseq@savedpaths@add@temporary{#1}\sseq@savedpaths@add@background{#1}}


\def\sseq@savedpaths@addclass@background#1{\sseq@error@internal{\@nx\sseq@savedpaths@addclass occurred in background mode}}
\def\sseq@savedpaths@adddifferential@background#1{\sseq@error@internal{\@nx\sseq@savedpaths@adddifferential occurred in background mode}}
\def\sseq@savedpaths@addstructline@background#1{\sseq@error@internal{\@nx\sseq@savedpaths@addstructline occurred in background mode}}
\def\sseq@savedpaths@add@background{\sseq@g@addto@macro\sseq@savedbackgroundpaths}
\def\sseq@savedpaths@xadd@background{\sseq@x@addto@macro\sseq@savedbackgroundpaths}

\def\sseq@setsavedpaths#1{
    \@xp\let\@xp\sseq@savedpaths@addclass       \csname sseq@savedpaths@addclass@#1\endcsname
    \@xp\let\@xp\sseq@savedpaths@adddifferential\csname sseq@savedpaths@adddifferential@#1\endcsname
    \@xp\let\@xp\sseq@savedpaths@addstructline  \csname sseq@savedpaths@addstructline@#1\endcsname
    \@xp\let\@xp\sseq@savedpaths@add            \csname sseq@savedpaths@add@#1\endcsname
    \@xp\let\@xp\sseq@savedpaths@xadd            \csname sseq@savedpaths@xadd@#1\endcsname
    \pgfutil@ifundefined{sseq@scope@savedpaths@add@#1}{}{
        \@xp\let\@xp\sseq@savedpaths@show        \csname sseq@savedpaths@show@#1\endcsname
        \@xp\let\@xp\sseq@scope@savedpaths@add   \csname sseq@scope@savedpaths@add@#1\endcsname
    }
}

\def\sseq@usesavedpaths{
    \sseq@savedpaths
    \sseq@clearchangestyles
    \sseq@tempsavedpaths
    \gdef\sseq@tempsavedpaths{}
}

%% Options
\def\sseq@savedoptioncode{}
\def\sseq@d@addto@options{\sseq@d@addto@macro\sseq@savedoptioncode}
\def\sseq@e@addto@options{\sseq@e@addto@macro\sseq@savedoptioncode}
\def\sseq@g@addto@options{\sseq@g@addto@macro\sseq@savedoptioncode}
\def\sseq@x@addto@options{\sseq@x@addto@macro\sseq@savedoptioncode}

%%%% Tikz modifications

%%% Context -- make sure \foreach doesn't break when used with sseqpages commands that defer evaluation
% TODO: robustify by copying pgffor wholesale?
\def\sseq@savedcontext{}
\def\sseq@addtocontext#1{#1\sseq@for@checkoptions{#1}\sseq@for@checkoptions@add{#1}\sseq@d@addto@macro\sseq@savedcontext{#1}}

\def\sseq@for@makeletters#1{\sseq@for@makeletters@#1.}
\def\sseq@for@makeletters@#1{\ifx#1.\else\@xp\def\csname sseq@for@#1@isletter\endcsname{}\@xp\sseq@for@makeletters@\fi}
\sseq@for@makeletters{abcdefghijklmnopqrstuvwxyz}
\def\sseq@for@ifstartswithletter#1#2#3{\lowercase{\@ifundefined{sseq@for@\sseq@firstchar#1\@nil @isletter}{#3}{#2}}}
\def\sseq@firstchar#1#2\@nil{#1}

% This macro checks whether any of the macros in the current context are used in its argument
% If they are, add them to the savedpaths before anything that uses them.
% By default, \sseq@for@checkoptions is a no-op because there is no context. If \foreach or \addtocontext is used, it is changed to actually do something
\let\sseq@for@checkoptions\@gobble
\bgroup\lccode`!=`\\\lowercase{\egroup
\gdef\sseq@for@checkoptions@active#1{% active version
    % First check whether there are any macros in the option list at all
    \def\next##1!##2\sseq@nil{
        \ifx\sseq@nil##2\sseq@nil % No macros present
            \@xp\@gobble % So don't do anything
        \else
            \@xp\sseq@for@checkoptions@active@ % Check whether any of the context macros are here.
        \fi
    }
    \def\sseq@temp{#1} %Using \meaning we turn all \'s into catcode other, so we can check whether any macros are present
    \sseq@eval{\@nx\next\meaning\sseq@temp!\@nx\sseq@nil}{#1}
}
}

\def\sseq@for@checkoptions@active@#1{
    \def\\{\sseq@for@checkoption{#1}}
    \def\sseq@tempii{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@tempcount\endcsname{}}
    \sseq@context@tempcount=0\relax
    \loop %
        \advance\sseq@context@tempcount1\relax
        \@xptwo\sseq@tempii
        \csname sseq@for@savedtoks\the\sseq@context@tempcount\endcsname
    \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
}


\def\sseq@for@checkoption#1#2#3{
    \def\next##1#2##2\sseq@nil{
        \ifx\sseq@nil##2\sseq@nil %If true, the macro #2 was not in the option text #1 so put #2 back in the list of things to check for in the future
            \@xp\sseq@g@addto@macro\csname sseq@for@savedtoks\the\sseq@context@tempcount\endcsname{\\#2{#3}}
        \else % #2 was in #1 so add the definition of #2 as #3 to the savedpaths and savedbackgroundpaths
            \sseq@for@checkoptions@add{\def#2{#3}}
        \fi
    }
    \bgroup % We change the catcode of \{ into 12 and use \scantokens to prevent macros from being hidden by braces
    \catcode`\{=12\relax\catcode`\}=12\relax\makeatletter
    \scantokens{\@xp\egroup\next#1#2\sseq@nil}
}

% Put together an error message that says which stage in the for loop caused the error
\def\sseq@builderrorinfo@foreach{
    \let\sseq@errorinfo\sseq@errorinfo@foreach % The starting message, which says we're in a for each loop and these are the variables involved
    % Now print each of the current saved values
    \let\\\sseq@errorinfo@foreach@slsl % Iterator to print out "variable = value"
    \sseq@context@tempcount0\relax
    \loop % Work through each layer of context / foreach loop
        \advance\sseq@context@tempcount1\relax
        \csname sseq@for@savedtoks@error\the\sseq@context@tempcount\endcsname
    \ifnum\sseq@context@tempcount<\sseq@context@depth\repeat %
}

\def\sseq@errorinfo@foreach@slsl#1#2{% No semicolon before the first variable
    \sseq@g@addto@macro\sseq@errorinfo{ \@nx#1= #2}\let\\\sseq@errorinfo@foreach@slsl@ii
}
\def\sseq@errorinfo@foreach@slsl@ii#1#2{
    \sseq@g@addto@macro\sseq@errorinfo{; \@nx#1= #2}
}

\def\sseq@pgffor@atbeginforeach{%
    \begingroup %
    \let\sseq@builderrorinfo\sseq@builderrorinfo@foreach % Install foreach error annotations
    \let\errmessage\sseq@errmessage
    \let\sseq@error\sseq@errorwithinfo
    \let\sseq@for@checkoptions\sseq@for@checkoptions@active % Check options to see whether we need to put the assignment into the savedpaths
    \advance\sseq@context@depth1\relax
    \sseq@for@clearsavedtoks % empty the saved variables at this level
}

\def\sseq@for@clearsavedtoks{\@xp\gdef\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{}}
\def\sseq@for@savemacro#1#2{\@xp\sseq@g@addto@macro\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{\\#1{#2}}}
\def\sseq@for@esavemacro#1#2{\@xp\sseq@x@addto@macro\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname{\@nx\\\@nx#1{#2}}}
\def\sseq@for@savemacros{\@ifnextchar\def{\sseq@for@savemacros@}{}}
\def\sseq@for@savemacros@#1#2#3{\sseq@for@savemacro#2{#3}\@ifnextchar\def{\sseq@for@savemacros@}{}}
\def\sseq@for@savedpaths@add#1{
    \sseq@savedpaths@add@background{#1}
    \ifsseq@keepchanges
        \sseq@savedpaths@add@standard{#1}
    \else
        \sseq@savedpaths@add@temporary{#1}
    \fi
}
\let\sseq@for@checkoptions@add\sseq@for@savedpaths@add

%% Patch \foreach
% Perform a deep copy
\def\sseq@pgffor@@vars@opt[#1]{\pgfkeys{/sseqpages/foreach/.cd,#1}\pgffor@vars}
\let\sseq@pgffor@doloop\pgffor@doloop
\let\sseq@pgffor@invokebody\pgffor@invokebody
\let\sseq@pgffor@assign@@@parse\pgffor@assign@@@parse
\let\sseq@pgffor@count@@parse\pgffor@count@@parse
\let\sseq@pgffor@remember@@@parse\pgffor@remember@@@parse
\let\sseq@pgffor@remember@@@parse@old\pgffor@remember@@@parse@old
\let\sseq@pgffor@multiassignfinal\pgffor@multiassignfinal
\let\sseq@pgffor@default@endgroup\pgffor@default@endgroup
\let\sseq@pgffor@atendforeach\pgffor@atendforeach

\def\sseq@patchfor{%
    \let\pgffor@@vars@opt\sseq@pgffor@@vars@opt
    \let\pgffor@atbeginforeach\sseq@pgffor@atbeginforeach
    \let\pgffor@invokebody\sseq@pgffor@invokebody
    \let\pgffor@doloop\sseq@pgffor@doloop
    \let\pgffor@assign@@@parse\sseq@pgffor@assign@@@parse
    \let\pgffor@count@@parse\sseq@pgffor@count@@parse
    \let\pgffor@remember@@@parse\sseq@pgffor@remember@@@parse
    \let\pgffor@remember@@@parse@old\sseq@pgffor@remember@@@parse@old
    \let\pgffor@multiassignfinal\sseq@pgffor@multiassignfinal
    \let\pgffor@default@endgroup\sseq@pgffor@default@endgroup
    \let\pgffor@atendforeach\sseq@pgffor@atendforeach
}

%% Now modify all of the commands to tell sseqpages about the variable values
\def\sseq@error@fornopatch{\sseq@error@internal{failed to patch \string\foreach}}
\patchcmd\sseq@pgffor@invokebody % store setting after
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@var\expandafter{\pgffor@value}%
        \@xp\sseq@for@esavemacro\pgffor@var{\pgffor@var}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@invokebody
    {\expandafter\expandafter\expandafter\pgffor@reset@hooks\expandafter\pgffor@beginhook\expandafter\pgffor@body\pgffor@endhook}
    {\@xp\let\csname sseq@for@savedtoks@error\the\sseq@context@depth\@xp\endcsname\csname sseq@for@savedtoks\the\sseq@context@depth\endcsname
    \expandafter\expandafter\expandafter\pgffor@reset@hooks\expandafter\pgffor@beginhook\expandafter\pgffor@body\pgffor@endhook}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@doloop % store setting before
    {\ifx\pgffor@assign@before@code}
    {\@xp\sseq@for@esavemacro\pgffor@var{\pgffor@var}%
     \ifx\pgffor@assign@before@code}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@invokebody % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@doloop % reset stored definitions before
    {\ifx\pgffor@assign@after@code}
    {\sseq@for@clearsavedtoks%
     \ifx\pgffor@assign@after@code}
    {}{\sseq@error@fornopatch}

\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#2{#4}\sseq@for@savemacro#2{#4}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@esavemacro#1{\pgfmathresult}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@once@code}{\def#1{#2}\sseq@for@savemacro#1{#2}}}
    {}{\sseq@error@fornopatch}


\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\pgfmathparse{#2}\let#1=\pgfmathresult\sseq@for@esavemacro#1{\pgfmathresult}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@assign@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@before@code}{\def#1{#2}\sseq@for@savemacro#1{#2}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@count@@parse
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult}}
    {\pgfutil@append@tomacro\pgffor@assign@before@code{\pgfmathparse{int(#1+1)}\let#1=\pgfmathresult\sseq@for@esavemacro#1{\pgfmathresult}}}
    {}{\sseq@error@fornopatch}

\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{\the#2}\sseq@for@esavemacro#1{\the#2}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@remember@@@parse
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\expandafter\def\expandafter#1\expandafter{#2}\@xp\sseq@for@savemacro\@xp#1\@xp{#2}}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@remember@@@parse@old
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}}}
    {\pgfutil@append@tomacro{\pgffor@assign@after@code}{\edef#2{#1}\sseq@for@esavemacro#2{#1}}}
    {}{\sseq@error@fornopatch}

\patchcmd\sseq@pgffor@multiassignfinal
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}}
    {\expandafter\expandafter\expandafter\def\expandafter\pgffor@currentvar\expandafter{\pgffor@temp}%
        \@xp\sseq@for@esavemacro\pgffor@currentvar{\pgffor@temp}}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@default@endgroup
    {\else\pgffor@remember@once@expanded}
    {\else\pgffor@remember@once@expanded %
        \@xp\sseq@for@savemacros\pgffor@remember@once@expanded}
    {}{\sseq@error@fornopatch}
\patchcmd\sseq@pgffor@atendforeach
    {\else\pgffor@remember@expanded}
    {\else\pgffor@remember@expanded %
        \@xp\sseq@for@savemacros\pgffor@remember@expanded}
    {}{\sseq@error@fornopatch}
\pretocmd\sseq@pgffor@atendforeach{\sseq@for@clearsavedtoks}{}{\sseq@error@fornopatch}

% TODO: delete this
\ifnum\sseq@errormode>1\relax
    \let\sseq@for@checkoptions@active\@gobble
    \apptocmd\sseq@for@savemacro{\sseq@context@set#1{#2}}{}{}
    \apptocmd\sseq@for@esavemacro{\sseq@eval{\@nx\sseq@for@savedpaths@add{\@nx\sseq@context@set\@nx#1{#2}}}}{}{}
    \apptocmd\sseq@pgffor@atbeginforeach{%
        \sseq@for@savedpaths@add{\bgroup}
        \ifnum\sseq@context@depth=1\relax\sseq@for@savedpaths@add{\def\sseq@errorinfo{in the \string\foreach\space block that ends on line \the\inputlineno, with variable values}}\fi
    }{}{}
    \pretocmd\sseq@pgffor@atendforeach{\sseq@for@savedpaths@add{\egroup}}{}{}
    \def\sseq@context@set#1#2{\def#1{#2}\sseq@temptoks\@xp{\sseq@errorinfo: \@nx#1=}\edef\sseq@errorinfo{\the\sseq@temptoks#2}\let\sseq@context@set\sseq@context@set@rest}
    \def\sseq@context@set@rest#1#2{\def#1{#2}\sseq@temptoks\@xp{\sseq@errorinfo; \@nx#1=}\edef\sseq@errorinfo{\the\sseq@temptoks#2}}
\fi



%%%% Internal utilities
\def\sseq@iffullcoord(#1){\@xp\sseq@iffullcoord@#1,\sseq@nil}
\def\sseq@iffullcoord@#1,#2,#3\sseq@nil{\ifx\sseq@nil#3\sseq@nil\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}

% Only works for full coordinates. Used for error checking in \replaceclass and \d.
\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1,#2,#3){%
    \sseq@obj@ifundef{partcoord.(#1,#2).numnodes}%
        {\@firstoftwo}%
        {\ifnum#3<\sseq@obj{partcoord.(#1,#2).numnodespp}\relax\@xp\@secondoftwo\else\@xp\@firstoftwo\fi}%
}

\def\sseq@ifdead#1{\ifnum\sseq@obj{class.#1[\sseq@obj{class.#1.num}].page}<\sseq@infinity\relax \@xp\@firstoftwo\else\@xp\@secondoftwo\fi}
\def\sseq@getdeathpage#1{\sseq@obj{class.#1[\sseq@obj{class.#1.num}].page}}

%% \sseq@whichclass -- Find out which class an index indicates
% if the index is positive, just check that it is within bounds
% if the index is negative, return (number of nodes at (x,y)) - index + 1
% if index is empty, return 1 (should it be -1?)
%
% #1 -- output variable
% #2 -- x coordinate
% #3 -- y coordinate
% #4 -- index
% #5 -- calling command (for error messages)
\def\sseq@whichclass#1#2#3#4#5{%
    \edef#1{#4}%
    \ifx#1\pgfutil@empty % If no index is provided, just use 1 TODO: Maybe we should use -1?
        \edef#1{1}%
    \else
        \ifnum#4<0% Negative case -- why this command exists
            \sseq@obj@ifundef{partcoord.(#2,#3).numnodes}{
                \sseq@error{Error: negative index #4 provided for #5 but no classes yet exist in #5 position (#2,#3).
                    Negative indices count from the most recent class in the given position; in particular, there must be at least one existing class}{}
            }{%
                \sseq@tempcount=\sseq@obj{partcoord.(#2,#3).numnodes}
                \advance\sseq@tempcount#4\relax
                \advance\sseq@tempcount1\relax
                \ifnum\sseq@tempcount<1\relax
                    \sseq@error{Error: index #4 provided for the #5 is out of bounds -- fewer than \@gobble#4 classes exist at #5 position (#2,#3)}{}
                \fi
                \edef#1{\the\sseq@tempcount}%
            }%
        \fi
    \fi
}

%% Parsers
% These are very internal commands. They work. I should probably never touch or look at them again.

%% \sseq@parsecoords:
% #1 -- output command
% #2 -- coordinate of the form "(x,y)" or "x,y" or "(x,y,n)" or "x,y,n"
% Defines #1 to be #2 after applying \pgfmathparse to x and y, and then replacing numbers of the form n.0 with n for n an integer
\def\sseq@parsecoords#1#2{\pgfmathparse{#2}\edef\sseq@temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\sseq@temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.0\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.0#2\sseq@nil{#1\ifx&#2&\else\@xp\ifx\sseq@getfirstchar#2\sseq@nil.\else .0\sseq@uptopt#2\sseq@nil\fi\fi}
\def\sseq@uptopt#1.#2\sseq@nil{#1}

%% \sseq@parsecommas:
% (#1) -- a comma separated list of up to four arguments. Blank or off-the-end entries are considered to be absent.
% The value of the #1th argument is stored in \csname sseq@arg#1\endcsname.
% This command is primarily to set up the weird syntax of \d, but it gets used in some other places because it already existed.
\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}
\def\sseq@parsecommas@#1#2,{%
    \advance\sseq@commacount1\relax
    \ifnum\sseq@commacount<4 % This causes an error without a space I think?
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}
\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}
\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1\relax
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

% These are for accessing the output of \sseq@parsecommas
% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}
\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}{}}


%%%%%%% Set up keys
\def\sseqset#1{\pgfqkeys{/sseqpages/global/default}{#1}}

%% TODO: Verify starting values
\let\sseq@pgfkeys@case@one@save\pgfkeys@case@one
\let\sseq@pgfkeys@case@two@extern@save\pgfkeys@case@two@extern
\def\sseq@pgfkeys@case@one@store{%
    \pgfkeysifdefined{\pgfkeyscurrentkey/.@cmd}{
        \pgfkeysgetvalue{\pgfkeyscurrentkey/.@cmd}{\pgfkeys@code}%
        \sseq@temptoks\@xptwo{\@xp\pgfkeys@code\pgfkeyscurrentvalue\pgfeov}
        \@xp\sseq@keys@addtooptions@checkalso\@xp{\the\sseq@temptoks}
    }{\pgfkeys@case@two}%
}
\def\sseq@pgfkeys@case@two@extern@store{%
  \ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text%
    \pgfkeysvalueof{\pgfkeyscurrentkey}%
  \else%
    \sseq@temptoks\@xp{\pgfkeyscurrentvalue}
    \sseq@e@addto@options{\@nx\pgfkeyssetvalue{\pgfkeyscurrentkey}{\the\sseq@temptoks}}
  \fi%
}

%%
\def\sseqset@inprogress{\pgfqkeys{/sseqpages}}
\def\sseq@set{\pgfqkeys{/sseqpages}}
\def\sseq@passoptionto#1{\sseq@temptoks\@xp{\pgfkeyscurrentvalue}\sseq@eval{\@nx\pgfqkeys{#1}{\pgfkeyscurrentname={\the\sseq@temptoks}}}}

\def\sseq@keys@lastpart#1{\sseq@eval{\@nx\sseq@keys@lastpart@#1/\@nx\sseq@nil}}
\def\sseq@keys@lastpart@#1/{\@ifnextchar\sseq@nil{\edef\sseq@temp{#1}\@gobble}{\sseq@keys@lastpart@}}

\def\sseq@keys@try@addtooptions#1{
    \ifsseq@tempif\else
        \pgfkeysifdefined{#1/\pgfkeyscurrentname/.@cmd}{
            \sseq@tempiftrue
            \pgfkeysgetvalue{#1/\pgfkeyscurrentname/.@cmd}{\pgfkeys@code}%
            \sseq@temptoks\@xptwo{\@xp\pgfkeys@code\pgfkeyscurrentvalue\pgfeov}
            \@xp\sseq@keys@addtooptions@checkalso\@xp{\the\sseq@temptoks}
        }{
            \pgfkeysifdefined{#1/\pgfkeyscurrentname}{
                \sseq@tempiftrue
                \sseq@temptoks\@xp{\pgfkeyscurrentvalue}
                \sseq@e@addto@options{\@nx\pgfkeyssetvalue{#1/\pgfkeyscurrentname}{\the\sseq@temptoks}}
            }{}
        }
    \fi
}

\def\sseq@keys@addtooptions@checkalso#1{%
    \let\pgfkeys@case@one\sseq@pgfkeys@case@one@store
    \let\pgfkeys@case@two@extern\sseq@pgfkeys@case@two@extern@store
    \sseq@keys@addtooptions@checkalso@#1\pgfkeysalso\sseq@nil
}
\def\sseq@keys@addtooptions@checkalso@#1\pgfkeysalso#2{%
    \sseq@d@addto@options{#1}
    \ifx#2\sseq@nil
        \let\pgfkeys@case@one\sseq@pgfkeys@case@one@save
        \let\pgfkeys@case@two@extern\sseq@pgfkeys@case@two@extern@save
    \else
        \pgfkeysalso{#2}
        \@xp\sseq@keys@addtooptions@checkalso@
    \fi
}
\let\sseq@pgfkeysalso@leavealone\pgfkeysalso

\def\sseq@keys@unknown#1{%
    \let\tikz@key\pgfkeyscurrentname
    \sseq@tempiffalse
    \sseq@keys@try@addtooptions{/tikz}
    \sseq@keys@try@addtooptions{/pgf}
    \ifsseq@tempif\else
        \@xp\pgfutil@in@\@xp!\@xp{\tikz@key}%
        \ifpgfutil@in@%
          % this is a color!
          \@xp\sseq@d@addto@options\@xp{\@xp\tikz@addoption\@xp{\@xp\tikz@compat@color@set\@xp{\tikz@key}}}%
          \sseq@e@addto@options{\def\@nx\tikz@textcolor{\tikz@key}}%
        \else%
          \pgfutil@doifcolorelse{\tikz@key}
          {%
              \@xp\sseq@d@addto@options\@xp{\@xp\tikz@addoption\@xp{\@xp\tikz@compat@color@set\@xp{\tikz@key}}}%
              \sseq@e@addto@options{\def\@nx\tikz@textcolor{\tikz@key}}%
          }%
          {%
            % Ok, second chance: This might be an arrow specification:
            \@xp\pgfutil@in@\@xp-\@xp{\tikz@key}%
            \ifpgfutil@in@%
              % Ah, an arrow spec!
              \@xp\sseq@d@addto@options\@xp{\@xp\tikz@processarrows\@xp{\tikz@key}}%
            \else%
              % Ok, third chance: A shape!
              \@xp\ifx\csname pgf@sh@s@\tikz@key\endcsname\relax%
                    \sseq@error{I do not know the key \pgfkeyscurrentname}% TODO: improve error message
              \else%
                \sseq@e@addto@options{\def\@nx\tikz@shape{\tikz@key}}%
              \fi%
            \fi%
          }%
      \fi%
    \fi
}

\def\sseq@options@use#1{#1}
\def\sseq@options@normalmode{\let\sseq@options@firstpass\sseq@options@use\let\sseq@options@secondpass\sseq@d@addto@options}
\def\sseq@options@firstpassmode{\let\sseq@options@firstpass\sseq@options@use\let\sseq@options@secondpass\@gobble}
\def\sseq@options@secondpassmode{\let\sseq@options@firstpass\@gobble\let\sseq@options@secondpass\sseq@options@use}
\def\sseq@options@bothpassmode{\let\sseq@options@firstpass\sseq@options@use\let\sseq@options@secondpass\sseq@options@use}
\sseq@options@normalmode

\def\sseq@pgfkeysdocommand#1#2{
    \sseq@tempiffalse
    \sseq@pgfkeysdocommand@try{/tikz/#1}{#2}
    \sseq@pgfkeysdocommand@try{/pgf/#1}{#2}
    \ifsseq@tempif\else\sseq@error@internal{\@nx\sseq@pgfkeysdocommand{#1}{#2} failed}\fi
}

\def\sseq@pgfkeysdocommand@try#1#2{
    \ifsseq@tempif\else
        \pgfkeysifdefined{#1/.@cmd}{
            \sseq@tempiftrue
            \pgfkeysgetvalue{#1/.@cmd}{\pgfkeys@code}%
            \pgfkeys@code#2\pgfeov
        }{
            \pgfkeysifdefined{#1}{
                \sseq@tempiftrue
                \pgfkeyssetvalue{#1}{#2}
            }{}
        }
    \fi
}

\pgfqkeys{/handlers}{
    .sseq @ first pass code/.code={
        \pgfkeysalso{\pgfkeyscurrentpath/.code={\sseq@options@firstpass{#1}}}
    },
    .sseq @ first pass append code/.code={
        \pgfkeysalso{\pgfkeyscurrentpath/.append code={\sseq@options@firstpass{#1}}}
    },
    .sseq @ second pass code/.code={
        \pgfkeysalso{\pgfkeyscurrentpath/.code={\sseq@options@secondpass{#1}}}
    },
    .sseq @ second pass append code/.code={
        \pgfkeysalso{\pgfkeyscurrentpath/.append code={\sseq@options@secondpass{#1}}}
    },
    .sseq @ second pass store in/.code={
        \pgfkeysalso{\pgfkeyscurrentpath/.code={\sseq@options@secondpass{\def#1{##1}}}}
    },
    .sseq @ code/.code 2 args={
        \pgfkeysalso{\pgfkeyscurrentpath/.code={\sseq@options@firstpass{#1}}}
        \pgfkeysalso{\pgfkeyscurrentpath/.append code={\sseq@options@secondpass{#1}}}
    }
}

\pgfkeys{%
    /sseqpages/.is family,
    /sseqpages/.unknown/.code={\sseq@keys@unknown{#1}},
    /sseqpages/unknown/.unknown/.code={\sseq@keys@unknown{#1}},% Force unknown key handling
    % \sseq@currentoptionpath is set to \sseq@thename in \sseqdata, then "temp" in \sseqpage
    /sseqpages/global/.unknown/.code={%
        \let\sseq@tempa\pgfkeyscurrentname
        \let\sseq@tempb\pgfkeyscurrentvalue
        \pgfkeysifdefined{/tikz/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/tikz/\pgfkeyscurrentname}{}{%
          %  \pgfkeysifdefined{/sseqpages/\pgfkeyscurrentname/.@cmd}{}{\pgfkeysifdefined{/sseqpages/\pgfkeyscurrentname}{}{% TODO: Does this belong here?
                \sseq@error{Undefined global option '\pgfkeyscurrentname\@xp\ifx\pgfkeyscurrentvalue\pgfkeysnovalue\else=\pgfkeyscurrentvalue\fi'}%
          %  }}%
        }}%
        \pgfkeysalso{{\sseq@currentoptionpath} options/.append style/.expand twice={\@xp\sseq@tempa\@xp=\@xp{\sseq@tempb}}}%
    },
    /sseqpages/global/default/.unknown/.code={%
        \let\sseq@currentoptionpath@save\sseq@currentoptionpath
        \def\sseq@currentoptionpath{default}%
        \sseq@passoptionto{/sseqpages/global}
        \let\sseq@currentoptionpath\sseq@currentoptionpath@save
    },
    /sseqpages/global/{default} options/.code={},
    /sseqpages/global/name only/.unknown/.code={},
%
    /sseqpages/class/.unknown/.code={%
        \expandafter\ifx\csname pgf@sh@s@\pgfkeyscurrentname\endcsname\relax % is it the name of a shape?
            \sseq@passoptionto{/sseqpages}%
        \else
            \sseq@e@addto@options{\def\@nx\tikz@shape{\pgfkeyscurrentname}}% if so, store it
        \fi
    },
    /sseqpages/.is family,
    /sseqpages/scope/.is family,
    /sseqpages/scope/.unknown/.code={\sseq@passoptionto{/sseqpages}},
    /sseqpages/class/.is family,
    /sseqpages/class/label/.is family,
    /sseqpages/class/label/.unknown/.code={\sseq@keys@unknown{#1}},
    /sseqpages/class/node texts/.is family,
    /sseqpages/class/node texts/.unknown/.code={\sseq@passoptionto{/tikz}},
    /sseqpages/differential/.is family,
    /sseqpages/differential/.unknown/.code={\sseq@passoptionto{/sseqpages}},
    /sseqpages/struct line/.is family,
    /sseqpages/struct line/.unknown/.code={\sseq@passoptionto{/sseqpages}},
    /sseqpages/label/.is family,
    /sseqpages/label/.unknown/.code={\sseq@passoptionto{/tikz}},
    /sseqpages/tikz primitives/.is family,
    /sseqpages/tikz primitives/.unknown/.code={\sseq@keys@unknown{/tikz}},
    % One off directories
    /sseqpages/foreach/.unknown/.code={\sseq@passoptionto{/pgf/foreach}},
    /sseqpages/class placement/.unknown/.code={\sseq@passoptionto{/tikz}}
}

\pgfqkeys{/sseqpages/class}{shape/.code={\edef\tikz@shape{\pgfkeyscurrentname}}} % shape=whatever shape passing


%% label directions
\def\sseq@labeldirectionlist{\\{above}\\{below}\\{left}\\{right}\\{above left}\\{above right}\\{below left}\\{below right}}
\def\sseq@setlabeldirectionkeys#1{
    \@ifnextchar[{\sseq@setlabeldirectionkeys@{#1}}{\sseq@setlabeldirectionkeys@{#1}[/.code]}%]
}

\def\\#1{\@xp\sseq@addtostorelist\csname sseq@default@#1@distance\endcsname{1ex}}
\sseq@labeldirectionlist
\def\sseq@defaultlabeldistance#1{\csname sseq@default@#1@distance\endcsname}
\def\sseq@setdefaultlabeldistance#1#2{\sseq@savedpaths@add{\@xp\def\csname sseq@default@#1@distance\endcsname{#2}}}
\def\sseq@setdefaultlabeldistances#1{\def\\##1{\sseq@setdefaultlabeldistance{##1}{#1}}\sseq@labeldirectionlist}
\def\sseq@savedefaultlabeldistances{
    \def\\##1{
        \sseq@eval{
            \sseq@temptoks@iii{\the\sseq@temptoks@iii\@nx\sseq@setdefaultlabeldistance{##1}{\sseq@defaultlabeldistance{##1}}}
        }
    }
    \sseq@labeldirectionlist
}

\def\sseq@setlabeldirectionkeys@#1[#2]#3{
    \def\sseq@temp##1{#3}
    \sseq@temptoks@ii{}
    \def\\##1{
        \sseq@temptoks\@xp{\sseq@temp{##1}}
        \sseq@eval{\sseq@temptoks@ii{\the\sseq@temptoks@ii##1#2={\the\sseq@temptoks},}}
    }
    \sseq@labeldirectionlist
    \sseq@eval{\@nx\pgfqkeys{#1}{\the\sseq@temptoks@ii}}
}

\pgfqkeys{/sseqpages/class/label}{% maybe implement multipart node labels this way? No way!
    node/.sseq @ first pass code={\sseq@classlabelfalse},
    inside/.sseq @ first pass code={\sseq@classlabelfalse}
}

\pgfqkeys{/sseqpages/global}{background color/.initial=white}
\pgfqkeys{/sseqpages/label}{
    description/.code={
        \pgfkeysalso{/tikz/anchor=center}
        \def\sseq@edgeoptionhook{\pgfkeysalso{/tikz/fill=\pgfkeysvalueof{/sseqpages/global/background color}}}
    }
}


\def\sseq@edgeoptionhook{}

\sseq@setlabeldirectionkeys{/sseqpages/class/label}[/.sseq @ first pass code]{\sseq@classlabeltrue}
\sseq@setlabeldirectionkeys{/sseqpages/class/label}[/.sseq @ second pass append code]{\sseq@class@positionlabel{#1}{##1}}
\sseq@setlabeldirectionkeys{/sseqpages/class/label}[/.default]{\sseq@defaultlabeldistance{#1}}


\sseq@setlabeldirectionkeys{/sseqpages/global}[ label distance/.code]{\sseq@setdefaultlabeldistance{#1}{##1}}
\sseq@setlabeldirectionkeys{/sseqpages}[ label distance/.code]{\sseq@setdefaultlabeldistance{#1}{##1}}

\pgfqkeys{/sseqpages/global}{
    label distance/.code={\sseq@setdefaultlabeldistances{#1}}
}
\pgfqkeys{/sseqpages}{
    label distance/.code={\sseq@setdefaultlabeldistances{#1}}
}

\def\sseq@class@positionlabel#1#2{\sseq@pgfkeysdocommand{#1}{#2}}

%% Quote handling
% \sseq@handlequote will be installed later as the 'first char syntax' for ".
\def\sseq@handlequote#1{\pgfkeysalso{handle quote=#1}}
\pgfkeys{%
    /sseqpages/scope/handle quote/.code={\sseq@error{Quotes are not allowed as options to a scope}{}},
    /sseqpages/class/handle quote/.code={%
        \begingroup
        \let\tikz@quotes@as\sseq@handleclassquotes
        \tikz@quote@parser{#1}
        \endgroup
    },
    /sseqpages/handle quote/.code={\sseq@needstikztrue\sseq@d@addto@options{\tikzset{every to/.append style={#1}}}}
}
\def\sseq@classnodetext{}
\def\sseq@classnodetextoptions{}
\def\sseq@classlabelnodes{}
\def\sseq@handleclassquotes#1#2{% We use this via \let\tikz@quotes@as\sseq@handleclassquotes
    /utils/exec={% so it's called inside \pgfkeysalso{stuff}. Need to surround with /utils/exec={} to get out.
        \begingroup\pgfscope
        \sseq@options@firstpassmode
        \the\sseq@labelstyle
        \the\sseq@classlabelstyle
        \def\sseq@savedoptioncode{}
        \let\sseq@firstpass@shifttransform\@gobbletwo
        \def\pgfkeysdefaultpath{/sseqpages/class/label/}
        \sseq@options@normalmode
        \pgfkeysalso{#2}
        \sseq@temptoks{#1}
        \sseq@temptoks@ii\@xp{\sseq@savedoptioncode}
        \ifsseq@classlabel
            \sseq@options@firstpassmode
            \the\sseq@outerclasslabelstyle
            \sseq@x@addto@macro\sseq@classlabelnodes{%
                \@nx\ifsseq@needstikz
                    node[
                        /sseqpages/class/label,
                        /utils/exec={
                            \let\@nx\sseq@tikz@transform@save\@nx\tikz@transform
                            \let\@nx\tikz@transform\relax % The next line was set up to fix the classlabelstyle glitch
                            \the\sseq@labelstyle\@nx\the\sseq@labelstyle@page\the\sseq@classlabelstyle\@nx\the\sseq@classlabelstyle@page
                            \sseq@theouterclasslabelstyle\the\sseq@temptoks@ii
                            \@nx\iftikz@fullytransformed\@nx\else
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                            \let\@nx\tikz@transform\@nx\sseq@tikz@transform@save
                         }
                    ]{\the\sseq@temptoks}%
                \@nx\else
                    \@nx\node[
                        /sseqpages/class/label,
                        /utils/exec={
                            \let\@nx\sseq@tikz@transform@save\@nx\tikz@transform
                            \let\@nx\tikz@transform\relax % The next line was set up to fix the classlabelstyle glitch
                            \the\sseq@labelstyle\@nx\the\sseq@labelstyle@page\the\sseq@classlabelstyle\@nx\the\sseq@classlabelstyle@page
                            \sseq@theouterclasslabelstyle\the\sseq@temptoks@ii
                            \@nx\iftikz@fullytransformed\@nx\else
                                \@nx\tikz@fullytransformedtrue\@nx\tikz@addtransform{\@nx\pgftransformresetnontranslations\@nx\sseq@globalrotatetransform}
                            \@nx\fi
                           \let\@nx\tikz@transform\@nx\sseq@tikz@transform@save
                         }
                    ]{\the\sseq@temptoks};%
                \@nx\fi
            }%
        \else
            \sseq@options@firstpassmode
            \the\sseq@innerclasslabelstyle
            \sseq@options@normalmode
            \pgfkeysalso{#2}
            \sseq@temptoks@ii\@xp{\sseq@savedoptioncode}
            \gdef\sseq@classnodetext{#1}%
            \xdef\sseq@classnodetextoptions{
                \def\@nx\pgfkeysdefaultpath{/sseqpages/class/node texts/}
                \sseq@thelabelstyle\sseq@theinnerclasslabelstyle\the\sseq@temptoks@ii
            }%
        \fi
        \endpgfscope\endgroup
    }%
}

%% Parsing, background vs foreground, and context
\def\sseq@standardparse{%
    %\let\sseq@transform\sseq@okaytransform % Allow all coordinate transformations
    %\let\sseq@tikz@shifttransform\sseq@okayshifttransform
    %((((((((((((((((((
    \def\class##1){\sseq@setthiscall{\string\class##1)}\sseq@error@standardparse{\class}}%
    \def\replaceclass##1){\sseq@setthiscall{\string\replaceclass##1)}\sseq@error@standardparse{\replaceclass}}%
    \def\classoptions##1){\sseq@setthiscall{\string\classoptions##1)}\sseq@error@standardparse{\classoptions}}%
    \def\d##1){\sseq@setthiscall{\string\d##1)}\sseq@error@standardparse{\d}}%
    \def\doptions##1){\sseq@setthiscall{\string\doptions##1)}\sseq@error@standardparse{\doptions}}%
    \def\structline##1)##2){\sseq@setthiscall{\string\structline##1)##2)}\sseq@error@standardparse{\structline}}%
    \def\structlineoptions##1)##2){\sseq@setthiscall{\string\structlineoptions##1)##2)}\sseq@error@standardparse{\structlineoptions}}%
}

\def\sseq@nodeparse{%
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform
    \let\class\sseq@class
    \let\replaceclass\sseq@replaceclass
    \let\d\sseq@d
    \let\structline\sseq@structline
}

\def\sseq@errortikzprimsonly#1{\sseq@error{You can only use '#1' as an option for tikz primitives,
    not for \@nx\class, \@nx\replaceclass, \@nx\classoptions, \@nx\d, \@nx\doptions, \@nx\structline, or \@nx\structlineoptions}{}}

\pgfqkeys{/sseqpages}{%
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo\sseq@d@addto@options{\sseq@standardparse}},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform\sseq@d@addto@options{\sseq@nodeparse}},
    background/.code={\sseq@setsavedpaths{background}\pgfkeysalso{standard parse}},
    foreground/.code={\ifsseq@keepchanges\sseq@setsavedpaths{standard}\else\sseq@setsavedpaths{temporary}\fi\pgfkeysalso{node parse}}
}
\pgfqkeys{/sseqpages/tikz primitives}{%
    standard parse/.code={\let\sseq@firstpass@shifttransform\@gobbletwo\sseq@d@addto@options{\sseq@standardparse}},
    node parse/.code={\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform\sseq@d@addto@options{\sseq@nodeparse}},
    background/.code={\sseq@setsavedpaths{background}\pgfkeysalso{standard parse}},
    foreground/.code={\ifsseq@keepchanges\sseq@setsavedpaths{standard}\else\sseq@setsavedpaths{temporary}\fi\pgfkeysalso{node parse}},
    handle quote/.sseq @ second pass code={\tikzset{#1}}
}

\pgfkeys{/tikz/handle quote/.code={\sseq@error{If you want to use quotes on a tikz edge, please provide it directly to the 'to' comand (e.g., \@nx\draw (0,0) to["hi"] (1,0);)}}}


\pgfqkeys{/sseqpages/class}{
    standard parse/.sseq @ first pass code={\sseq@errortikzprimsonly{standard parse}},
    background/.sseq @ first pass code={\sseq@errortikzprimsonly{background}}
}
\pgfqkeys{/sseqpages/differential}{
    standard parse/.sseq @ first pass code={\sseq@errortikzprimsonly{standard parse}},
    background/.sseq @ first pass code={\sseq@errortikzprimsonly{background}}
}

\pgfqkeys{/sseqpages/class}{
    name/.code={\sseq@error{You can't use the 'name' option with the '\@nx\class' command. You should use 'alias' instead}{}}
}

%% Needs tikz
% Force \class or \d to fall back to using tikz to render their output
% Rather than using the faster direct \pgf primitives (largely copied from tikz to maximize compatibility)
% Drawing with tikz is slower, but I don't want to reimplement these features
\def\sseq@needstikzandpass#1#2{\sseq@needstikzandpass@{#1}#2,\@nil}
\def\sseq@needstikzandpass@#1#2,{%
    \pgfqkeys{#1}{#2/.code={\sseq@options@firstpass{\sseq@needstikztrue}\sseq@options@secondpass{\sseq@pgfkeysdocommand{#2}{##1}\sseq@needstikztrue}}}%
    \@ifnextchar\@nil{\@gobble}{\sseq@needstikzandpass@{#1}}%
}

\pgfqkeys{/sseqpages}{needs tikz/.code=\sseq@needstikztrue}
\sseq@needstikzandpass{/sseqpages}{%
    shade, blend mode, pattern, path picture, path fading, decorate, pin, label
}

\sseq@needstikzandpass{/sseqpages/differential}{%
    bend left, bend right, in, out, relative, looseness, in looseness, out looseness,
    min distance, max distance, out min distance, out max distance, in min distance, in max distance, distance,
    controls, in control, out control,
    loop, loop above, loop below, loop left, loop right % maybe delete the loops and replace them with errors? It's pretty pointless to use these.
}

\sseq@needstikzandpass{/sseqpages/struct line}{%
    bend left, bend right, in, out, relative, looseness, in looseness, out looseness,
    min distance, max distance, out min distance, out max distance, in min distance, in max distance, distance,
    controls, in control, out control,
    loop, loop above, loop below, loop left, loop right % maybe delete the loops and replace them with errors? It's pretty pointless to use these.
}

%    circle split/.code=\sseq@needstikzandpass,
%    circle solidus/.code=\sseq@needstikzandpass,
%    ellipse split/.code=\sseq@needstikzandpass,
%    rectangle split/.code=\sseq@needstikzandpass,
%    align/.code=\sseq@needstikzandpass,

\pgfqkeys{/sseqpages/struct line}{
    source anchor/.sseq @ second pass store in=\sseq@edgesourceanchor,
    target anchor/.sseq @ second pass store in=\sseq@edgetargetanchor
}
\pgfqkeys{/sseqpages/differential}{
    source anchor/.sseq @ second pass store in=\sseq@edgesourceanchor,
    target anchor/.sseq @ second pass store in=\sseq@edgetargetanchor
}

%% Style options
\def\sseq@stylelist{}
\def\sseq@clearchangestyles{}
\bgroup\catcode` =\active
\gdef\sseq@activespace{ }
\egroup
\def\sseq@newstyles#1{\def\sseq@temppath{#1}\bgroup\catcode` =\active\sseq@newstyles@}
\def\sseq@newstyles@#1{\egroup\sseq@newstyles@@#1,\sseq@nil}
\def\sseq@newstyles@@#1,{\sseq@newsseqstyle{#1}\sseq@newstyles@@goblespaces}
\def\sseq@newstyles@@goblespaces{\@xp\@ifnextchar\sseq@activespace{\@xp\sseq@newstyles@@goblespaces\@gobble}{\@ifnextchar\sseq@nil{\@gobble}{\sseq@newstyles@@}}}

\def\sseq@set@newstyle#1{\pgfqkeys{/sseqpages}{#1}\pgfqkeys{/sseqpages/global}{#1}\pgfqkeys{/sseqpages/global/default}{#1}\pgfqkeys{/sseqpages/first pass}{#1}}

\def\sseq@newsseqstyle#1{%
    \@xp\def\sseq@activespace{}
    \edef\sseq@tempcmd{\csname sseq@#1style\endcsname}%
    \edef\sseq@tempcmdb{\csname sseq@#1style@page\endcsname}%
    \@xp\edef\csname sseq@the#1style\endcsname{\@nx\the\sseq@tempcmd\@nx\the\sseq@tempcmdb}
    \@xp\let\sseq@activespace\space
    \@xp\newtoks\sseq@tempcmd
    \@xp\newtoks\sseq@tempcmdb
    \sseq@x@addto@macro\sseq@stylelist{\sseq@tempcmd{\@nx\the\sseq@tempcmd}}
    \sseq@x@addto@macro\sseq@clearchangestyles{\sseq@tempcmdb{}}
    \sseq@set@newstyle{%
        #1 style/.ecode={%
            \sseq@tempcmd{\@nx\pgfkeysalso{##1}}%
            \@nx\ifx\@nx\sseqset\@nx\sseqset@inprogress
                \@nx\sseq@savedpaths@xadd{\sseq@tempcmd{\@nx\the\sseq@tempcmd}}
            \@nx\fi
        },%
        #1s/.ecode={%
            \let\@nx\sseq@savedoptioncode@store\@nx\sseq@savedoptioncode
            \edef\@nx\sseq@savedoptioncode{\@nx\the\sseq@tempcmd}
            \@nx\sseq@addstylecodetooptions{\sseq@temppath}{##1}
            \sseq@tempcmd\@nx\@xp{\@nx\sseq@savedoptioncode}
            \@nx\ifx\@nx\sseqset\@nx\sseqset@inprogress
                \@nx\sseq@savedpaths@xadd{\sseq@tempcmd{\@nx\the\sseq@tempcmd}}
            \@nx\fi
            \let\@nx\sseq@savedoptioncode\@nx\sseq@savedoptioncode@store
        },%
        change #1s/.ecode={%
            \@nx\ifsseq@ispageenv\@nx\else\@nx\sseq@error{It's pointless to use 'change #1s' in the sseqdata environment. Try '#1s={##1}' instead}\@nx\fi
            \@nx\ifsseq@hasname\@nx\else\@nx\sseq@error{It's pointless to use 'change #1s' in a standalone sseqpage environment. Try '#1s={##1}' instead}\@nx\fi
            \let\@nx\sseq@savedoptioncode@store\@nx\sseq@savedoptioncode
            \edef\@nx\sseq@savedoptioncode{\@nx\the\sseq@tempcmdb}
            \@nx\sseq@addstylecodetooptions{\sseq@temppath}{##1}
            \sseq@tempcmdb\@nx\@xp{\@nx\sseq@savedoptioncode}
            \let\@nx\sseq@savedoptioncode\@nx\sseq@savedoptioncode@store
        }
    }%
}

\def\sseq@addstylecodetooptions#1#2{
    \def\sseq@temp{#1}
    \pgfqkeys{/sseqpages/setstyle}{#2}% This is lazy, small performance cost.
}
\def\sseq@addstylecodetooptions@#1{
    \sseq@tempiffalse
    \def\next{\sseq@addstylecodetooptions@@{#1}}
    \@xp\next\sseq@temp,\sseq@nil
}
\def\sseq@addstylecodetooptions@@#1#2,{
    \@ifnextchar\sseq@nil{% Ran out of paths to try
        \sseq@keys@try@addtooptions{#2}
        \ifsseq@tempif\else
            \sseq@keys@unknown{#1}
        \fi
        \@gobble
    }{
        \sseq@keys@try@addtooptions{#2}
        \ifsseq@tempif
            \let\next\sseq@gobble@to@nil
        \else
            \def\next{\sseq@addstylecodetooptions@@{#1}}
        \fi
        \next
    }
}

\pgfkeys{/sseqpages/setstyle/.unknown/.code={\sseq@addstylecodetooptions@{#1}}}

\sseq@newstyles{/sseqpages/global}{sseq, page}
\sseq@newstyles{/sseqpages}{path, edge, label, edge label, differential label, struct line label}
\sseq@newstyles{/sseqpages/class,/sseqpages}{class, permanent cycle, transient cycle, this page cycle}
\sseq@newstyles{/sseqpages/differential,/sseqpages}{differential}
\sseq@newstyles{/sseqpages/struct line,/sseqpages}{struct line, this page struct line}
\sseq@newstyles{/sseqpages/class/label}{class label, inner class label, outer class label}

\sseq@set@newstyle{classes/.style={classs={#1}},change classes/.style={change classs={#1}}}% "class" has a nonstandard plural
\sseq@set@newstyle{
    cycles/.code={\pgfkeysalso{classes={#1}}},
    permanent classes/.code={\pgfkeysalso{permanent cycles={#1}}},
    transient classes/.code={\pgfkeysalso{transient cycles={#1}}},
    this page classes/.code={\pgfkeysalso{this page cycles={#1}}},
    cycle style/.code={\pgfkeysalso{class style={#1}}},
    permanent class style/.code={\pgfkeysalso{permanent cycle style={#1}}},
    transient class style/.code={\pgfkeysalso{transient cycle style={#1}}},
    this page class style/.code={\pgfkeysalso{this page cycle style={#1}}},
    class label position/.code={\pgfkeysalso{class label positions={#1}}}
}%

\sseqset{
    %class labels=above,
    classes={draw,circle,inner sep=0.13em},
    edges=draw,
    edge labels={auto=right},
    labels={execute at begin node=$,execute at end node=$},
    differentials=->
}
%\showthe\sseq@labelstyle

\pgfqkeys{/handlers}{
    .sseq store in/.code 2 args={
        \sseq@addtostorelist#1{#2}
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \edef\sseq@temp@ii{\pgfkeyscurrentpath}
        \pgfkeys{
            \sseq@temp@ii/.store in=#1,
            /sseqpages/global/default/\sseq@temp/.store in/.expand once=\csname \sseq@macroname#1@default\endcsname
        }
    },
    .sseq is if/.code={
        \sseq@addiftostorelist@truedefault{#1}
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \edef\sseq@temp@ii{\pgfkeyscurrentpath}
        \pgfkeys{
            \sseq@temp@ii/.is if=sseq@#1,
            /sseqpages/global/default/\sseq@temp/.code={\@xp\edef\csname sseq@#1@default\endcsname{\global\@xp\@nx\csname sseq@#1##1\endcsname}}
        }
    },
    .sseq default code/.code={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \pgfkeys{/sseqpages/global/default/\sseq@temp/.code={#1}}
    },
    .sseq default code 2 args/.code={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \pgfkeys{/sseqpages/global/default/\sseq@temp/.code 2 args={#1}}
    },
    .sseq default copy/.code={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \pgfkeys{/sseqpages/global/default/\sseq@temp/.ecode={\@nx\pgfkeysalso{/sseqpages/global/\sseq@temp={##1}}}}
    },
    .sseq default error/.code={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \pgfkeys{/sseqpages/global/default/\sseq@temp/.ecode={\@nx\sseq@error@nodefaultallowed{\sseq@temp}}}
    },
    .sseq x y alias/.code={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \ifx\pgfkeysnovalue#1
            \edef\sseq@tempb##1{##1 \sseq@temp}
        \else
            \def\sseq@tempb##1{#1}
            \sseq@usedparam\sseq@tempb
        \fi
        \pgfkeys{
            /sseqpages/global/\sseq@temp/.ecode={\@nx\pgfkeysalso{\sseq@tempb{x}=##1,\sseq@tempb{y}=##1}},
            /sseqpages/global/default/\sseq@temp/.ecode={\@nx\pgfkeysalso{\sseq@tempb{x}=##1,\sseq@tempb{y}=##1}}
        }
    }
}

\bgroup\lccode`*=`#\lowercase{\egroup
    \def\sseq@usedparam#1{
        \@xp\sseq@usedparam@\@xp#1\meaning#1*\@nil
    }
    \def\sseq@usedparam@#1#2->#3*#4\@nil{
        \ifx&#4&
            \@xp\def\@xp#1\@xp##\@xp1\@xp{\@xp##\@xp1\@xp\space#1{}}
        \fi
    }
}

\pgfqkeys{/handlers}{
    sseq @@ make style handler/.style={
        .sseq #1/.code={
            \sseq@keys@lastpart{\pgfkeyscurrentpath}
            \pgfkeys{
                /sseqpages/class/\sseq@temp/.#1={##1},
                /sseqpages/differential/\sseq@temp/.#1={##1},
                /sseqpages/struct line/\sseq@temp/.#1={##1}
            }
        }
    },
    sseq @@ make style handler=style,
    sseq @@ make style handler=prefix style,
    sseq @@ make style handler=append style,
    sseq @@ make style handler=code,
    sseq @@ make style handler=prefix code,
    sseq @@ make style handler=append code,
%
    .sseq grading/.code 2 args={
        \sseq@keys@lastpart{\pgfkeyscurrentpath}
        \sseq@temptoks{degree={#1}{#2}}
        \pgfkeys{
            /sseqpages/global/\sseq@temp/.estyle={\the\sseq@temptoks},
            %/sseqpages/global/\sseq@temp/.code 2 args={},
            /sseqpages/global/default/\sseq@temp/.estyle={\the\sseq@temptoks}
        }
    },
    Adams grading/.sseq grading={-1}{#1},
    homological Serre grading/.sseq grading={-#1}{#1-1},
    cohomological Serre grading/.sseq grading={#1}{1-#1},
}


\def\sseq@keys@ignorehandlers{\\{value forbidden}\\{value required}\\{default}\\{sseq store in}\\{sseq is if}\\{sseq default code}\\{sseq default code 2 args}\\{sseq default copy}}
\def\sseq@keys@removehandler#1{\sseq@keys@removehandler@#1=\sseq@nil}
\def\sseq@keys@removehandler@#1/.#2=#3\sseq@nil{
    \def\sseq@temp{#2}
    \def\\##1{\def\sseq@tempii{##1}\ifx\sseq@tempii\sseq@temp \sseq@tempiffalse\let\\\@gobble\fi}
    \sseq@keys@ignorehandlers
    \def\sseq@temp{#1}
}

\gdef\sseq@globalkeys#1{
    \let\sseq@storetilde~
    \def~{}
    \pgfqkeys{/sseqpages/global}{#1}
    \sseq@globalkeys@#1,\sseq@nil
    \let~\sseq@storetilde
}

\def\sseq@globalkeys@#1,{
    \sseq@tempiftrue
    \sseq@keys@removehandler{#1}
    \ifsseq@tempif
        \pgfkeys{/sseqpages/\sseq@temp/.ecode={\@nx\sseq@error@optionglobalonly{\sseq@temp}}}
        \pgfkeysifdefined{/sseqpages/global/default/\sseq@temp/.@cmd}{}{
            \pgfkeys{/sseqpages/global/default/\sseq@temp/.ecode={\@nx\pgfkeysalso{sseqs={\sseq@temp}}}}
        }
    \fi
    \sseq@globalkeys@next
}

\def\sseq@globalkeys@eatentry#1,{
    \sseq@globalkeys@next
}

\def\sseq@globalkeys@next{
    \@ifnextchar\sseq@nil{\@gobble}{
        \@ifnextchar~{\sseq@globalkeys@eatentry}{
            \@ifnextchar,{\sseq@globalkeys@eatentry}{
                \sseq@globalkeys@
            }
        }
    }
}


%% Global options
\pgfqkeys{/sseqpages/global/name only}{
    name/.code={\def\sseq@thename{#1}\sseq@hasnametrue},
    name/.value required,
    keep changes/.is if=sseq@keepchanges,
    update existing/.code={\ifsseq@ispageenv\sseq@error{Option 'update existing' is only for the sseqdata environment}\fi\sseq@updateexistingtrue}
}

\sseq@globalkeys{%
    name/.code={},
    name/.sseq default error,
    page/.code={\ifsseq@hasname\def\sseq@thepage{#1}\let\page\sseq@thepage\else\sseq@error{You can't specify a page but no name}{}\fi},
    page/.sseq default error,% implement page default?
    degree/.code 2 args={\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}\let\d\sseq@d},
    degree/.sseq default code 2 args={\def\sseq@targetx@default##1{#1}\def\sseq@targety@default##1{#2}\let\d\sseq@d},
    update existing/.code={},
    keep changes/.code={%
        \ifsseq@hasname\else\sseq@error{Option 'keep changes' is only for named spectral sequences}\fi
        \ifsseq@ispageenv\else\sseq@error{Option 'keep changes' is only for the sseqpage environment}\fi
    },
    custom clip/.sseq store in=\sseq@customclip{},
    clip/.sseq is if=clip,
    draw differentials/.sseq is if=drawdifferentials,
    no differentials/.code={\sseq@drawdifferentialsfalse},
    no differentials/.value forbidden,
    draw struct lines/.sseq is if=drawstructlines,
    no struct lines/.code={\sseq@drawstructlinesfalse},
    no struct lines/.value forbidden,
    draw orphan edges/.sseq is if=draworphanedges,
    no orphan edges/.code={\sseq@draworphanedgesfalse},
    class placement transform/.code={%
        \bgroup
        \let\tikz@transform\pgfutil@empty
        \pgfqkeys{/sseqpages/class placement}{#1}%
        \global\let\sseq@classplacementtransform\tikz@transform
        \egroup
    },
    class placement transform/.sseq default copy,
    class placement transform/.value required
}

\sseq@addtostorelist\sseq@targetx{}\sseq@addtostorelist\sseq@targety{}
\sseq@addtostorelist\sseq@xlabelstep{1}\sseq@addtostorelist\sseq@ylabelstep{1}
\sseq@addtostorelist\sseq@classplacementtransform{}

\sseq@addiftostorelist@truedefault{borderxaxis}\sseq@addiftostorelist@truedefault{borderyaxis}
\sseq@addtostorelist\sseq@xaxisorigin{0}\sseq@addtostorelist\sseq@yaxisorigin{0}

%% Range
\sseq@globalkeys{%
    x range/.code 2 args={\sseq@xrange{#1}{#2}},
    x range/.sseq default code 2 args={\sseq@xrange@default{#1}{#2}},
    y range/.code 2 args={\sseq@yrange{#1}{#2}},
    y range/.sseq default code 2 args={\sseq@yrange@default{#1}{#2}}
}

% These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
\@xp\sseq@addtostorelist\@xp\sseq@xmin\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymin\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@xmax\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymax\@xp{\@xp-\sseq@infinity}
% These are used to decide whether to add a certain node to savedpaths.
% In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
% If the user doesn't specify a range, all nodes should be rendered
% To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
\@xp\sseq@addtostorelist\@xp\sseq@xminmm\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@yminmm\@xp{\@xp-\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@xmaxpp\@xp{\sseq@infinity}
\@xp\sseq@addtostorelist\@xp\sseq@ymaxpp\@xp{\sseq@infinity}

\def\sseq@xrange#1#2{%
    \global\let\sseq@xminmax\@gobbletwo % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \global\let\sseq@yminmax\@gobbletwo %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp{\the\sseq@tempcount}%
}

\def\sseq@xrange@default#1#2{%
    \global\let\sseq@xminmax\@gobbletwo % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin@default{#1}%
    \gdef\sseq@xmax@default{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@xminmm@default{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@xmaxpp@default{\the\sseq@tempcount}%
}
\def\sseq@yrange@default#1#2{%
    \global\let\sseq@yminmax\@gobbletwo %
    \gdef\sseq@ymin@default{#1}%
    \gdef\sseq@ymax@default{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\xdef\sseq@yminmm@default{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\xdef\sseq@ymaxpp@default{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax@active#1#2{%
    \ifnum#1<\sseq@xmin
        \ifx\sseq@yminmax\@gobbletwo
            \ifnum#2>\sseq@yminmm
                \ifnum#2<\sseq@ymaxpp
                    \xdef\sseq@xmin{#1}%
                \fi
            \fi
        \else
            \xdef\sseq@xmin{#1}%
        \fi
    \fi
    \ifnum#1>\sseq@xmax
        \ifx\sseq@yminmax\@gobbletwo
            \ifnum#2>\sseq@yminmm
                \ifnum#2<\sseq@ymaxpp
                    \xdef\sseq@xmax{#1}%
                \fi
            \fi
        \else
            \xdef\sseq@xmax{#1}%
        \fi
    \fi
}

\def\sseq@yminmax@active#1#2{%
    \ifnum#2<\sseq@ymin
        \ifx\sseq@xminmax\@gobbletwo
            \ifnum#1>\sseq@xminmm
                \ifnum#1<\sseq@xmaxpp
                    \xdef\sseq@ymin{#2}%
                \fi
            \fi
        \else
            \xdef\sseq@ymin{#2}%
        \fi
    \fi
    \ifnum#2>\sseq@ymax
        \ifx\sseq@xminmax\@gobbletwo
            \ifnum#1>\sseq@xminmm
                \ifnum#1<\sseq@xmaxpp
                    \xdef\sseq@ymax{#2}%
                \fi
            \fi
        \else
            \xdef\sseq@ymax{#2}%
        \fi
    \fi
}

%% Axes and Layout options
% axes options:
\sseq@globalkeys{%
    labels/.code={},
    x labels/.code={},
    y labels/.code={},
    x axis style/.is choice,
    y axis style/.is choice,
    axes style/.sseq x y alias=axis style,
    ~x axis style/border/.code={\sseq@drawxaxistrue\sseq@borderxaxistrue},
    ~y axis style/border/.code={\sseq@drawyaxistrue\sseq@borderyaxistrue},
    ~x axis style/center/.code={
        \sseq@drawxaxistrue\sseq@borderxaxisfalse
        \ifx\sseq@xaxisgap\sseq@xaxisgap@default
            \def\sseq@xaxisgap{0cm}
        \fi
    },
    ~y axis style/center/.code={\sseq@drawyaxistrue\sseq@borderyaxisfalse\ifx\sseq@yaxisgap\sseq@yaxisgap@default\def\sseq@yaxisgap{0cm}\fi},
    ~x axis style/none/.code={\sseq@drawxaxisfalse},
    ~y axis style/none/.code={\sseq@drawyaxisfalse},
    x axis origin/.sseq store in=\sseq@xaxisorigin{0},
    y axis origin/.sseq store in=\sseq@yaxisorigin{0},
    axes origin/.sseq x y alias=axis origin,
    no x axis/.code={\sseq@drawxaxisfalse},
    no x axis/.value forbidden,
    no y axis/.code={\sseq@drawyaxisfalse},
    no y axis/.value forbidden,
    no axes/.value forbidden,
    no axes/.sseq x y alias=no #1 axis,
    draw x axis/.sseq is if=drawxaxis,
    draw y axis/.sseq is if=drawyaxis,
    draw axes/.is choice,
    ~draw axes/true/.code={\pgfkeysalso{draw x axis}\pgfkeysalso{draw y axis}},
    ~draw axes/false/.code={\pgfkeysalso{draw x axis=false}\pgfkeysalso{draw y axis=false}},
    ~draw axes/.default=true,
    rotate labels/.sseq is if=rotatelabels,
    label step/.sseq x y alias,
    label step/.value required,
    x label step/.sseq store in=\sseq@xlabelstep{1},
    y label step/.sseq store in=\sseq@ylabelstep{1},
%
    no x axis labels/.code={\sseq@drawxaxislabelsfalse},
    no x axis labels/.value forbidden,
    draw x axis labels/.sseq is if=drawxaxislabels,
    no y axis labels/.code={\sseq@drawyaxislabelsfalse},
    no y axis labels/.value forbidden,
    draw y axis labels/.sseq is if=drawyaxislabels,
    no axes labels/.value forbidden,
    no axes labels/.sseq x y alias=no #1 axis labels,
    draw axes labels/.code={\pgfkeysalso{draw x axis={#1},draw y axis={#1}}},
    draw axes labels/.default=true
}

\sseq@globalkeys{
    axes gap/.sseq x y alias=axis gap,
    axes gap/.value required,
    x axis gap/.sseq store in=\sseq@xaxisgap{0.5cm},
    y axis gap/.sseq store in=\sseq@yaxisgap{0.5cm},
    label gap/.sseq x y alias,
    label gap/.value required,
    x label gap/.sseq store in=\sseq@xlabelgap{0.5cm},
    y label gap/.sseq store in=\sseq@ylabelgap{0.5cm},
    x axis extend start/.sseq store in=\sseq@xaxis@start@extend{0.9cm},
    y axis extend start/.sseq store in=\sseq@yaxis@start@extend{0.9cm},
    axes extend start/.sseq x y alias=axis extend start,
    x axis extend end/.sseq store in=\sseq@xaxis@end@extend{0.5cm},
    y axis extend end/.sseq store in=\sseq@yaxis@end@extend{0.5cm},
    axes extend end/.sseq x y alias=axis extend end,
    x axis clip padding/.sseq store in=\sseq@xclip@axisgap{0.1cm},
    y axis clip padding/.sseq store in=\sseq@yclip@axisgap{0.1cm},
    axes clip padding/.sseq x y alias=axis clip padding,
    right clip padding/.sseq store in=\sseq@clip@padding@right{0.1cm},
    left clip padding/.sseq store in=\sseq@clip@padding@left{0.4cm},
    top clip padding/.sseq store in=\sseq@clip@padding@top{0.1cm},
    bottom clip padding/.sseq store in=\sseq@clip@padding@bottom{0.4cm}
}

%% Global Coordinate transformations
\sseq@globaldetonetrue
\sseq@addtostorelist\sseq@globaldetonetransform{}
\sseq@addtostorelist\sseq@globalrotatetransform{}
\sseq@addtostorelist\sseq@globalscaletransform{}

\def\sseq@globaldetoneoption#1#2{%
    \ifsseq@globaldetone
        \@xp\gdef\@xp\sseq@globaldetonetransform\@xp{\sseq@globaldetonetransform #1}%
        #1
    \else
        \sseq@error{You cannot use the option '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option after using 'xscale', 'yscale', or 'scale'. Please move '#2\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' before any scaling options}
    \fi
}
\def\sseq@globalscaleoption#1{%
    \sseq@globaldetonefalse
    \@xp\gdef\@xp\sseq@globalscaletransform\@xp{\sseq@globalscaletransform#1}#1
}
\pgfqkeys{/sseqpages/global}{%
    xshift/.code={\sseq@error@illegalasglobal{xshift}},
    yshift/.code={\sseq@error@illegalasglobal{yshift}},
    shift/.code={\sseq@error@illegalasglobal{shift}},
    scale around/.code={\sseq@error@illegalasglobal{scale around}},
    rotate around/.code={\sseq@error@illegalasglobal{rotate around}},
    rotate/.code={%
        \@xp\gdef\@xp\sseq@globalrotatetransform\@xp{\sseq@globalrotatetransform\pgftransformrotate{#1}}%
        \sseq@globaldetoneoption{\pgftransformrotate{#1}}{rotate}%
    },
    rotate/.value required,
    xslant/.code={\sseq@globaldetoneoption{\pgftransformxslant{#1}}{xslant}},
    xslant/.value required,
    yslant/.code={\sseq@globaldetoneoption{\pgftransformyslant{#1}}{yslant}},
    yslant/.value required,
    xmirror/.code={\sseq@globaldetoneoption{\pgftransformxscale{-1}}{xmirror}},
    xmirror/.value forbidden,
    ymirror/.code={\sseq@globaldetoneoption{\pgftransformyscale{-1}}{ymirror}},
    ymirror/.value forbidden,
    xscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax%
            \sseq@error{You said 'xscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'xmirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformxscale{#1}}%
    },
    xscale/.value required,
    yscale/.code={%
        \pgfmathparse{int(#1-1)}%
        \ifnum\pgfmathresult<0\relax
            \sseq@error{You said 'yscale=#1' as a global option, but scaling by negative numbers is not allowed as a global option. Instead, please use the option 'ymirror', and then scale by the absolute value}
        \fi
        \sseq@globalscaleoption{\pgftransformyscale{#1}}%
    },
    yscale/.value required,
    scale/.code={\sseq@globalscaleoption{\pgftransformscale{#1}}},
    scale/.value required
}

\pgfqkeys{/sseqpages/class placement}{
    x shift/.code={\sseq@error@noclassplacementshift{x shift}{#1}},
    y shift/.code={\sseq@error@noclassplacementshift{y shift}{#1}},
    shift/.code={\sseq@error@noclassplacementshift{shift}{#1}}
}

%% setup for coordinate transformation keys
\pgfqkeys{/sseqpages}{%
    x/.code={\sseq@error@optionillegal{x}{#1}{}},
    y/.code={\sseq@error@optionillegal{y}{#1}{}},
    z/.code={\sseq@error@optionillegal{z}{#1}{}},
    xshift/.sseq @ second pass code={\sseq@shifttransform{x}{#1}}, % I don't know why it has to be this way,
    xshift/.sseq @ first pass append code={\sseq@firstpass@shifttransform{x}{#1}}, % but it definitely breaks if I change it...
    xshift/.value required,
    yshift/.sseq @ second pass code={\sseq@shifttransform{y}{#1}},
    yshift/.sseq @ first pass append code={\sseq@firstpass@shifttransform{y}{#1}},
    yshift/.value required,
    shift/.sseq @ second pass code={\sseq@transform{shift}{#1}},
    shift/.value required,
    shift only/.sseq @ second pass code={\sseq@transform{shift only}{}},
    xscale/.sseq @ second pass code={\sseq@transform{xscale}{#1}},
    xscale/.value required,
    yscale/.code={\sseq@transform{yscale}{#1}},
    yscale/.value required,
    scale/.sseq @ second pass code={\sseq@transform{scale}{#1}},
    scale/.value required,
    scale around/.sseq @ second pass code={\sseq@transform{scale around}{#1}},
    scale around/.value required,
    xslant/.sseq @ second pass code={\sseq@transform{xslant}{#1}},
    xslant/.value required,
    yslant/.sseq @ second pass code={\sseq@transform{yslant}{#1}},
    yslant/.value required,
    rotate/.sseq @ second pass code={\sseq@transform{rotate}{#1}},
    rotate/.value required,
    rotate around/.sseq @ second pass code={\sseq@transform{rotate around}{#1}},
    rotate around/.value required,
    cm/.sseq @ second pass code={\sseq@transform{cm}{#1}},
    cm/.value required,
    reset cm/.sseq @ second pass code={\sseq@transform{reset cm}{}},
    reset cm/.value forbidden,
    transform canvas/.sseq @ second pass code={\sseq@transform{transform canvas}{#1}},
    transform canvas/.value required
}


\pgfqkeys{/sseqpages/tikz primitives}{
    shift/.code={\sseq@error@internal{Not implemented}},
    xshift/.sseq @ second pass code=\sseq@tikz@shifttransform{x}{#1},
    yshift/.sseq @ second pass code=\sseq@tikz@shifttransform{y}{#1},
    rotate around/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{rotate}{#1}},
    rotate/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{rotate}{#1}},
    rotate/.value required,
    xslant/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{xslant}{#1}},
    xslant/.value required,
    yslant/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{yslant}{#1}},
    yslant/.value required,
    xmirror/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{xmirror}{-1}},
    xmirror/.value forbidden,
    ymirror/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{ymirror}{-1}},
    ymirror/.value forbidden,
    xscale/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{xscale}{#1}},
    xscale/.value required,
    yscale/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{yscale}{#1}},
    yscale/.value required,
    scale/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{scale}{#1}},
    scale/.value required,
    scale around/.sseq @ second pass code={\sseq@standardparse\sseq@pgfkeysdocommand{scale around}{#1}}
}
\pgfqkeys{/sseqpages/scope}{
    shift/.code={\sseq@error@internal{Not implemented}},
    xshift/.sseq @ second pass code={\sseq@tikz@shifttransform{x}{#1}},
    xshift/.sseq @ first pass append code={\sseq@tikz@firstpass@checkshifttransform{x}{#1}},
    yshift/.sseq @ second pass code={\sseq@tikz@shifttransform{y}{#1}},
    yshift/.sseq @ first pass append code={\sseq@tikz@firstpass@checkshifttransform{y}{#1}},
    rotate around/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{rotate}{#1}},
    rotate/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{rotate}{#1}},
    rotate/.value required,
    xslant/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{xslant}{#1}},
    xslant/.value required,
    yslant/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{yslant}{#1}},
    yslant/.value required,
    xmirror/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{xmirror}{-1}},
    xmirror/.value forbidden,
    ymirror/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{ymirror}{-1}},
    ymirror/.value forbidden,
    xscale/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{xscale}{#1}},
    xscale/.value required,
    yscale/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{yscale}{#1}},
    yscale/.value required,
    scale/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{scale}{#1}},
    scale/.value required,
    scale around/.sseq @ code={\sseq@standardparse}{\sseq@standardparse\sseq@pgfkeysdocommand{scale around}{#1}}
}



\def\sseq@error@optionillegal#1#2#3{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi', but the option '#1' is
        illegal in the sseqdata and sseqpage environments#3%
    }{}%
}

\def\sseq@macrogobble#1->{}

\def\sseq@error@optionglobalonly#1{%
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else={\@xp\sseq@macrogobble\meaning\pgfkeyscurrentvalue}\fi', but the option '#1' is
        only allowed as a global option (as in '\@nx\begin{sseqdata}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else={\@xp\sseq@macrogobble\meaning\pgfkeyscurrentvalue}\fi]' or
        '\@nx\begin{sseqpage}[#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else={\@xp\sseq@macrogobble\meaning\pgfkeyscurrentvalue}\fi]')%
    }{}%
}

\def\sseq@error@nodefaultallowed#1{
    \sseq@error{%
        You cannot set a default value for '#1'. Maybe try \@nx\sseqset{sseqs={#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi}}%
    }{}
}

\def\sseq@error@illegalasglobal#1{
    \sseq@error{%
        You said '#1\ifx\pgfkeyscurrentvalue\pgfkeysnovalue@text\else=\pgfkeyscurrentvalue\fi' as a global option, but option '#1' is illegal as a global option
    }
}


\def\sseq@okaytransform#1#2{\sseq@pgfkeysdocommand{#1}{#2}}
\def\sseq@error@illegaltransform#1#2{%
    \sseq@temptoks{#2}%
    \sseq@error{%
        You said '#1\ifx&#2&\else=\the\sseq@temptoks\fi', but
        no coordinate transforms are allowed in the body of sseqpages or sseqdata other
        than shifts by unit-free integers. If you need a coordinate transformation,
        first use the option 'standard parse'%
    }{}%
}

\def\sseq@firstpass@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult\relax
    }{\sseq@error@illegaltransform{#1shift}{#2}}%
}
\let\sseq@firstpass@shifttransform\sseq@firstpass@checkshifttransform

\def\sseq@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@#1\endcsname\pgfmathresult\relax
        \sseq@pgfkeysdocommand{#1shift}{#2cm}
    }{\sseq@error@illegaltransform{#1shift}{#2}}%
}

\def\sseq@okayshifttransform#1#2{%
    \pgfmathparse{#2}
    \ifpgfmathunitsdeclared
        \sseq@pgfkeysdocommand{#1shift}{#2}
    \else
        \sseq@pgfkeysdocommand{#1shift}{#2cm}
    \fi
}

\def\sseq@tikz@firstpass@checkshifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
    }{\sseq@standardparse}%
}

\def\sseq@tikz@shifttransform#1#2{%
    \pgfmathparse{#2}%
    \sseq@ifpgfmathresultisunitlessint{%
        \@xp\pgfmathint\@xp{\pgfmathresult}%
        \@xp\advance\csname sseq@\sseq@getfirstchar#1\sseq@nil\endcsname\pgfmathresult\relax
        \sseq@pgfkeysdocommand{#1shift}{#2cm}
    }{
        \sseq@standardparse
        \ifpgfmathunitsdeclared
            \sseq@pgfkeysdocommand{#1shift}{#2}
        \else
            \sseq@pgfkeysdocommand{#1shift}{#2cm}
        \fi
    }%
}

\def\sseq@ifpgfmathresultisunitlessint{\ifpgfmathunitsdeclared\@xp\@secondoftwo\else\sseq@ifpgfmathresultisint{\@xp\@firstoftwo}{\@xp\@secondoftwo}\fi}
\def\sseq@ifpgfmathresultisint{\@xp\sseq@ifpgfmathresultisint@\pgfmathresult..\sseq@nil}
\def\sseq@ifpgfmathresultisint@#1.#2.#3\sseq@nil{\ifx\sseq@nil#2\sseq@nil\@xp\@firstoftwo\else \ifnum#2=0\relax \@xp\@xp\@xp\@firstoftwo\else \@xp\@xp\@xp\@secondoftwo\fi\fi}



%%% Command redefinition commands

% copy commands into user namespace by removing sseq@ prefixes
% given a list of commands, \let\thiscommand\sseq@thiscommand on each one
\def\sseq@copycommands#1{\sseq@copycommands@#1\sseq@nil}
\def\sseq@copycommands@#1{%
    \ifx#1\sseq@nil\else % if so, that was the last command in the list
        \@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname
        \@xp\sseq@copycommands@
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@tikzcommands{%
        \clip\coordinate\draw\fill\filldraw
        \graph\matrix\node\path\pattern
        \shade\shadedraw\useasboundingbox
}

\def\sseq@tikz@pageconstraint{1}
\def\sseq@tikz@pageconstraint@true{1}
\pgfqkeys{/sseqpages/tikz primitives}{
    page constraint/.code={
        \bgroup
        \sseq@temptoks\@xp{\sseq@tikz@pageconstraint}
        \sseq@temptoks@ii{#1}
        \edef\sseq@temp{(\the\sseq@temptoks)&&(\the\sseq@temptoks@ii)}
        \@xp\egroup
        \@xp\def\@xp\sseq@tikz@pageconstraint\@xp{\sseq@temp}
    },
    page constraint or/.code={
        \bgroup
        \sseq@temptoks\@xp{\sseq@tikz@pageconstraint}
        \sseq@temptoks@ii{#1}
        \edef\sseq@temp{(\the\sseq@temptoks)||(\the\sseq@temptoks@ii)}
        \@xp\egroup
        \@xp\def\@xp\sseq@tikz@pageconstraint\@xp{\sseq@temp}

    },
    set page constraint/.store in=\sseq@tikz@pageconstraint
}

\pgfqkeys{/sseqpages/scope}{
    page constraint/.code={
        \bgroup
        \sseq@temptoks\@xp{\sseq@tikz@pageconstraint}
        \sseq@temptoks@ii{#1}
        \edef\sseq@temp{(\the\sseq@temptoks)&&(\the\sseq@temptoks@ii)}
        \@xp\egroup
        \@xp\def\@xp\sseq@tikz@pageconstraint\@xp{\sseq@temp}
    },
    page constraint or/.code={
        \bgroup
        \sseq@temptoks\@xp{\sseq@tikz@pageconstraint}
        \sseq@temptoks@ii{#1}
        \edef\sseq@temp{(\the\sseq@temptoks)||(\the\sseq@temptoks@ii)}
        \@xp\egroup
        \@xp\def\@xp\sseq@tikz@pageconstraint\@xp{\sseq@temp}

    },
    set page constraint/.store in=\sseq@tikz@pageconstraint,
    background/.code={\sseq@standardparse\sseq@setsavedpaths{background}\pgfkeysalso{standard parse}},
    on background layer/.code={\sseq@options@secondpass{\pgfonlayer{background}}\pgfkeysalso{/tikz/on background layer={#1}}}
}

\def\sseq@modtikzcommands{%
    \let\scope\sseq@scope
    \let\endscope\sseq@endscope
    \@xp\sseq@modtikzcommands@\sseq@tikzcommands\sseq@nil
}
\def\sseq@modtikzcommands@#1{%
    \ifx#1\sseq@nil\else
        \def#1{\csname\sseq@macroname#1\space\endcsname#1}%
        \@xp\let\csname\sseq@macroname#1\space\endcsname\sseq@defer@tikzcommand % This is just for error reporting so that it will say "Paragraph ended before \draw  was complete"
        \@xp\sseq@modtikzcommands@
    \fi
}
\def\sseq@defer@tikzcommand#1#2;{%
    \begingroup
    \sseq@for@checkoptions{#2}%
    \sseq@tikzprims@handleoptions{#1}#2;[\sseq@nil]% outputs into \sseq@temptoks
    \@xp\sseq@tikzprimitives@coords\@xp{\the\sseq@temptoks}
    \sseq@temptoks\@xp{\sseq@temp}
    \ifx\sseq@tikz@pageconstraint\sseq@tikz@pageconstraint@true
        \sseq@savedpaths@xadd{\sseq@defer@tikzcommand@addcmd}%
    \else
        \sseq@temptoks@ii\@xp{\sseq@tikz@pageconstraint}%
        \sseq@savedpaths@xadd{\@nx\sseq@pgfmathparse@rescan{\the\sseq@temptoks@ii}\@nx\ifnum\@nx\pgfmathresult>0\relax \sseq@defer@tikzcommand@addcmd\@nx\fi}%
    \fi
    \endgroup
}
\ifnum\sseq@errormode>1
    \def\sseq@defer@tikzcommand@addcmd{%
        \def\@nx\sseq@inputlineno{\the\inputlineno}%
        \@nx\sseq@setthiscall{\the\sseq@temptoks}% sseq@temptoks set by \sseq@tikzprims@handleoptions
        \the\sseq@temptoks
    }
\else
    \def\sseq@defer@tikzcommand@addcmd{\the\sseq@temptoks}% sseq@temptoks set by \sseq@tikzprims@handleoptions
\fi

\def\sseq@tikzprims@handleoptions#1#2[#3]{%
    \ifx\sseq@nil#3%
        \sseq@temptoks{#1#2}
    \else
        \def\sseq@savedoptioncode{}%
        \pgfqkeys{/sseqpages/tikz primitives}{#3}%
        \sseq@temptoks{#1#2}
        \sseq@temptoks@ii\@xp{\sseq@savedoptioncode}
        \sseq@ifhop{\sseq@eval{\@nx\sseq@tikzprims@handleoptions{\the\sseq@temptoks[/utils/exec={\the\sseq@temptoks@ii}]}}}
    \fi
}
\def\sseq@pgfmathparse@rescan#1{\catcode`\&=12\relax\scantokens{\pgfmathparse{#1}}}

%% Tikz primitives
\def\sseq@tikzprimitives@coords#1{\def\sseq@temp{}\sseq@tikzprimitives@coords@#1(\sseq@nil)}
\def\sseq@tikzprimitives@coords@#1(#2){
    \ifx\sseq@nil#2
        \let\next\@gobbletwo
        \sseq@g@addto@macro\sseq@temp{#1}
    \else
        \let\next\sseq@tikzprimitives@coords@notaclass
        \ifsseq@tikzprims@integershift
            \pgfutil@in@${#2}
            \ifpgfutil@in@
                \let\next\sseq@tikzprimitives@coords@handlemath
            \else
                \pgfutil@in@:{#2}
                \ifpgfutil@in@\else
                    \pgfutil@in@{intersection}{#2}
                    \ifpgfutil@in@\else
                        \pgfutil@in@|{#2}%
                        \ifpgfutil@in@\else
                            \pgfutil@in@,{#2}
                            \ifpgfutil@in@
                                \sseq@iffullcoord(#2){\sseq@tikzprimitive@getcoord#2\sseq@nil}{\sseq@tikzprimitive@getcoord#2,\sseq@nil}
                                \sseq@obj@ifundef{partcoord.(\sseq@tempx,\sseq@tempy).numnodes}{}{
                                    \def\next##1##2{\sseq@tikzprimitives@coords@}
                                    \sseq@whichclass\sseq@n\sseq@tempx\sseq@tempy\sseq@tempn{oops}
                                    \sseq@temptoks{#1}
                                    \sseq@x@addto@macro\sseq@temp{\the\sseq@temptoks(sseq{\sseq@tempx,\sseq@tempy,\sseq@n}\sseq@tempanchor)}
                                }
                            \fi
                        \fi
                    \fi
                \fi
            \fi
        \fi
    \fi
    \next{#1}{#2}
}
\def\sseq@tikzprimitives@coords@notaclass#1#2{\sseq@g@addto@macro\sseq@temp{#1(#2)}\sseq@tikzprimitives@coords@}
\def\sseq@tikzprimitives@coords@handlemath#1#2{\sseq@tikzprimitives@coords@handlemath@{#1}(#2)}
\def\sseq@tikzprimitives@coords@handlemath@#1$#2$){\sseq@g@addto@macro\sseq@temp{#1$#2$)}}
\def\sseq@tikzprimitive@getcoord#1,#2,#3\sseq@nil{
    \pgfmathparse{\sseq@x+#1}
    \sseq@ifpgfmathresultisint{\edef\sseq@tempx{\@xp\sseq@uptopt\pgfmathresult\sseq@nil}}{\def\sseq@tempx{nope}}
    \pgfmathparse{\sseq@y+#2}
    \sseq@ifpgfmathresultisint{\edef\sseq@tempy{\@xp\sseq@uptopt\pgfmathresult\sseq@nil}}{\def\sseq@tempy{nope}}
    \sseq@tikzprimitive@getcoord@anchor#3.\sseq@nil
}
\def\sseq@tikzprimitive@getcoord@anchor#1.#2\sseq@nil{
    \def\sseq@tempn{#1}
    \ifx\sseq@nil#2\sseq@nil
        \def\sseq@tempanchor{}
    \else
        \edef\sseq@tempanchor{.\sseq@tikzprimitive@getcoord@anchor@eatdot#2}
    \fi
}
\def\sseq@tikzprimitive@getcoord@anchor@eatdot#1.{#1}



\def\sseq@scope{\@ifnextchar[{\sseq@scope@}{\sseq@scope@[]}}%]
\def\sseq@scope@[#1]{%
    \sseq@for@checkoptions{#1}%
    \sseq@scope@savedpaths@add{\begin{scope}}
    \def\sseq@savedoptioncode{}%
    \pgfqkeys{/sseqpages/scope}{#1}%
    \@xp\sseq@scope@savedpaths@add\@xp{\sseq@savedoptioncode\tikz@options}
}
\def\sseq@endscope{\sseq@scope@savedpaths@add{\end{scope}}}


%%%% Environment definitions
\sseq@addtostorelist\sseq@savedbackgroundpaths{}

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]{%
    \selectfont\nullfont % Avoid space hazards!
    \def\par{}
%
    \let\sseqset\sseqset@inprogress % Not sure if this is right/necessary. Probably is though.
    \sseq@keepchangestrue
    \sseq@storelist@setdefaults
%
    \ifx\sseq@xmin@default\sseq@infinity
        \let\sseq@xminmax\sseq@xminmax@active
    \fi
    \ifx\sseq@ymin@default\sseq@infinity
        \let\sseq@yminmax\sseq@yminmax@active
    \fi
%
    % copy commands into the user namespace.
    \sseq@copycommands{\class\replaceclass\d\structline\classoptions\doptions\structlineoptions\addtocontext}%
    \def\xmin{\sseq@xmin}\def\xmax{\sseq@xmax}
    \def\ymin{\sseq@ymin}\def\ymax{\sseq@ymax}
    \sseq@modtikzcommands % Defer evaluation of tikz primitives
    \sseq@patchfor % patch \foreach to work with deferred macros
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote} % install quotes parsing
%
%
    \pgfqkeys{/sseqpages/global/name only}{#1}
    \@ifundefined{sseq@thename}{\sseq@error{Every 'sseqdata' environment must have a name. Specify one by saying 'name=your sseq name'}{}}{}
    \sseq@obj@ifundef{exists}{
        \sseq@obj@gdef{exists}{}
        \pgfqkeys{/sseqpages/global}{{\sseq@thename} options/.code={}}
    }{
        \ifsseq@updateexisting
            \sseq@getcmds
        \else
            \sseq@error{A spectral sequence with the name '\sseq@thename' already exists.
                If you want to add to an already existing spectral sequence, please pass the option 'update existing'}
        \fi
    }
    \sseq@setsavedpaths{standard}
%
    % the default option handler for /sseqpages/global adds to \sseq@currentoptionpath options
    \let\sseq@currentoptionpath\sseq@thename
    \the\sseq@sseqstyle
    \pgfqkeys{/sseqpages/global}{#1}
    \sseq@savedpaths@xadd{\sseq@stylelist}
    \sseq@savedpaths@add{\begingroup} % prevent some of the two-pass user macros horrors
    %To give these options global scope we say \global\let\sseq@<name of sseq>options\sseq@<name of sseq>options
    \sseq@eval{
        \global\let\@xp\@nx\csname pgfk@/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname
            \@xp\@nx\csname pgfk@/sseqpages/global/{\sseq@thename} options/.@cmd\endcsname
    }
    \ifx\sseq@targetx\pgfutil@empty \let\d\sseq@d@error@nodegree \fi % Unless degree has a default, make \d be an error until a degree is set.
}

% Just store all the settings
\def\endsseqdata{
    % To fix the \classlabelstyle glitch:
    \sseq@obj@xdef{restorelabelstyles}{\sseq@labelstyle{\the\sseq@labelstyle}\sseq@classlabelstyle{\the\sseq@classlabelstyle}}
    \sseq@savedpaths@add{\endgroup} % prevent some of the two-pass user macros horrors
    \sseq@storecmds
}

\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %]

\def\sseqpage@[#1]{%
    \selectfont\nullfont % Avoid space hazards!
    \def\par{}
%
    \let\sseqset\sseqset@inprogress
    \sseq@ispageenvtrue
%
    \let\sseq@xminmax\sseq@xminmax@active
    \let\sseq@yminmax\sseq@yminmax@active
%
    % Copy commands into user namespace
    \sseq@copycommands{\class\replaceclass\classoptions\d\doptions\structline\structlineoptions\addtocontext}
    \def\xmin{\sseq@xmin}\def\xmax{\sseq@xmax}
    \def\ymin{\sseq@ymin}\def\ymax{\sseq@ymax}
    \sseq@modtikzcommands % Redefine tikz primitives to store themselves in the appropriate place
    \sseq@patchfor % Change foreach to record it's variable values in the appropriate places
    \pgfkeys{/handlers/first char syntax/the character "/.initial=\sseq@handlequote}% install quotes parsing
%
    \gdef\sseq@pagecleanup{}% For undoing local option settings
%
    \def\sseq@thepage{0}% page defaults to 0
    \pgfqkeys{/sseqpages/global/name only}{#1}% Get the name
    \ifsseq@hasname
        \sseq@obj@ifundef{exists}{
            \sseq@error{No spectral sequence named '\sseq@thename' exists}{}
        }{}
        \sseq@getcmds
        \ifsseq@keepchanges
            \sseq@setsavedpaths{standard}
        \else
            \sseq@setsavedpaths{temporary}
        \fi
    \else
        \def\sseq@thename{temp@sseq@number@\the\sseq@anonsseqcount}
        \global\advance\sseq@anonsseqcount1
        \sseq@storelist@setdefaults
        \sseq@setsavedpaths{temporary}
        \sseq@savedpaths@xadd{\sseq@stylelist}
        \pgfqkeys{/sseqpages/global}{{\sseq@thename} options/.code={}}
    \fi
    \sseq@savedpaths@add{\begingroup} % prevent some of the two-pass user macros horrors
    % To fix the \classlabelstyle glitch:
    \sseq@obj{restorelabelstyles}
    \def\sseq@currentoptionpath{this page}
    \pgfqkeys{/sseqpages/global}{{this page} options/.code={},#1}
%
    \ifx\sseq@targetx\pgfutil@empty \let\d\sseq@d@error@nodegree\fi
}

% Here we do all of the work to actually print the page
\def\endsseqpage{
    \sseq@savedpaths@add{\endgroup} % prevent some of the two-pass user macros horrors
    % Copied from tikzcd code. Pass quotes forward to edge and format edge label appropriately
    \ifx\sseq@xmin\sseq@infinity\sseq@error@range\fi
    \ifx\sseq@ymin\sseq@infinity\sseq@error@range\fi
    \pgfkeys{
      /tikz/edge quotes mean={
        edge node={node [/sseqpages/label,
                         /utils/exec={\sseq@thelabelstyle\sseq@theedgelabelstyle},
                         ##2,
                         /utils/exec={
                        %    \ifsseq@rotatelabels\iftikz@fullytransformed\else \tikz@fullytransformedtrue\tikz@addtransform{\pgftransformresetnontranslations\sseq@globalrotatetransform}\fi\fi
                             \sseq@edgeoptionhook
                        }
                   ]{##1}}}}
%
    \tikzset{
        z=0pt,
        every path/.style={},
        every node/.style={}
    }
    \begin{tikzpicture}[/sseqpages/global/{default} options,\ifsseq@hasname/sseqpages/global/{\sseq@thename} options\fi,/sseqpages/global/{this page} options]%
    \the\sseq@sseqstyle
    \the\sseq@pagestyle
    \pgftransformreset
    \sseq@globaldetonetransform
    \sseq@globalscaletransform
%
    \let\sseq@transform\sseq@error@illegaltransform % Disallow most coordinate transforms
    \let\sseq@shifttransform\sseq@checkshifttransform % Allow shifts as long as they are by integers and have no units.
%
    \pgfonlayer{background}
    \sseq@handlexaxis
    \sseq@handleyaxis
    \endpgfonlayer
%
    \ifnum\sseq@errormode>1\relax
        \let\errmessage\sseq@errmessage
    \fi
%
    \let\sseq@error\sseq@errorwithinfo
    \let\errmessage\sseq@errmessage
    \begingroup
    \sseq@savedbackgroundpaths
    \endgroup
%
    \sseq@clip
%
    \ifsseq@drawdifferentials\else
        \let\sseq@differential@draw@ifpage\@gobble
    \fi
    \ifsseq@drawstructlines\else
        \let\sseq@structline@draw@ifpage\@gobble
    \fi
%
    \sseq@usesavedpaths
%
    \end{tikzpicture}
    \ifsseq@keepchanges
        \sseq@storecmds   % store changes
    \else
        \sseq@pagecleanup % undo any changes specific to this page
    \fi
}

% Shorthand for sseqpage with empty body
\def\printpage[#1]{%
    \begin{sseqpage}[#1]
    \end{sseqpage}%
}

%% Draw axes and clip

\def\sseq@handlexaxis{
    \ifsseq@drawxaxis
        \bgroup
        \ifsseq@borderxaxis\else
            \let\sseq@ymin\sseq@yaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawxaxis
        \ifsseq@drawxaxislabels
            \sseq@drawxlabels
        \fi
        \egroup
    \fi
}
\def\sseq@handleyaxis{
    \ifsseq@drawyaxis
        \bgroup
        \ifsseq@borderyaxis\else
            \let\sseq@xmin\sseq@xaxisorigin % Warning: this is a stupid, lazy hack.
        \fi
        \sseq@drawyaxis
        \ifsseq@drawyaxislabels
            \sseq@drawylabels
        \fi
        \egroup
    \fi
}

\def\sseq@drawxaxis{
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    %
    \bgroup
    \pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}
    \egroup
    \bgroup
    \pgftransformxshift{-\sseq@yaxisgap}
    %\pgftransformxshift{-\sseq@ylabelgap}
    \pgftransformxshift{-\sseq@xaxis@start@extend}
    \pgftransformyshift{-\sseq@xaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}
    \egroup
    \egroup
    \pgfusepath{stroke}
}
\def\sseq@drawyaxis{
    \bgroup
    \pgftransformreset
    \sseq@globaldetonetransform
    \bgroup
    \pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}
    \egroup
    \bgroup
    \pgftransformyshift{-\sseq@xaxisgap}
    %\pgftransformyshift{-\sseq@xlabelgap}
    \pgftransformyshift{-\sseq@yaxis@start@extend}
    \pgftransformxshift{-\sseq@yaxisgap}
    \sseq@globalscaletransform
    \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}
    \egroup
    \egroup
    \pgfusepath{stroke}%
}

\def\sseq@drawxlabels{
    \sseq@tempy=\sseq@ymin\relax
    %\advance\sseq@tempy-1\relax
    \sseq@tempx=\sseq@xmax\relax
    \advance\sseq@tempx1\relax
    \edef\sseq@temp{\the\sseq@tempx}%
    \sseq@tempx=\sseq@xmin\relax
    \loop
        \bgroup
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformyshift{-\sseq@xlabelgap}\pgftransformyshift{-\sseq@xaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempx$}
        \egroup
        \advance\sseq@tempx\sseq@xlabelstep\relax
    \ifnum\sseq@tempx<\sseq@temp\repeat
}
\def\sseq@drawylabels{
    \sseq@tempx=\sseq@xmin\relax
    %\advance\sseq@tempx-1\relax
    \sseq@tempy=\sseq@ymax\relax
    \advance\sseq@tempy1\relax
    \edef\sseq@tempmax{\the\sseq@tempy}
    \sseq@tempy=\sseq@ymin\relax
    \loop
        %\node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
        \bgroup
        \pgftransformshift{\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}
        \pgftransformresetnontranslations
        \sseq@globaldetonetransform
        \pgftransformxshift{-\sseq@ylabelgap}\pgftransformxshift{-\sseq@yaxisgap}
        \pgftransformresetnontranslations
        \ifsseq@rotatelabels\sseq@globalrotatetransform\fi
        \pgftext{$\the\sseq@tempy$}%
        \egroup
        \advance\sseq@tempy\sseq@ylabelstep\relax
    \ifnum\sseq@tempy<\sseq@tempmax\repeat
}

\def\sseq@clip{
    %\clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
    \ifsseq@clip
        \ifx\sseq@customclip\pgfutil@empty
            \bgroup
            \pgftransformreset
            \sseq@globaldetonetransform
            \ifsseq@borderyaxis
                \def\xmin{\pgftransformxshift{-\sseq@yaxisgap}\pgftransformxshift{\sseq@yclip@axisgap}}
            \else
                \def\xmin{\pgftransformxshift{-\sseq@xaxis@start@extend}\pgftransformxshift{-\sseq@clip@padding@left}}
            \fi
            \ifsseq@borderxaxis
                \def\ymin{\pgftransformyshift{-\sseq@xaxisgap}\pgftransformyshift{\sseq@xclip@axisgap}}
            \else
                \def\ymin{\pgftransformyshift{-\sseq@yaxis@start@extend}\pgftransformyshift{-\sseq@clip@padding@bottom}}
            \fi
            \def\xmax{\pgftransformxshift{\sseq@xaxis@end@extend}\pgftransformxshift{\sseq@clip@padding@right}}
            \def\ymax{\pgftransformyshift{\sseq@yaxis@end@extend}\pgftransformyshift{\sseq@clip@padding@top}}
            \bgroup
            \xmin\ymin\sseq@globalscaletransform
            \pgfpathmoveto{\pgfpoint{\sseq@xmin cm}{\sseq@ymin cm}}
            \egroup
            \bgroup
            \xmin\ymax\sseq@globalscaletransform
            \pgfpathlineto{\pgfpoint{\sseq@xmin cm}{\sseq@ymax cm}}
            \egroup
            \bgroup
            \xmax\ymax\sseq@globalscaletransform
            \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymax cm}}
            \egroup
            \bgroup
            \xmax\ymin\sseq@globalscaletransform
            \pgfpathlineto{\pgfpoint{\sseq@xmax cm}{\sseq@ymin cm}}
            \egroup
            \egroup
            \pgfpathclose
            \pgfgetpath\sseq@theclippath % This stores the clipping so I can find intersections later
            \pgfusepath{clip}% This has to be after the egroup or else the clipping gets screwed up
        \else
            \def\sseq@temp{\clip[name path=temp]}
            \@xptwo\sseq@temp\@xp\@gobble\sseq@customclip
            \pgfgetpath\sseq@theclippath
            \let\sseq@theclippath\tikz@intersect@path@name@temp
        \fi
    \else
        \pgfgetpath\sseq@theclippath
    \fi
}

%%%% The main commands

%% First, \class and its buddies

\def\sseq@class{\@ifnextchar[{\sseq@class@}{\sseq@class@[]}}%}
\def\sseq@class@[#1](#2,#3){%
    \begingroup
    \def\sseq@temp{#1}
    \sseq@temptoks{#1}
    \sseq@temptoks@ii{(#2,#3)}
    \sseq@esetthiscall{\string\class\ifx\sseq@temp\pgfutil@empty\else[\the\sseq@temptoks]\fi\the\sseq@temptoks@ii}
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \def\sseq@savedoptioncode{}
    \sseq@for@checkoptions{#1}
    \pgfqkeys{/sseqpages/class}{#1}%
    \sseq@parsecoords\temp{#2,#3}%
    \sseq@temptoks\@xp{\sseq@classnodetext}%
    \sseq@eval{\@nx\sseq@class@@(\temp){\the\sseq@temptoks}}%
}
\def\sseq@class@@(#1,#2)#3{
    \sseq@tempx=#1\relax
    \advance\sseq@tempx\sseq@x\relax
    \sseq@tempy=#2\relax
    \advance\sseq@tempy\sseq@y\relax
    \edef\partialcoord{\the\sseq@tempx,\the\sseq@tempy}%
    \sseq@xminmax{\the\sseq@tempx}{\the\sseq@tempy}
    \sseq@yminmax{\the\sseq@tempx}{\the\sseq@tempy}
    \sseq@tempcount=\sseq@obj@ifundef{partcoord.(\partialcoord).numnodespp}{1}{\sseq@obj{partcoord.(\partialcoord).numnodespp}}%
    \edef\nodenum{\the\sseq@tempcount}%
    \ifsseq@hasname
        \ifsseq@keepchanges\else
            \ifnum\sseq@tempcount=1\relax
                \sseq@obj@gdef{partcoord.(\partialcoord).numnodes}{0}
                \sseq@obj@gdef{partcoord.(\partialcoord).numnodespp}{1}
            \fi
            \sseq@cleanup@obj{partcoord.(\partialcoord).numnodes}
            \sseq@cleanup@obj{partcoord.(\partialcoord).numnodespp}
        \fi
    \fi
%
    \sseq@obj@xdef{partcoord.(\partialcoord).numnodes}{\the\sseq@tempcount}
    \advance\sseq@tempcount1\relax
    \sseq@obj@xdef{partcoord.(\partialcoord).numnodespp}{\the\sseq@tempcount}
    \edef\coord{(\the\sseq@tempx,\the\sseq@tempy,\nodenum)}%
    \def\classname{class.\coord[0]}
%
    \sseq@obj@gdef{class.\coord.num}{0}% For \replaceclass
    \sseq@obj@new{\classname}
    \sseq@obj@xodef{\classname.options}{\sseq@savedoptioncode}
    \sseq@obj@xodef{\classname.nodetext}{\sseq@classnodetext}
    \sseq@obj@xodef{\classname.nodetext.options}{\sseq@classnodetextoptions}
    \sseq@obj@xodef{\classname.labelnodes}{\sseq@classlabelnodes}
    \sseq@obj@xdef{class.\coord.x}{\the\sseq@tempx}
    \sseq@obj@xdef{class.\coord.y}{\the\sseq@tempy}
    \sseq@obj@ifundef{\classname.dependencies}{\sseq@obj@gdef{\classname.dependencies}{}}{}
    \sseq@obj@xdef{\classname.needstikz}{\ifsseq@needstikz\@nx\sseq@needstikztrue\fi}
%
    \sseq@savedpaths@addclass{class.\coord}
    \sseq@obj@gdef{class.\coord.style}{}%
    \endgroup
}

\def\sseq@replaceclass{\@ifnextchar[{\sseq@replaceclass@}{\sseq@replaceclass@[]}}%}
\def\sseq@replaceclass@[#1](#2){%
    \begingroup
    \sseq@setthiscall{\replaceclass[#1](#2)}
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \def\sseq@savedoptioncode{}
    \sseq@for@checkoptions{#1}
    \pgfqkeys{/sseqpages/class}{#1}%
    \sseq@parsecommas(#2)%
    \sseq@replaceclass@@{#1}%
}

\def\sseq@replaceclass@@#1{%
    \sseq@arg@checkpresent\replaceclass1%
    \sseq@arg@checkpresent\replaceclass2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\sseq@n{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{replace class command '\sseq@thiscall'}
    \edef\coord{(\sseq@arg1,\sseq@arg2,\sseq@n)}%
    \edef\coordname{(\sseq@arg1,\sseq@arg2\sseq@optargc3)}%
    \sseq@ifundefcoord\coord{\sseq@error{There never was a class at \coordname\space so I cannot replace it}{}}{}
    \sseq@ifdead\coord{}{\sseq@error{I cannot replace the class at \coordname\space because it seems to be alive and well}{}}
    \sseq@cleanup@obj{class.\coord.num}
    \sseq@obj@inc{class.\coord.num}
    \edef\classname{class.\coord[\sseq@obj{class.\coord.num}]}
%
    \sseq@obj@new{\classname}
    \sseq@obj@xodef{\classname.options}{\sseq@savedoptioncode}
    \sseq@obj@xodef{\classname.nodetext}{\sseq@classnodetext}
    \sseq@obj@xodef{\classname.nodetext.options}{\sseq@classnodetextoptions}
    \sseq@obj@xodef{\classname.labelnodes}{\sseq@classlabelnodes}
    \sseq@obj@gdef{\classname.dependencies}{}
    \sseq@obj@xdef{\classname.needstikz}{\ifsseq@needstikz\@nx\sseq@needstikztrue\fi}
%
    \endgroup
}

\def\sseq@classoptions{\@ifnextchar[{\sseq@classoptions@}{\sseq@error{There is no reason to use \string\sseq@classoptions without giving options}{}}}%]
\def\sseq@classoptions@[#1](#2){%
    \begingroup
    \gdef\sseq@classnodetext{}
    \gdef\sseq@classnodetextoptions{}
    \gdef\sseq@classlabelnodes{}
    \sseq@setthiscall{\classoptions[#1](#2)}
    \let\sseq@savedoptioncode\sseq@savedcontext
    \let\sseq@for@checkoptions@add\sseq@d@addto@options
    \sseq@for@checkoptions{#1}
    \pgfqkeys{/sseqpages/class}{#1}%
    \sseq@parsecommas(#2)%
    \sseq@arg@checkpresent\replaceclass1%
    \sseq@arg@checkpresent\replaceclass2%
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@obj@ifundef{partcoord.(\the\sseq@tempx,\the\sseq@tempy).numnodes}{\sseq@error{No class in the specified position exists}{}}{}
    \sseq@whichclass\sseq@n{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{replace class command '\sseq@thiscall'}
    \edef\coord{(\the\sseq@tempx,\the\sseq@tempy,\sseq@n)}%
    \ifsseq@keepchanges\else
        \sseq@ifdead\coord{
            \ifnum\sseq@thepage>\sseq@getdeathpage\coord\relax
                \sseq@error{The node (#2) perished on page \sseq@getdeathpage\coord\sseq@macroname\ so there is no reason to add an option to it on page \sseq@thepage}{}%
            \fi
        }{}%
    \fi
    \edef\classname{class.\coord[\sseq@obj{class.\coord.num}]}
    \sseq@cleanup@obj{\classname.options}
    \sseq@obj@xoaddto{\classname.options}{\sseq@savedoptioncode}%
%
    \ifx\sseq@classnodetext\pgfutil@empty\else
        \sseq@cleanup@obj{\classname.nodetext}
        \sseq@obj@xodef{\classname.nodetext}{\sseq@classnodetext}
    \fi
    \ifx\sseq@classnodetextoptions\pgfutil@empty\else
        \sseq@cleanup@obj{\classname.nodetext.options}
        \sseq@obj@xoaddto{\classname.nodetext.options}{\sseq@classnodetextoptions}
    \fi
    \ifx\sseq@classlabelnodes\pgfutil@empty\else
        \sseq@cleanup@obj{\classname.labelnodes}
        \sseq@obj@xoaddto{\classname.labelnodes}{\sseq@classlabelnodes}
    \fi
    \endgroup
}

\def\sseq@class@draw@ifpage#1{
    \bgroup
    \sseq@tempcount=-1\relax
    \sseq@tempcountb=\sseq@obj{#1.num}\relax
    \loop
        \advance\sseq@tempcount1\relax
        \ifnum\sseq@obj{#1[\the\sseq@tempcount].page}>\sseq@thepage\relax
            \sseq@class@drawnode{#1[\the\sseq@tempcount]}
            \sseq@tempcount=\sseq@tempcountb\relax
        \else
            \ifnum\sseq@obj{#1[\the\sseq@tempcount].page}=\sseq@thepage\relax
                \sseq@thispagetrue
                \sseq@class@drawnode{#1[\the\sseq@tempcount]}
                \sseq@tempcount=\sseq@tempcountb\relax
            \fi
        \fi
    \ifnum\sseq@tempcount<\sseq@tempcountb\repeat
    \egroup
}

%% \d and \doptions
\bgroup\lccode`@=`\#\lccode`Y=`Y\lccode`S=`S \lowercase{\egroup
    \def\sseq@d@error@nodegree#1){%(
        \sseq@setthiscall\@xp{\string\d#1)}
        \sseq@error{
            You must specify the degree of your spectral sequence if you want to use the differential command \string\d.
            Specify the degree by providing 'degree={f(@1)}{g(@1)}' as an option to '\string\begin{sseqdata}',
            where f(@1) and g(@1) compute the x and y degree of the @1th page differential%
        }
    }
}
\def\sseq@d{\pgfutil@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}
\def\sseq@d@[#1]#2(#3){%
    \begingroup
    \sseq@tempcount=#2%
    \sseq@for@checkoptions{#1}%
    \def\sseq@savedoptioncode{}
    \pgfqkeys{/sseqpages/differential}{#1}%
    \sseq@temptoks{#1}
    \sseq@temptoks@ii{#2(#3)}
    \def\sseq@temp{#1}
    \sseq@esetthiscall{\string\d\ifx\sseq@temp\pgfutil@empty\else[\the\sseq@temptoks]\fi\the\sseq@temptoks@ii}
    \sseq@temptoks{\sseq@d@@{#1}}%
    \sseq@eval{\the\sseq@temptoks{\the\sseq@tempcount}}{#3}%
}

% #1 -- options
% #2 -- page
% #3 -- source coordinate
\def\sseq@d@@#1#2#3{%
    \sseq@dsetupsourceandtarget{#2}{#3}%
%
%   Errors:
    \sseq@ifundefcoord\source{%
        \sseq@error{%
            Source \sourcename\sseq@macroname\ of differential '\sseq@thiscall' can't support
            a differential because a class in that position never existed% TODO: make separate out of bounds index error message
        }{}%
    }{}%
    \sseq@ifundefcoord\target{%
        \sseq@error{%
            Target \targetname\sseq@macroname\ of differential '\sseq@thiscall' can't accept
            a differential because a class in that position never existed%
        }{}%
    }{}%
%
    \ifsseq@keepchanges
        \sseq@d@setpageminrec{class.\source}{#2}{source}
        \sseq@d@setpageminrec{class.\target}{#2}{target}
    \else
        \sseq@d@setpageminrectemp{class.\source}{#2}{source}
        \sseq@d@setpageminrectemp{class.\target}{#2}{target}
    \fi
%
    \ifnum\sseq@obj{partcoord.(\sourcecoord).numnodes}=1\relax\else
        \@ifundefined{sseq@arg3}{\sseq@error{%
            There are multiple nodes at source coordinate (\sourcecoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,n\sseq@optargc4)' where n specifies which of the
            \sseq@obj{partcoord.(\sourcecoord).numnodes} nodes at (\sourcecoord) should be the source%
        }{}}{}%
    \fi
    \ifnum\sseq@obj{partcoord.(\targetcoord).numnodes}=1\relax\else
        \@ifundefined{sseq@arg4}{\sseq@error{%
            There are multiple nodes at target coordinate (\targetcoord) so instead of '\sseq@thiscall' you should say
            '\string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(\sourcecoord,\sseq@optarg{}3,n)' where n specifies which of the
            \sseq@obj{partcoord.(\targetcoord).numnodes}\ nodes at (\targetcoord) should be the target%
        }{}}{}%
    \fi
%
    \sseq@obj@gdef{d.#2\source\target.page}{#2}
    \sseq@obj@gdef{d.#2\source\target.style}{}%
    \sseq@obj@xdef{d.#2\source\target.source}{\source}
    \sseq@obj@xdef{d.#2\source\target.target}{\target}
    \sseq@temptoks\@xp{\sseq@savedoptioncode}
    \sseq@obj@xdef{d.#2\source\target.options}{\ifsseq@needstikz\@nx\sseq@needstikztrue\fi\the\sseq@temptoks}
%
    \sseq@savedpaths@adddifferential{d.#2\source\target}%
%
    \endgroup
}

\def\sseq@doptions{\pgfutil@ifnextchar[{\sseq@doptions@}{\sseq@error{It's pointless to use '\string\doptions' without giving any options}}} %}
\def\sseq@doptions@[#1]#2(#3){%
    \begingroup
    \sseq@setthiscall{\doptions[#1]#2(#3)}
    \def\sseq@savedoptioncode{}
    \let\sseq@for@checkoptions@add\sseq@d@addto@options
    \sseq@for@checkoptions{#1}
    \pgfqkeys{/sseqpages/differential}{#1}%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@doptions@@{#1}}%
    \sseq@eval{\the\sseq@temptoks{\the\sseq@tempcount}}{#3}%
}
\def\sseq@doptions@@#1#2#3{%
    \sseq@dsetupsourceandtarget{#2}{#3}
    \sseq@obj@ifundef{d.#2\source\target.style}{\sseq@error{There is no differential of the form '\string\d#2(#3)' so I can't add options to it}{}}{}%
    \ifsseq@keepchanges\else
        \@ifundefined{sseq@thepage}{}{
            \ifnum\sseq@thepage=#2\relax\else\ifnum\sseq@thepage=0\else
                \sseq@error{Adding an option to a differential on page #2 when the current page is \sseq@thepage\sseq@macroname\ has no effect}{}%
            \fi\fi
        }%
    \fi
%
    \sseq@cleanup@obj{d.#2\source\target.options}
    \sseq@obj@xoaddto{d.#2\source\target.options}{\sseq@savedoptioncode}
    \endgroup
}

% Some helper macros:
\def\sseq@dsetupsourceandtarget#1#2{
    \sseq@parsecommas(#2)
    \sseq@arg@checkpresent\d1
    \sseq@arg@checkpresent\d2
    \sseq@tempx=\sseq@x
    \advance\sseq@tempx\sseq@arg1\relax
    \sseq@tempy=\sseq@y
    \advance\sseq@tempy\sseq@arg2\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}3}{source of differential '\sseq@thiscall'}
    \edef\sourcecoord{\the\sseq@tempx,\the\sseq@tempy}
    \edef\sourcename{(\sourcecoord\sseq@optargc3)}
    \edef\source{(\sourcecoord,\tempn)}
%
    \pgfmathparse{int(\the\sseq@tempx+\sseq@targetx{#1})}
    \sseq@tempx=\pgfmathresult\relax
    \pgfmathparse{int(\the\sseq@tempy+\sseq@targety{#1})}
    \sseq@tempy=\pgfmathresult\relax
    \sseq@whichclass\tempn{\the\sseq@tempx}{\the\sseq@tempy}{\sseq@optarg{}4}{target of differential '\sseq@thiscall'}
    \edef\targetcoord{\the\sseq@tempx,\the\sseq@tempy}
    \edef\targetname{(\targetcoord\sseq@optargc4)}
    \edef\target{(\targetcoord,\tempn)}
}

\def\sseq@d@setpageminrec#1#2#3{% not really recursive.
    \sseq@d@setpageclass{#1}{#2}{#3}
    \sseq@obj@map{#1[\sseq@obj{#1.num}].dependencies}{
        \sseq@d@setpagemin{##1}{#2}
    }
}
\def\sseq@d@setpageminrectemp#1#2#3{
    \sseq@cleanup@obj{#1[\sseq@obj{#1.num}].page}
    \sseq@cleanup@obj{#1[\sseq@obj{#1.num}].deathinfo}
    \sseq@cleanup@obj{#1[\sseq@obj{#1.num}].deathinputline}
    \sseq@d@setpageclass{#1}{#2}{#3}
    \sseq@obj@map{#1[\sseq@obj{#1.num}].dependencies}{
        \sseq@cleanup@obj{##1.page}
        \sseq@d@setpagemin{##1}{#2}
    }
}

\def\sseq@d@setpageclass#1#2#3{
    \edef\sseq@temp{#1[\sseq@obj{#1.num}]}
    \ifnum\sseq@obj{\sseq@temp.page}<\sseq@infinity\relax
        \ifnum\sseq@obj{\sseq@temp.page}>#2\relax
            \sseq@temptoks\@xpthree{\sseq@obj{\sseq@temp.deathinputline}}
            \edef\sseq@temp{\the\sseq@temptoks}
            \edef\sseq@temp@ii{\sseq@errorinfo}
            \ifx\sseq@temp\sseq@temp@ii
                \sseq@temptoks\@xpthree{\sseq@obj{\sseq@temp.deathinfo} (in the same \foreach loop)}
            \else
                \sseq@temptoks@ii\@xpthree{\sseq@obj{\sseq@temp.deathinfo}}
                \sseq@eval{\sseq@temptoks{\the\sseq@temptoks@ii\space(\the\sseq@temptoks)}}
            \fi
            \sseq@errornoinfo{%
                The #3 \csname #3name\endcsname\space of differential \sseq@thiscall\space on page #2 (\sseq@errorinfo)
                has already been the \the\sseq@temptoks.
                First use the shorter differential, then \string\replaceclass\csname #3name\endcsname, then the longer differential
            }
        \fi
        \ifnum\sseq@obj{\sseq@temp.page}<#2\relax
            \sseq@temptoks\@xpthree{\sseq@obj{\sseq@temp.deathinputline}}
            \edef\sseq@temp{\the\sseq@temptoks}
            \edef\sseq@temp@ii{\sseq@errorinfo}
            \ifx\sseq@temp\sseq@temp@ii
                \sseq@temptoks\@xpthree{\sseq@obj{\sseq@temp.deathinfo} (in the same \foreach loop)}
            \else
                \sseq@temptoks@ii\@xpthree{\sseq@obj{\sseq@temp.deathinfo}}
                \sseq@eval{\sseq@temptoks{\the\sseq@temptoks@ii\space(\the\sseq@temptoks)}}
            \fi
            \sseq@errornoinfo{%
                The #3 \csname #3name\endcsname\space of differential \sseq@thiscall\space on page #2 (\sseq@errorinfo)
                has already been the \the\sseq@temptoks.
                Use \string\replaceclass\csname #3name\endcsname\space before \sseq@thiscall
            }
        \fi
    \fi
    \ifnum\sseq@obj{#1.num}>0\relax
        \sseq@tempcount=\sseq@obj{#1.num}\relax
        \advance\sseq@tempcount-1\relax
        \ifnum\sseq@obj{#1[\the\sseq@tempcount].page}<#2\relax\else
            \sseq@error{The #3 \csname #3name\endcsname\space of differential \sseq@thiscall\space was the \sseq@obj{#1[\the\sseq@tempcount].deathinfo}.
            \ifnum#2=\sseq@obj{#1[\the\sseq@tempcount].page}
                If multiple differentials touch a class on the same page, they cannot be separated by a \@nx\replaceclass command%
            \else
                The differentials that touch a class must be ordered in increasing length%
            \fi
            }
        \fi

    \fi
    \sseq@obj@xdef{\sseq@temp.page}{#2}
    \sseq@obj@xdef{\sseq@temp.deathinfo}{#3 of differential \sseq@thiscall\space on page #2}
    \sseq@obj@xdef{\sseq@temp.deathinputline}{\sseq@errorinfo}
}

\def\sseq@d@setpagemin#1#2{
    \ifnum\sseq@obj{#1.page}>#2\relax
        \sseq@obj@xdef{#1.page}{#2}
    \fi
}

\def\sseq@differential@draw@ifpage#1{
    \ifnum\sseq@thepage=0\relax
        \sseq@drawdifferential{#1}
    \else
        \ifnum\sseq@obj{#1.page}=\sseq@thepage\relax
            \sseq@drawdifferential{#1}
        \fi
    \fi
}

\def\sseq@drawdifferential#1{
    \bgroup
    \sseq@eval{
        \@nx\sseq@drawedge\sseq@obj{#1.source}\sseq@obj{#1.target}{differential}{%
            \@xptwo\@nx\sseq@obj{#1.options}
        }
    }
    \egroup
}

%% \structline and \structlineoptions
\def\sseq@structline{\@ifnextchar[{\sseq@structline@}{\sseq@structline@[]}}%]
\def\sseq@structline@[#1](#2)(#3){
    \begingroup
    \def\sseq@temp{#1}
    \sseq@temptoks{#1}
    \sseq@temptoks@ii{(#2)(#3)}
    \sseq@esetthiscall{\string\structline\ifx\sseq@temp\pgfutil@emptytoks\else[\the\sseq@temptoks]\fi\the\sseq@temptoks@ii}
    \def\sseq@savedoptioncode{}
    \sseq@for@checkoptions{#1}
    \pgfqkeys{/sseqpages/struct line}{#1}
    \sseq@eval{\@nx\sseq@structline@@{#2}{#3}}
}
\def\sseq@structline@@#1#2{
    \def\sseq@thiscmdname{structure line }% To pass error information to \sseq@whichclass%
    \sseq@parsecoords\source{#1}
    \sseq@parsecoords\target{#2}
    \sseq@eval{
        \@nx\sseq@structline@@@
            \@xp\sseq@iffullcoord\@xp(\source){(\source)}{(\source,)}%
            \@xp\sseq@iffullcoord\@xp(\target){(\target)}{(\target,)}
    }
    \endgroup
}

\def\sseq@structline@@@(#1,#2,#3)(#4,#5,#6){
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#4\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#5\relax
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source of structure line '\sseq@thiscall'}%
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#6}{target of structure line '\sseq@thiscall'}%
    \edef\source{(\the\sseq@tempx,\the\sseq@tempy,\sseq@na)}
    \edef\target{(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)}
    \sseq@eval{\@nx\sseq@obj@newstructline{\source}{\target}}
    \sseq@temptoks\@xp{\sseq@savedoptioncode}
    \sseq@obj@xdef{structline.\source\target.options}{\ifsseq@needstikz\@nx\sseq@needstikztrue\fi\the\sseq@temptoks}
}

\def\sseq@obj@newstructline#1#2{
    \sseq@obj@xdef{structline.#1#2.page}{\sseq@infinity}
    \sseq@obj@xdef{structline.#1#2.source}{#1}
    \sseq@obj@xdef{structline.#1#2.target}{#2}
    \sseq@obj@adddependence{class.#1}{structline.#1#2}
    \sseq@obj@adddependence{class.#2}{structline.#1#2}
    \sseq@savedpaths@addstructline{structline.#1#2}
}

\def\sseq@obj@adddependence#1#2{
    \sseq@obj@ifundef{#1.num}{
        \sseq@obj@gdef{#1[0].dependencies}{\\{#2}}
    }{
        \sseq@obj@gaddtolist{#1[\sseq@obj{#1.num}].dependencies}{#2}
        \sseq@d@setpagemin{#2}{\sseq@obj{#1[\sseq@obj{#1.num}].page}}
    }
}

\def\sseq@structline@draw@ifpage#1{
    \bgroup
    \ifnum\sseq@obj{#1.page}>\sseq@thepage\relax
        \sseq@structline@draw{#1}
    \else
        \ifnum\sseq@obj{#1.page}=\sseq@thepage\relax
            \sseq@thispagetrue
            \sseq@structline@draw{#1}
        \fi
    \fi
    \egroup
}
\def\sseq@structline@draw#1{\sseq@eval{\@nx\sseq@drawedge\sseq@obj{#1.source}\sseq@obj{#1.target}{structline}{\@nx\sseq@obj{#1.options}}}}

\def\sseq@structlineoptions[#1](#2)(#3){
    \begingroup
    \sseq@setthiscall{\sseq@structlineoptions[#1](#2)(#3)}
    \sseq@for@checkoptions{#1}
    \def\sseq@savedoptioncode{}
    \pgfqkeys{/sseqpages/struct line}{#1}
    \sseq@parsecoords\source{#2}
    \sseq@parsecoords\target{#3}
    \sseq@eval{
        \@nx\sseq@structlineoptions@
            \@xp\sseq@iffullcoord\@xp(\source){(\source)}{(\source,)}
            \@xp\sseq@iffullcoord\@xp(\target){(\target)}{(\target,)}
    }
    \endgroup
}
\def\sseq@structlineoptions@(#1,#2,#3)(#4,#5,#6){
    \sseq@tempx=\sseq@x\relax\advance\sseq@tempx#1\relax
    \sseq@tempy=\sseq@y\relax\advance\sseq@tempy#2\relax
    \sseq@tempxb=\sseq@x\advance\sseq@tempxb#4\relax
    \sseq@tempyb=\sseq@y\advance\sseq@tempyb#5\relax
    \sseq@whichclass\sseq@na{\the\sseq@tempx}{\the\sseq@tempy}{#3}{source of structure line '\sseq@thiscall'}
    \sseq@whichclass\sseq@nb{\the\sseq@tempxb}{\the\sseq@tempyb}{#6}{target of structure line '\sseq@thiscall'}
%
    \edef\source{(\the\sseq@tempx,\the\sseq@tempy,\sseq@na)}
    \edef\target{(\the\sseq@tempxb,\the\sseq@tempyb,\sseq@nb)}
    \sseq@obj@ifundef{structline.\source\target.page}{
        \sseq@error{Cannot add options to struct line \source--\target because such a struct line doesn't exist}{}
    }{}
    \sseq@cleanup@obj{structline.\source\target.options}
    \ifsseq@needstikz
        \sseq@obj@gaddto{structline.\source\target.options}{\sseq@needstikztrue}
    \fi
    \sseq@obj@xoaddto{structline.\source\target.options}{\sseq@savedoptioncode}
}


%%%% The drawing department

%% Class offsets
\def\sseq@setstdoffsets#1#2#3#4{\@xp\def\csname sseq@stdxoffset#1/#2\endcsname{#3}\@xp\def\csname sseq@stdyoffset#1/#2\endcsname{#4}}

\sseq@setstdoffsets11{0}{0}

\sseq@setstdoffsets12{-0.13}{0}
\sseq@setstdoffsets22{0.13}{0}

\sseq@setstdoffsets13{-0.2}{0}
\sseq@setstdoffsets23{0}{0}
\sseq@setstdoffsets33{0.2}{0}

\sseq@setstdoffsets14{-0.13}{-0.13}
\sseq@setstdoffsets24{0.13}{-0.13}
\sseq@setstdoffsets34{-0.13}{0.13}
\sseq@setstdoffsets44{0.13}{0.13}

\sseq@setstdoffsets15{-0.16}{-0.16}
\sseq@setstdoffsets25{0.16}{-0.16}
\sseq@setstdoffsets35{-0.16}{0.16}
\sseq@setstdoffsets45{0.16}{0.16}
\sseq@setstdoffsets55{0}{0}

\sseq@setstdoffsets16{-0.13}{-0.2}
\sseq@setstdoffsets26{-0.13}{0}
\sseq@setstdoffsets36{-0.13}{0.2}
\sseq@setstdoffsets46{0.13}{-0.2}
\sseq@setstdoffsets56{0.13}{0}
\sseq@setstdoffsets66{0.13}{0.2}

\def\sseq@offset#1#2{
    \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{0\csname sseq@stdxoffset#1/#2\endcsname cm}{0\csname sseq@stdyoffset#1/#2\endcsname cm}}}
}

\def\sseq@class@getparts#1(#2,#3,#4)[#5].{
    \def\sseq@error@annotation{.^^J(Error occurred while drawing class (#2,#3,#4)\ifnum#5>0 \space which has been replaced #5 time\ifnum#5>1s\fi\fi.
        Look for a \ifnum#5>0\string\replaceclass\else\string\class\fi\space command that makes a class at that position.
        Also make sure to check any \@nx\classoptions commands that could be the culprit.)}
    \def\sseq@thisclassname{class.(#2,#3,#4)}
    \def\sseq@thisnodename{sseq{#2,#3,#4}}
    \def\sseq@thispos{(#2,#3)}
    \def\sseq@thisposnum{#4}
    \def\sseq@thisclassnum{#5}
}

% #1 -- the name of the node object
\def\sseq@class@drawnode#1{%
    \begingroup
    \sseq@class@getparts#1.
    \sseq@tempx=\sseq@obj{\sseq@thisclassname.x}\relax
    \sseq@tempy=\sseq@obj{\sseq@thisclassname.y}\relax
    \sseq@needstikzfalse
    \sseq@options@firstpassmode
        \sseq@thepathstyle
        \sseq@theclassstyle
        \ifnum\sseq@obj{#1.page}=\sseq@infinity\relax
            \sseq@thepermanentcyclestyle
        \else
            \sseq@thetransientcyclestyle
            \ifsseq@thispage
                \sseq@thethispagecyclestyle
            \fi
        \fi
        \sseq@obj{#1.needstikz}
%
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
        \sseq@outofrangefalse
        \pgfscope
        \let\tikz@options\pgfutil@empty
        \let\tikz@alias=\pgfutil@empty
        \def\pgfkeysdefaultpath{/sseqpages/class/}
        \sseq@options@secondpassmode
            \sseq@thepathstyle
            \sseq@theclassstyle
            \ifnum\sseq@obj{#1.page}=\sseq@infinity\relax
                \sseq@thepermanentcyclestyle
            \else
                \sseq@thetransientcyclestyle
                \ifsseq@thispage
                    \sseq@thethispagecyclestyle
                \fi
            \fi
            \sseq@obj{#1.options}%
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{-\the\sseq@x cm}{-\the\sseq@y cm}}}
        \iftikz@fullytransformed\pgfgettransform{\savetransform}\fi
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
        \iftikz@fullytransformed\pgfsettransform{\savetransform}\else\pgftransformresetnontranslations\ifsseq@rotatelabels\sseq@globalrotatetransform\fi\fi
        \tikz@options
        \ifsseq@needstikz
            \let\sseq@mode\tikz@mode
            \sseq@temptoks\@xpthree{\sseq@obj{#1.nodetext}}
            \tikzset{every text node part/.code/.expand once={\sseq@globalrotatetransform\sseq@obj{#1.nodetext.options}}}%
            \sseq@eval{%
                \@nx\node[/utils/exec={\let\@nx\tikz@mode\@nx\sseq@mode},
                    /handlers/first char syntax/the character "/.initial=\@nx\sseq@handlequote
                ] (\sseq@thisnodename) {\the\sseq@temptoks}
                [every text node part/.code={}]
                \@nx\sseq@obj{#1.labelnodes};
            }%
        \else
            \tikz@node@textfont
            \edef\sseq@classnodetextoptions{\@xptwo\@nx\sseq@obj{#1.nodetext.options}}
            \edef\sseq@classnodetext{\@xptwo\@nx\sseq@obj{#1.nodetext}}
            \sseq@setnodetext
            \let\tikz@fig@name\sseq@thisnodename
            \pgfmultipartnode{\tikz@shape}{\tikz@anchor}{\tikz@fig@name}{\sseq@drawnode}%
            \tikz@alias
            \sseq@obj{#1.labelnodes}
        \fi
        \endpgfscope
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{\the\sseq@tempx cm}{\the\sseq@tempy cm}}}%
        \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{-\the\sseq@x cm}{-\the\sseq@y cm}}}
        \pgftransformresetnontranslations
        \sseq@globalrotatetransform
        \sseq@classplacementtransform
        \sseq@offset{\sseq@thisposnum}{\sseq@obj{partcoord.\sseq@thispos.numnodes}}
        \pgfcoordinate{\sseq@thisnodename}{\pgfpointorigin}%
    \fi
    \endgroup
}

\def\sseq@setnodetext{%
    \setbox\pgfnodeparttextbox=\hbox{%
        \pgfscope%
        \tikzset{every text node part/.try}%
        \sseq@classnodetextoptions
        \ifx\tikz@textopacity\pgfutil@empty%
        \else%
         \pgfsetfillopacity{\tikz@textopacity}%
          \pgfsetstrokeopacity{\tikz@textopacity}%
        \fi%
        \pgfinterruptpicture
      \ifx\tikz@text@width\pgfutil@empty%
        \tikz@textfont%
      \else%
        \begingroup%
        	\pgfmathsetlength{\pgf@x}{\tikz@text@width}%
          \pgfutil@minipage[t]{\pgf@x}\leavevmode\hbox{}%
            \tikz@textfont%
            \tikz@text@action%
      \fi%
        \ifx\tikz@textcolor\pgfutil@empty%
        \else%
          \pgfutil@colorlet{.}{\tikz@textcolor}%
        \fi%
        \pgfsetcolor{.}%
          \tikz@atbegin@node%
          \sseq@classnodetext%
          \tikz@atend@node%
           \ifx\tikz@text@width\pgfutil@empty%
           \else%
              \pgfutil@endminipage%
            \endgroup%
          \fi%
          \endpgfinterruptpicture
      \endpgfscope%
    }%
    \ifx\tikz@text@width\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@width}%
      \wd\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@height\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@height}%
      \ht\pgfnodeparttextbox=\pgf@x%
    \fi%
    \ifx\tikz@text@depth\pgfutil@empty%
    \else%
      \pgfmathsetlength{\pgf@x}{\tikz@text@depth}%
      \dp\pgfnodeparttextbox=\pgf@x%
    \fi%
}

\def\sseq@drawnode{%
  \pgfutil@tempdima=\pgflinewidth%
  {%
    \tikz@mode%
    %\iftikz@mode@clip \sseq@error@internal{Clip shouldn't happen here, but this error should be caught earlier}{}\fi %
    \iftikz@mode@draw%
        \iftikz@mode@double%
        % Change line width
            \begingroup%
            \pgfsys@beginscope%
            \tikz@double@setup%
        \fi%
    \fi%
    %
    % Step 10: Do stroke/fill as needed
    %
    \sseq@eval{\noexpand\pgfusepath{%
        \iftikz@mode@fill fill,\fi%
        \iftikz@mode@draw draw,\fi%
    }}%
    %
    % Step 11: Double stroke, if necessary
    %
    \iftikz@mode@draw%
        \iftikz@mode@double%
            \pgfsys@endscope%
            \endgroup%
        \fi%
    \fi
  }%
  \global\pgflinewidth=\pgfutil@tempdima%
}


%% Drawing edges

\pgfdeclarearrow{
    name = ...,
    parameters = { \the\pgfarrowlength\the\pgflinewidth},
    setup code = {
        % The different end values:
        \pgfarrowssetlineend{-\pgfarrowlength}
        \pgfarrowssetbackend{-0.6\pgfarrowlength}
        % The hull
        \pgfarrowshullpoint{-\pgfarrowlength}{0pt}
        \pgfarrowshullpoint{\pgfarrowlength}{0pt}
        % Saves: Only the length:
        \pgfarrowssavethe\pgfarrowlength
        \pgfarrowssavethe\pgflinewidth
    },
    drawing code = {
        \pgfpathcircle{\pgfpoint{-0.7\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.4\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathcircle{\pgfpoint{-0.1\pgfarrowlength}{0pt}}{1.5\pgflinewidth}
        \pgfpathclose
        \pgfusepathqfill
    },
    defaults = { length = 0.3cm }
}

\def\sseq@ifinrange(#1){\sseq@ifinrange@#1,\sseq@nil}
\def\sseq@ifinrange@#1,#2,#3\sseq@nil{%
    \sseq@tempx=#1\relax\sseq@tempy=#2\relax
    \sseq@outofrangetrue
    \ifnum\sseq@tempx<\sseq@xmaxpp\relax\ifnum\sseq@tempx>\sseq@xminmm\relax\ifnum\sseq@tempy<\sseq@ymaxpp\relax\ifnum\sseq@tempy>\sseq@yminmm\relax
    \sseq@outofrangefalse
    \fi\fi\fi\fi
    \ifsseq@outofrange
        \@xp\pgfutil@secondoftwo
    \else
        \@xp\pgfutil@firstoftwo
    \fi
}

\sseq@addtostorelist\sseq@runoffarrow@start@differential@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@end@differential@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@start@structline@spec{...}
\sseq@addtostorelist\sseq@runoffarrow@end@structline@spec{...}

% #1 -- source (full)
% #2 -- target (full)
% #3 -- which type of edge (either "structline" or "differential")
% #4 -- options
\def\sseq@drawedge(#1)(#2)#3#4{
    \begingroup\pgfscope
    \let\sseq@edgesourceanchor\pgfutil@empty
    \let\sseq@edgetargetanchor\pgfutil@empty
%
    \sseq@needstikzfalse
    \def\pgfkeysdefaultpath{/sseqpages/#3/}
    \sseq@options@bothpassmode
    \sseq@thepathstyle\sseq@theedgestyle\csname sseq@the#3style\endcsname
    #4%
    \sseq@eval{\@nx\pgftransformshift{\@nx\pgfpoint{-\the\sseq@x cm}{-\the\sseq@y cm}}}
    % First calculate actual start and end of the edge
    \let\tempaf\pgfutil@empty
    \@xp\ifx\csname pgf@sh@pi@sseq{#1}\endcsname\pgfpictureid % Check if source is a named coordinate
        \ifx\sseq@edgesourceanchor\pgfutil@empty % Check that the source doesn't have a specified anchor
            \def\tempa{\pgfpointanchor{sseq{#1}}{center}}% if so, start by taking the center of that coordinate
        \else
            \edef\tempa{\@nx\pgfpointanchor{sseq{#1}}{\sseq@edgesourceanchor}} % If it has an anchor, use that
            \let\tempaf\tempa
        \fi
    \else
        \ifx\sseq@edgesourceanchor\pgfutil@empty\else % if the source isn't a named coordinate, we shouldn't have a source anchor
            \sseq@error{You specified a source anchor to the #3 between (#1) and (#2), but the source (#1) is not a node}
        \fi
        \edef\tempa{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#1)}% if the source isn't a named coordinate just take the coordinate in question
        \let\tempaf\tempa
    \fi
    \@xp\ifx\csname pgf@sh@pi@sseq{#2}\endcsname\pgfpictureid % Check if the target is a named coordinate
        \ifx\sseq@edgetargetanchor\pgfutil@empty % check that the target doesn't have a specified anchor
            \def\tempb{\pgfpointshapeborder{sseq{#2}}{\tempa}}% if so, our end point is the point on the boundary of node b that is in the direction of our initial start coordinate
        \else
            \edef\tempb{\@nx\pgfpointanchor{sseq{#2}}{\sseq@edgetargetanchor}}% If it has a specified anchor, use that
        \fi
    \else
        \ifx\sseq@edgetargetanchor\pgfutil@empty\else
            \sseq@error{You specified a target anchor to the #3 between (#1) and (#2), but the target (#2) is not a node}
        \fi
        \edef\tempb{\@nx\pgfpoint\sseq@fullcoord@to@partialcoordb(#2)}% if the targt is not a node, just use the coordinate
    \fi
    \let\tempbf\tempb
    \ifx\tempaf\pgfutil@empty
        \def\tempaf{\pgfpointshapeborder{sseq{#1}}{\tempb}}
    \fi
%
    \tikz@options
    \tikz@mode
    \pgfpathmoveto{\tempaf}
    \pgfpathlineto{\tempbf}
    \pgfgetpath\thispath
    \pgfusepath{discard}
    \sseq@ifinrange(#1){\sseq@ifinrange(#2){\sseq@outofrangefalse}{\sseq@outofrangetrue}}{\sseq@outofrangetrue}
    \ifsseq@outofrange
        \pgfintersectionofpaths{\pgfsetpath\sseq@theclippath}{\pgfsetpath\thispath}
    \else
        \def\pgfintersectionsolutions{0}
    \fi
    \def\temparrowstartspec{}
    \def\temparrowendspec{}
    \pgfcoordinate{tempa}{\tempaf}
    \pgfcoordinate{tempb}{\tempbf}
    \pgftransformreset
    \ifcase\pgfintersectionsolutions\relax
    \or
        \sseq@ifinrange(#1){
            \def\tempbf{\pgfpointintersectionsolution{1}}
            \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
            \pgfcoordinate{tempb}{\tempbf}
        }{
            \def\tempaf{\pgfpointintersectionsolution{1}}
            \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}
            \pgfcoordinate{tempa}{\tempaf}
        }
    \or
        \ifsseq@draworphanedges
            \def\tempaf{\pgfpointintersectionsolution{1}}
            \def\tempbf{\pgfpointintersectionsolution{2}}
            \edef\temparrowstartspec{\@nx\pgfsetarrowsstart{\csname sseq@runoffarrow@start@#3@spec\endcsname}}
            \edef\temparrowendspec{\@nx\pgfsetarrowsend{\csname sseq@runoffarrow@end@#3@spec\endcsname}}
            \pgfcoordinate{tempa}{\tempaf}
            \pgfcoordinate{tempb}{\tempbf}
        \else
            \sseq@drawedgefalse % Don't draw "orphaned edges"
        \fi
    \else
        \sseq@error{This shouldn't happen.}
    \fi
    \ifsseq@drawedge
        % TODO: should some sort of transformation manipulation be here? Maybe allow user to specify preference?
        % Don't draw dots on very short segments
        \tempbf\pgf@xa=\pgf@x\pgf@ya=\pgf@y
        \tempaf\advance\pgf@xa-\pgf@x\advance\pgf@ya-\pgf@y
        \pgfmathveclen{\pgf@xa}{\pgf@ya}
        \@xp\pgfmathint\@xp{\pgfmathresult}
        \ifnum\pgfmathresult<10\relax%%17? % TODO: Fix this predicate
            \tikzset{every text node part/.append code={\pgfsetcolor{white}}}
            \ifx\temparrowstartspec\pgfutil@empty
            \else
                \def\temparrowstartspec{\pgfsetarrowsstart{}}
            \fi
            \ifx\temparrowendspec\pgfutil@empty
            \else
                \def\temparrowendspec{\pgfsetarrowsend{}}
            \fi
        \fi
        \ifsseq@needstikz
            \sseq@eval{\@nx\draw[/sseqpages,
                /utils/exec={\@xp\@nx\temparrowstartspec\@xp\@nx\temparrowendspec}
            ]  (\@xp\ifx\csname pgf@sh@pi@sseq{#1}\endcsname\pgfpictureid sseq\fi{#1}\ifx\sseq@edgesourceanchor\pgfutil@empty\else.\sseq@edgesourceanchor\fi)
            to (\@xp\ifx\csname pgf@sh@pi@sseq{#2}\endcsname\pgfpictureid sseq\fi{#2}\ifx\sseq@edgetargetanchor\pgfutil@empty\else.\sseq@edgetargetanchor\fi);}
        \else
            \temparrowstartspec
            \temparrowendspec
            \pgfpathmoveto{\pgfpointanchor{tempa}{center}}
            \pgfpathlineto{\pgfpointanchor{tempb}{center}}
            \sseq@eval{\noexpand\pgfusepath{
                \iftikz@mode@fill fill,\fi
                \iftikz@mode@draw draw,\fi
            }}
        \fi
    \fi
    \endpgfscope\endgroup
}
