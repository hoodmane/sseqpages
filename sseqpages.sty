\ProvidesPackage{sseqpages}
\RequirePackage{tikz}
\RequirePackage{environ}
\RequirePackage{etoolbox}

\usetikzlibrary{quotes}
\usepackage{trace}

% Ensure \@xp and \@nx have the correct values in the (unlikely) case that amsmath isn't loaded
\let\@xp\expandafter
\let\@nx\noexpand

\def\sseq@macroname{\@xp\@gobble\string}

% Declarations
\newtoks\sseq@temptoks
\newtoks\sseq@temptoks@ii
\newtoks\sseq@thepermcyclestyle
\newtoks\sseq@thetranscyclestyle
\newcount\sseq@tempcount
\newcount\sseq@featurecount



\def\sseq@error{\PackageError{sseqpages}}
\def\sseq@nil{\sseq@thisshouldnthappen@nil} % This expansion text should be unique so that \ifx\sseq@nil\undefinedcommand is false.
\def\sseq@infinity{10000} % Larger than any coordinate anyone will ever use (hopefully).


% My own version of \pgfutil@g@addtomacro. Checks if the macro is undefined and handles that case correctly too.
\def\sseq@g@addto@macro#1{\@ifundefined{\sseq@macroname#1}{\gdef#1}{\sseq@g@addto@macro@#1}}
\let\sseq@g@addto@macro@\pgfutil@g@addto@macro
\def\sseq@x@addto@macro#1{\@ifundefined{\sseq@macroname#1}{\xdef#1}{\sseq@x@addto@macro@#1}}
\def\sseq@x@addto@macro@#1#2{\begingroup\pgfutil@toks@\@xp{#1}\xdef#1{\the\pgfutil@toks@#2}\endgroup}


%% Command redefinition commands

% Try to copy to \<commandname> a command of the form \sseq@data@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copydatacommands#1{\sseq@copydatacommands@#1\sseq@nil}
\def\sseq@copydatacommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@data@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@data@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copydatacommands@ %
    \fi %
}

% Try to copy to \<commandname> a command of the form \sseq@page@<commandname>, if that doesn't exist then use \sseq@<command name>
\def\sseq@copypagecommands#1{\sseq@copypagecommands@#1\sseq@nil}
\def\sseq@copypagecommands@#1{%
    \ifx#1\sseq@nil\else %
        \@ifundefined{sseq@page@\sseq@macroname#1}%
            {\@xp\let\@xp#1\csname sseq@\sseq@macroname#1\endcsname}%
            {\@xp\let\@xp#1\csname sseq@page@\sseq@macroname#1\endcsname}%
        \@xp\sseq@copypagecommands@ %
    \fi %
}

% Replace a tikz command with a command that saves the command on savedpaths
\def\sseq@modtikzcommands{%
    \let\scope\sseq@scope                   %
    \let\endscope\sseq@endscope             %
    \sseq@modtikzcommands@                  %
        \clip\coordinate\draw\fill\filldraw %
        \graph\matrix\node\path\pattern     %
        \shade\shadedraw\useasboundingbox   %
    \sseq@nil                                   %
}
\def\sseq@modtikzcommands@#1{\ifx#1\sseq@nil\else\def#1##1;{\sseq@g@addto@macro\sseq@savedpaths{#1##1;}}\@xp\sseq@modtikzcommands@\fi}

% Defered evaluation of scopes.
\NewEnviron{sseq@scope}{\sseq@temptoks\@xp{\BODY}\sseq@x@addto@macro\sseq@savedpaths{\@nx\begin{scope}\the\temptoks\@nx\end{scope}}}

% transfer data about the current spectral sequence between \<command> and \<oldcommand><sseqname>
\def\sseq@store#1{\edef\temp{\@nx\global\@nx\let\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname\@nx#1}\temp}
\def\sseq@get#1{\edef\temp{\global\let\@nx#1\@xp\@nx\csname\sseq@macroname#1\sseq@thename\endcsname}\temp}


%% Environment definitions

\def\sseqdata{\@ifnextchar[{\sseqdata@}{\sseqdata@[]}}%}

\def\sseqdata@[#1]#2{%
    %\catcode`\ =9% ignore spaces.
    \def\sseq@savedpaths{}%
    \sseq@data@name{#2}%
    \@xp\gdef\csname sseq@options\sseq@thename\endcsname{#1}%
    %
    % Page 0 is all pages
    \@xp\gdef\csname sseq@saveddiffs@\sseq@thename0\endcsname{%
        \foreach\sseq@p in {1,...,12}{%
            \csname sseq@saveddiffs@\sseq@thename\sseq@p\endcsname %
        }%
    }%
    % These are set up so that if the user specifies no \xrange, the minimum position of any node can be calculated on the fly.
    \xdef\sseq@xmin{\sseq@infinity}%
    \xdef\sseq@xmax{-\sseq@infinity}%
    \xdef\sseq@ymin{\sseq@infinity}%
    \xdef\sseq@ymax{-\sseq@infinity}%
    % These are used to decide whether to add a certain node to savedpaths.
    % In general the check is whether xmin<=xcoord<=xmax, but since Latex has no <=, set xminmm=xmin-1, xmaxpp=xmax+1.
    % If the user doesn't specify a range, all nodes should be rendered
    % To ensure that xminmm<xccord<xminpp in that case, set the default to xminmm=-\infty, xmaxpp=+\infty.
    \xdef\sseq@xminmm{-\sseq@infinity}%
    \xdef\sseq@xmaxpp{\sseq@infinity}%
    \xdef\sseq@yminmm{-\sseq@infinity}%
    \xdef\sseq@ymaxpp{\sseq@infinity}%
%
    % copy commands into the user namespace.
    \sseq@copydatacommands{%
        \cyclestyle\cyclestyles %
        \permanentcyclestyle\transientcyclestyle %
        \xrange\yrange\axesstyle %
        \place\d\degree %
        \structline %
    }%
%
    % Defer evaluation of tikz primitives
    \sseq@modtikzcommands %
}

% Store the savedpaths and ranges
\def\endsseqdata{
    \@xp\xdef\csname sseq@savednodes@\sseq@thename infty\endcsname{\csname sseq@savednodes@\sseq@thename infty\endcsname}%
%    \show\csname sseq@savednodes@\sseq@thename infty\endcsname
    \sseq@store\sseq@savedpaths %
    \sseq@store\sseq@thepermcyclestyle\sseq@store\sseq@thetranscyclestyle %
    \sseq@store\sseq@xmin\sseq@store\sseq@xmax %
    \sseq@store\sseq@ymin\sseq@store\sseq@ymax %
}
\def\sseqpage{\@ifnextchar[{\sseqpage@}{\sseqpage@[]}} %}

\def\sseqpage@[#1]{
    \gdef\sseqpage@cleanup{} % For undoing local option settings
    \def\sseq@options{#1}%
    % Copy commands into user namespace
    \sseq@copypagecommands{\name\page\doptions\xrange\yrange}%
    %
    % Defer evaluation of all tikz primitives
    \sseq@modtikzcommands %
}
\def\endsseqpage{%
    % Copied from tikzcd code. Passes quotes forward to edge and format edge label appropriately
    \pgfkeys{% `quotes' library support
      /handlers/first char syntax/the character "/.initial=\sseq@forward@quotes,%
      /tikz/edge quotes mean={%
        edge node={node [execute at begin node=$,%$
                         execute at end node=$,%$
                         auto=right,every label,##2]{##1}}}}%
%
    % Set it up so that options are dumped out but not expanded
    % So \temp will look like \begin{tikzpicture}[option=\mycommand{stuff},...] with \mycommand not yet expanded.
    \sseq@temptoks\@xp\@xp\@xp{\csname sseq@options\sseq@thename\endcsname}%
    \sseq@temptoks@ii\@xp{\sseq@options}%
    \edef\temp{\@nx\begin{tikzpicture}[\the\sseq@temptoks,\the\sseq@temptoks@ii]}%
    \temp %
%
    % Axes -- eventually incorporate \axesstyle, label options, changing the increment between the numbers, etc
    \draw (\sseq@xmin-1.5, \sseq@ymin-0.5) -- (\sseq@xmax+0.5, \sseq@ymin-0.5)%
          (\sseq@xmin-0.5, \sseq@ymin-1.5) -- (\sseq@xmin-0.5, \sseq@ymax+0.5);%
    \foreach \sseq@x in {\sseq@xmin,...,\sseq@xmax}%
        \node at (\sseq@x,\sseq@ymin-1) {\sseq@x};%
    \foreach \sseq@y in {\sseq@ymin,...,\sseq@ymax}%
        \node at (\sseq@xmin-1,\sseq@y) {\sseq@y};%
%
    % clip
    \clip(\sseq@xmin-0.4,\sseq@ymin-0.4) rectangle (\sseq@xmax+0.5,\sseq@ymax+0.5);%
%
    \let\tikz@@@parse@regular\sseq@tikz@@@parse@regular
    \let\tikz@@to@or@edge@@coordinate\sseq@tikz@@to@or@edge@@coordinate
%
%
    % Insert nodes from all pages after the current one
    \foreach\sseq@p in {\curpage,...,12,infty}{%
        \csname sseq@savednodes@\sseq@thename\sseq@p\endcsname %
    }%
    % Insert differentials from just this page. \sseq@saveddiffs@thename@0 expands to all of these
    \csname sseq@saveddiffs@\sseq@thename\curpage\endcsname %
%
    % dump in savedpaths now. Contains all miscellaneous tikz stuff. Perhaps should add an unclipped version.
    \sseq@savedpaths %
    \end{tikzpicture}%
    \sseqpage@cleanup % This blanks any options special to this page
    \let\sseq@thename\relax %
}

% Copied from tikzcd code. Passes quotes forward to edge
\def\sseq@forward@quotes#1{\tikzset{every to/.append style={#1}}}

\def\sseq@data@name#1{\gdef\sseq@thename{#1}}
% When you name a page, retreive the information for that page.
\def\sseq@page@name#1{%
    \def\sseq@thename{#1}%
    \sseq@get\sseq@savedpaths %
    \sseq@get\sseq@xmin  \sseq@get\sseq@xmax %
    \sseq@get\sseq@ymin  \sseq@get\sseq@ymax %
}

\def\sseq@cyclestyles#1#2{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#2}}
\def\sseq@cyclestyle#1{\sseq@thepermcyclestyle{#1}\sseq@thetranscyclestyle{#1}}
\def\sseq@permanentcyclestyle#1{\sseq@thepermcyclestyle{#1}}
\def\sseq@transientcyclestyle#1{\sseq@thetranscyclestyle{#1}}

\def\sseq@xrange#1#2{%
    \let\sseq@xminmax\@gobble % Don't need to calculate range of nodes if user specifies it
    \gdef\sseq@xmin{#1}%
    \gdef\sseq@xmax{#2}%
    % Need to know decremented \xmin and incremented \xmax to decide which nodes to print
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\edef\sseq@xminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\edef\sseq@xmaxpp{\the\sseq@tempcount}%
}
\def\sseq@yrange#1#2{%
    \let\sseq@yminmax\@gobble %
    \gdef\sseq@ymin{#1}%
    \gdef\sseq@ymax{#2}%
    \sseq@tempcount=#1 \advance\sseq@tempcount-1\edef\sseq@yminmm{\the\sseq@tempcount}%
    \sseq@tempcount=#2 \advance\sseq@tempcount1\edef\sseq@ymaxpp{\the\sseq@tempcount}%
}

% If #1 is less than \xmin or greater than \xmax, update \xmin or \xmax appropriately
% Gets set to \@gobble if user specifies range
\def\sseq@xminmax#1{%
    \ifnum#1<\sseq@xmin\gdef\sseq@xmin{#1}\fi %
    \ifnum#1>\sseq@xmax\gdef\sseq@xmax{#1}\fi %
}

\def\sseq@yminmax#1{%
    \ifnum#1<\sseq@ymin\gdef\sseq@ymin{#1}\fi %
    \ifnum#1>\sseq@ymax\gdef\sseq@ymax{#1}\fi %
}

% Specify bidegree of differentials
\def\sseq@degree#1#2{\def\sseq@targetx##1{#1}\def\sseq@targety##1{#2}}

\def\sseq@axesstyle#1{}

\def\sseq@page@page{\afterassignment\sseq@page@page@\def\curpage}
\def\sseq@page@page@{\sseq@tempcount=\curpage\advance\sseq@tempcount-1\edef\curpagemm{\the\sseq@tempcount}}

\def\sseq@doptions{\bgroup\catcode`\ =9\relax\sseq@doptions@}

\def\sseq@doptions@#1(#2){
    \egroup
    \sseq@g@addto@macro\sseqpage@cleanup{\@xp\gdef\csname sseq@dstyle#1(#2)\endcsname{}}
    %\@xp\sseq@g@addto@macro\csname sseq@dstyle#1(#2)\endcsname
    \@xp\def\csname sseq@dstyle#1(#2)\endcsname
}




\tikzset{
  every differential/.style={},
  every label/.style={
    /tikz/auto,
    /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},
    /tikz/inner sep=+0.5ex}
}


\def\printpage#1#2{
    \begin{sseqpage}
    \name{#1}
    \page{#2}
    \end{sseqpage}
}



% Core

\def\sseq@ifhop#1#2\fi{\fi#1} % so we can use \sseq@optarg in \edef.
\def\sseq@id#1{#1} % Just removes braces

% #1 -- callback to apply to the argument if it is present
% #2 -- default value if argument is absent. Gets #3 = the name of the command this argument for, #4 = the argument number.
%       if we don't want to throw an error, this argument should generally end in \@gobbletwo
% #3 -- the name of the command
% #4 -- the number of the argument
\def\sseq@optarggen#1#2#3#4{\@xp\ifx\csname sseq@arg#4\endcsname\relax #2{#3}{#4}\else  #1{\csname sseq@arg#4\endcsname}\fi}
\def\sseq@optargc{\sseq@optarggen{,\sseq@id}{\@gobbletwo}{}}
\def\sseq@optarg#1{\sseq@optarggen{\sseq@id}{#1\@gobbletwo}{}}

\def\sseq@arg@checkpresent#1#2{\@ifundefined{sseq@arg#2}{\sseq@error{Comma separated value argument number #2 to the command \@nx#1 is missing}{Argument #2 is mandatory, please include it}{}}}
\def\sseq@arg{\sseq@optarggen{\sseq@id}{\sseq@thiscanthappen}}

\newcount\sseq@commacount

\def\sseq@pc@stdslsl#1{% This is the callback that we map over the texlist of arguments at the end of \sseq@parsecommas
    \advance\sseq@commacount1%
    \ifx&#1& % This without a space before the % breaks????
        \@xp\let\csname sseq@arg\the\sseq@commacount\endcsname\relax %
    \else %
        \pgfmathparse{int(#1)}%
        \@xp\edef\csname sseq@arg\the\sseq@commacount\endcsname{\pgfmathresult}%
    \fi %
}

\def\sseq@parsecommas(#1){\let\\\sseq@pc@stdslsl\sseq@commacount0\relax\sseq@parsecommas@{}#1,,,,,\sseq@nil}

\def\sseq@parsecommas@#1#2,{%
    \conditionally@traceoff %
    \advance\sseq@commacount1\relax%
    \ifnum\sseq@commacount<4 %
        \def\next{\sseq@parsecommas@{#1\\{#2}}}%
    \else %
        \def\next{\sseq@parsecommas@@{#1\\{#2}}}%
    \fi  %
    \next%
}

\def\sseq@parsecommas@@#1#2\sseq@nil{%
    \sseq@commacount=0\relax #1%
}

\def\sseq@parsecoords#1#2{\conditionally@traceoff\pgfmathparse{#2}\conditionally@traceon\edef\temp{\sseq@parsecoords@}\edef#1{\@xp\@gobble\temp}}
\def\sseq@parsecoords@{\@xp\sseq@parsecoords@@\pgfmathresult\sseq@nil}
\def\sseq@parsecoords@@#1{\ifx\sseq@nil#1\else ,\sseq@parsecoords@@@#1.\sseq@nil\@xp\sseq@parsecoords@@\fi}
\def\sseq@parsecoords@@@#1.#2\sseq@nil{#1}

%% Getters and setters

\def\sseq@ifundefcoord{\@xp\sseq@ifundefcoord@}
\def\sseq@ifundefcoord@(#1){\@ifundefined{sseq@coord\sseq@thename(#1)}}
\def\sseq@getcoord#1{\@xp\sseq@getcoord@\@xp#1}
\def\sseq@getcoord@#1(#2){\@ifundefined{sseq@coord\sseq@thename(#2)}{\sseq@thisshouldnothappen}{\@xp\let\@xp#1\csname sseq@coord\sseq@thename(#2)\endcsname}}
\def\sseq@setcoord(#1){\@ifundefined{sseq@coord\sseq@thename(\temp)}{\@xp\xdef\csname sseq@coord\sseq@thename(#1)\endcsname}{\sseq@thisshouldnothappen}}
\def\sseq@resetcoord(#1){\@xp\xdef\csname sseq@coord\sseq@thename(#1)\endcsname}

\def\sseq@ifdead{\@xp\sseq@ifdead@}
\def\sseq@ifdead@(#1){\@ifundefined{sseq@death\sseq@thename(#1)}{\@secondoftwo}{\@firstoftwo}}
\def\sseq@getdeathpage{\@xp\sseq@getdeathpage@}
\def\sseq@getdeathpage@(#1){\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@setdeathpage{\@xp\sseq@setdeathpage@}
\def\sseq@setdeathpage@(#1){\@xp\xdef\csname sseq@death\sseq@thename(#1)\endcsname}
\def\sseq@cleardeathpage{\@xp\sseq@cleardeathpage@}
\def\sseq@cleardeathpage@(#1){\@xp\global\@xp\let\csname sseq@death\sseq@thename(#1)\endcsname\relax}

\newif\ifsseq@printnode@
\def\sseq@nodecond#1#2{\sseq@printnode@false\ifnum#1<#2\relax \sseq@printnode@true\fi}

\def\sseq@place#1(#2){%
    \sseq@parsecoords\temp{#2}%
    \edef\next{\@nx\sseq@place@#1(\temp)}%
    \next %
}

\def\sseq@place@#1(#2,#3){%
    \conditionally@traceon %
    \sseq@xminmax{#2}%
    \sseq@yminmax{#3}%
    \sseq@ifundefcoord(#2,#3){}{\sseq@error{A node at (#2,#3) already exists}{}}%
    \sseq@ifundefcoord(#2,#3,1){}{\sseq@error{A node at (#2,#3) already exists}{}}%
    \ifnum#1=1\relax %
        \sseq@setcoord(#2,#3){#2,#3}%
%
        \edef\temp{%
            \@nx\sseq@place@full{#2}{#3}{}{}{}%
                {\the\sseq@thetranscyclestyle}%
                {\the\sseq@thepermcyclestyle}%
        }%
        \temp %
    \else\ifnum#1=2\relax %
        \sseq@setcoord(#2,#3,1){#2-0.13,#3}%
        \sseq@setcoord(#2,#3,2){#2+0.13,#3}%
%
        \edef\temp{%
            \@nx\sseq@place@full{#2}{#3}{,1}{-0.13}{}%
                {\the\sseq@thetranscyclestyle}%
                {\the\sseq@thepermcyclestyle}%
        }%
        \temp %
        \edef\temp{%
            \@nx\sseq@place@full{#2}{#3}{,2}{+0.13}{}%
                {\the\sseq@thetranscyclestyle}%
                {\the\sseq@thepermcyclestyle}%
        }%
        \temp %
    \else %
        \sseq@error{Not implemented}{}%
    \fi\fi\conditionally@traceoff %
}

%
% #1 -- "virtual address" x coordinate
% #2 -- "virtual address" y coordinate
% #3 -- nth class at (x,y). If there is only ever going to be one, {}, otherwise {,n}
% #4 -- offset from virtual x coordinate to actual x coordinate
% #5 -- offset from virtual y coordinate to actual y coordinate
% #6 -- callback to draw node if it is a transient cycle
% #7 -- callback to draw node if it is a permanent cycle
%
\def\sseq@place@full#1#2#3#4#5#6#7{
    \def\temp##1##2{#6}%
    \sseq@temptoks\@xp{\temp{sseq@{#1,#2#3}}{#1#4,#2#5}}%
    \@xp\xdef\csname sseq@place\sseq@thename(#1,#2#3)\endcsname{\the\sseq@temptoks}% Classes that eventually die
%
    \def\temp##1##2{#7}%
    \sseq@temptoks\@xp{\temp{sseq@{#1,#2#3}}{#1#4,#2#5}}%
    \@xp\xdef\csname sseq@placeinfty\sseq@thename(#1,#2#3)\endcsname{\the\sseq@temptoks}% Classes that live forever
    \@xp\gdef\csname sseq@clearinfty\sseq@thename(#1,#2#3)\endcsname{\@xp\global\@xp\let\csname sseq@placeinfty\sseq@thename(#1,#2#3)\endcsname\relax}%
%
    \ifnum#1<\sseq@xmaxpp\ifnum#1>\sseq@xminmm\ifnum#2<\sseq@ymaxpp\ifnum#2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
            \@nx\ifx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2#3)\endcsname\relax\@nx\else %
                \@nx\@nx\@xp\@nx\csname sseq@placeinfty\sseq@thename(#1,#2#3)\endcsname %
            \@nx\fi %
        }%
    \fi\fi\fi\fi %
}

% This isn't used anymore
\def\sseq@place@one#1#2#3#4#5{%
    % Classes that live forever
    \@xp\gdef\csname sseq@place\sseq@thename(#1,#2#3)\endcsname{\node[draw,circle,fill,inner sep=0.3ex] at (#1#4,#2#5) {};}%
    \ifnum#1<\sseq@xmaxpp\ifnum#1>\sseq@xminmm\ifnum#2<\sseq@ymaxpp\ifnum#2>\sseq@yminmm %
        \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
            \@nx\ifx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2#3)\endcsname\relax\@nx\else %
                \@nx\@nx\@xp\@nx\csname sseq@place\sseq@thename(#1,#2#3)\endcsname %
            \@nx\fi %
        }%
    \fi\fi\fi\fi %
}

\def\sseq@replace(#1){%
    \sseq@ifundefcoord(#1){\sseq@error{There never was a class at (#1) so I can't replace it}{}}{}%
    \sseq@ifdead(#1){}{\sseq@error{I cannot replace the class at (#1) because it seems to be alive and well}{}}%
    \sseq@parsecommas(#1)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
}%


\def\sseq@d{\@ifnextchar[{\sseq@d@}{\sseq@d@[]}} %}

\def\sseq@d@[#1]#2(#3){%
    \sseq@tempcount=#2%
    \sseq@temptoks{\sseq@d@@{#1}}%
    \edef\temp{\the\sseq@temptoks{\the\sseq@tempcount}}%
    \temp{#3}%
}

\def\sseq@d@@#1#2#3{%
    \conditionally@traceon%
    \sseq@parsecommas(#3)%
    \sseq@arg@checkpresent\d1%
    \sseq@arg@checkpresent\d2%
%
    \edef\sourcename{(\sseq@arg\d1,\sseq@arg\d2\sseq@optargc3)}%
    \sseq@parsecoords\targetname{\sseq@arg\d1 + \sseq@targetx{#2},\sseq@arg\d2+\sseq@targety{#2}}%
    \edef\targetname{(\targetname\sseq@optargc4)}%
    \sseq@ifundefcoord\sourcename{%
        \sseq@error{%
            Source \sourcename\sseq@macroname\ of differential \string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3) can't support
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \sseq@ifundefcoord\targetname{%
        \sseq@error{%
            Target \targetname\sseq@macroname\ of differential \string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3) can't accept
            a differential because a class in that position never existed%
        }{}%
    }{}%
    \sseq@ifdead\sourcename{%
        \sseq@error{%
            Source \sourcename\sseq@macroname\ of differential \string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3) can't support
            a differential because it already perished on page \sseq@getdeathpage\sourcename %
        }{}%
    }{}%
    \sseq@ifdead\targetname{%
        \sseq@error{%
            Target \targetname\sseq@macroname\ of differential \string\d\ifx\sseq@nil#1\sseq@nil \else[#1]\fi#2(#3) can't accept
            a differential because it already perished on page \sseq@getdeathpage\targetname %
        }{}%
    }{}%
%
%
    \sseq@setdeathpage\sourcename{#2}%
    \sseq@setdeathpage\targetname{#2}%
%
%
    \sseq@getcoord\source\sourcename %
    \sseq@getcoord\target\targetname %
%
    \sseq@temptoks{#1}%
    \@xp\sseq@x@addto@macro\csname sseq@saveddiffs@\sseq@thename#2\endcsname{%
        \@nx\sseq@temptoks{\the\sseq@temptoks}%
        %\@nx\show\@xp\@nx\csname sseq@dstyle\sourcename#2\endcsname
        %\show\@xp\@nx\csname sseq@dstyle#2\sourcename\endcsname
        \@nx\edef\@nx\temp{\@nx\@nx\@nx\draw[every differential,\@nx\the\@nx\sseq@temptoks,\@xp\@nx\csname sseq@dstyle#2\sourcename\endcsname] \sourcename to \targetname;}%
        \@nx\temp %
    }%
%
    \@xp\gdef\csname sseq@dstyle#2\sourcename\endcsname{}%
%
    % Remove placement of features from infinity page -- removes node, and also any features contingent on the node
    \def\sseq@temppage{#2} % This is needed to tell contingent features what page we're on
    \csname sseq@clearinfty\sseq@thename\sourcename\endcsname%
    \csname sseq@clearinfty\sseq@thename\targetname\endcsname%
%
    % Add placement on appropriate page
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename#2\endcsname{%
        \@xp\@nx\csname sseq@place\sseq@thename\sourcename\endcsname %
        \@xp\@nx\csname sseq@place\sseq@thename\targetname\endcsname %
    }%
}


\def\sseq@addcontingentfeature#1#2{%
    \@xp\gdef\csname sseq@feature\the\sseq@featurecount\endcsname{#2}%
    \@xp\gdef\csname sseq@featureinfty\the\sseq@featurecount\endcsname{#2}%
    \@xp\sseq@x@addto@macro\csname sseq@savednodes@\sseq@thename infty\endcsname{%
        \@nx\ifx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax\@nx\else %
            \@nx\@nx\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname %
        \@nx\fi %
    }%
    \@xp\xdef\csname sseq@transferfeature\the\sseq@featurecount\endcsname{%
        \global\let\@xp\@nx\csname sseq@featureinfty\the\sseq@featurecount\endcsname\relax %
        \@nx\@xp\@nx\sseq@g@addto@macro\@nx\csname sseq@savednodes@\sseq@thename\@nx\sseq@temppage\endcsname{%
            \@xp\@nx\csname sseq@feature\the\sseq@featurecount\endcsname %
        }%
        \global\let\@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname\relax %
    }%
    \sseq@addcontingentfeature@#1(\sseq@nil)%
    \global\advance\sseq@featurecount1%
}

\def\sseq@addcontingentfeature@(#1){\ifx\sseq@nil#1\else %
    \sseq@parsecoords\temp{#1}%
    \@xp\sseq@x@addto@macro\csname sseq@clearinfty\sseq@thename(\temp)\endcsname{%
            \@xp\@nx\csname sseq@transferfeature\the\sseq@featurecount\endcsname %
    }%
%
    \@xp\sseq@addcontingentfeature@ %
\fi}

\def\sseq@structline(#1)(#2){\edef\temp{\@nx\sseq@structline@\sseq@anchorsplit{#1}\sseq@anchorsplit{#2}}\temp}
\def\sseq@structline@#1#2#3#4{
    \sseq@parsecoords\source{#1}%
    \sseq@parsecoords\target{#3}%
    \edef\temp{\@nx\sseq@structline@@{\source}{#2}{\target}{#4}}
    \temp
}

\def\sseq@anchorsplit#1{\sseq@anchorsplit@#1.\sseq@nil}
\def\sseq@anchorsplit@#1.#2{\ifx#2\sseq@nil {#1}{}\else {#1}\@xp\sseq@anchorsplit@@\@xp#2\fi}
\def\sseq@anchorsplit@@#1.\sseq@nil{{.#1}}

\def\sseq@structline@@#1#2#3#4{\sseq@addcontingentfeature{(#1)(#3)}{\draw (#1#2)--(#3#4);}}


%% Redo tikz rules for interpreting coordinates to default to treating (x,y) as specifying a node.
\def\sseq@testpt#1.#2\@nil{{#1}\ifx&#2&\else .\sseq@gobblept#2\@nil\fi}
\def\sseq@gobblept#1.\@nil{#1}

\let\sseq@tikz@@@parse@regular@old\tikz@@@parse@regular
\def\sseq@tikz@@@parse@regular#1#2#3){%(
    \edef\next{\@nx\sseq@tikz@@@parse@regular@\@nx#1{#2}\sseq@testpt#3.\@nil)}
    \next
}

\def\sseq@tikz@@@parse@regular@#1#2#3#4){
    \sseq@parsecoords\temp{#2,#3}
    %\show\temp
    \@xp\ifx\csname pgf@sh@pi@sseq@{\temp}\endcsname\pgfpictureid
        \edef\next{\@nx\tikz@parse@node\@nx#1(sseq@{\temp}#4)}
    \else %(
        \def\next{\sseq@tikz@@@parse@regular@old#1{#2}{#3#4})}
    \fi
    %\show\next
    \next
}

\def\sseq@tikz@@to@or@edge@@coordinate(#1){%
  \@xp\ifx\csname pgf@sh@pi@sseq@{#1}\endcsname\pgfpictureid
    \def\tikztotarget{sseq@{#1}}
  \else
    \def\tikztotarget{#1}
  \fi
  \tikz@to@or@edge@function%
}
