\documentclass{ltxdoc}
\usepackage[a4paper,left=2.25cm,right=2.25cm,top=2.5cm,bottom=2.5cm,nohead]{geometry}
\usepackage{sseqpages}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{fit}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage[documentation]{tcolorbox}
\usepackage{hyperref}
\hypersetup{%
        colorlinks=true,
        linkcolor=blue,
        filecolor=blue,
        urlcolor=blue,
        citecolor=blue,
        pdfborder=0 0 0,
}
%]\usepackage{makeidx}
%\makeindex

\makeatletter          % !!!!
\input{pgfmanual.code} % This must be exectuted when catcode of @ is letter
\makeatother           % !!!!

\usepackage{calc} %
\include{pgfmanual-en-macros} % This must be executed when catcode of @ is other

\makeatletter

\parskip=10pt
\parindent=0pt
\MakeShortVerb{\|}

\def\sectionstring{\textbackslash\@xp\@gobble\string}

% Prevent \decompose from throwing an error when the key doesn't start with /.
% I could replace this with something simpler -- the only important thing \decompose does is make a link
\let\olddecompose\decompose
\def\decompose{\olddecompose/}

%\patchcmd\pgfmanualpdfref{#2}{#2} % If I want it to behave differently for things that aren't links
\patchcmd\pgfmanualpdfref{\expandafter\pgfmanualpdfref@\expandafter{\pgfmanualpdflabel@@}{#2}} % Fix it so that being a link doesn't change the color
    {\colorlet{temp}{.}\expandafter\pgfmanualpdfref@\expandafter{\pgfmanualpdflabel@@}{\textcolor{temp}{#2}}}{}{}%

\newenvironment{manualentry}[1]{
    \begin{pgfmanualentry}
    \pgfmanualentryheadline{#1}
    \pgfmanualbody
}{
    \end{pgfmanualentry}
}

\let\extractkey@\extractkey
%\show\extractkey@
\apptocmd\extractkey@{\egroup}{}{\error}
\def\extractkey{\bgroup\@ifnextchar*{\def\decompose####1\nil{ }\relax\extractkey@\@gobble}{\extractkey@}}

\def\pgfmanual@pretty@quote{"}
\let\pgfmanual@pretty@pgfkeys@loop@\pgfmanual@pretty@pgfkeys@loop
\def\pgfmanual@pretty@pgfkeys@loop#1{%
	\def\pgfmanual@loc@TMPa{#1}%
    \def\pgfmanual@pretty@pgfkeys@loop@NEXT{\pgfmanual@pretty@pgfkeys@loop@{#1}}%
    \ifx\pgfmanual@loc@TMPa\pgfmanual@pretty@quote%
        \let\pgfmanual@pretty@pgfkeys@loop@NEXT\pgfmanual@pretty@collectquote
    \fi
    \pgfmanual@pretty@pgfkeys@loop@NEXT
}
\def\pgfmanual@pretty@collectquote{%
    \let\pgfmanualprettyprinterhandlecollectedargs=\pgfmanual@pretty@collectargs@finish@collectquote
    \pgfmanualprettyprintercollectupto"
    	{\pgfmanual@pretty@collectquote@b}%
}
\def\pgfmanual@pretty@collectquote@b{%
    \let\pgfmanualprettyprinterhandlecollectedargs=\pgfmanual@pretty@collectargs@finish@collectquote@b
    \expandafter\pgfmanualprettyprintercollectupto,
    	{\afterpgfmanual@pretty@collectquote}%
}
\def\afterpgfmanual@pretty@collectquote{\pgfmanual@pretty@pgfkeys@loop}
\def\pgfmanual@pretty@collectargs@finish@collectquote#1{\opt{\pgfmanualpdfref{""quotes}{"#1"}}}
\def\pgfmanual@pretty@collectargs@finish@collectquote@b#1{%
    \pgfkeys{/codeexample/prettyprint/key name/.code={\textcolor{keycolor}{##1}}}%
    \pgfmanual@pretty@pgfkeys@loop#1\pgfmanual@EOI
    \ifpgfmanualprettyprinterfoundterminator,\fi
}

\pgfkeys{
	/codeexample/prettyprint/cs arguments/meta/.initial=1, % Make \meta work correctly in codeexample
	/codeexample/prettyprint/cs/meta/.code={\textcolor{black}{\meta{\@gobble#1}}},
	/codeexample/prettyprint/cs arguments/opt/.initial=1,
	/codeexample/prettyprint/cs/opt/.code={\opt{\@gobble#1}},
    /codeexample/prettyprint/cs arguments/oarg/.initial=1,
	/codeexample/prettyprint/cs/oarg/.code={\oarg{\@gobble#1}},
    /codeexample/prettyprint/cs arguments/cscolor/.initial=1,
	/codeexample/prettyprint/cs/cscolor/.code={\textcolor{cscolor}{\@gobble#1}},
	%/codeexample/prettyprint/cs/.code={\pgfmanualpdfref{#1}{\textcolor{blue}{#1}}},
%	/codeexample/prettyprint/cs with args/.code 2 args={\pgfmanualpdfref{#1}{\textcolor{blue}{#1}}\{\pgfmanualprettyprintcode{#2}\pgfmanualclosebrace},
    %/codeexample/prettyprint/colored
}

%\patchcmd\endofcodeexample{\ifcode@execute}{\ifcode@execute\sseqset{background color=graphicbackground}}{}{\error}
%\makeatother
\begin{document}
\tableofcontents
\section{Introduction}
The |sseqpages| package consists of two main environments -- the |sseqdata| environment, which specifies the data for a named spectral sequence diagram, and the |sseqpage| environment, which prints a single page of a spectral sequence diagram. The command \cmd\printpage{} is also available as a synonym for a sseqpage enivornment with an empty body.

Here is a basic example:
\begin{codeexample}[]
\begin{sseqdata}[name=ex1,cohomological Serre grading]
\class(0,0)
\class(0,2)
\class(3,0)
\class(3,2)
\d3(0,2)
\end{sseqdata}
\printpage[name=ex1,page=3]\hskip1cm
\printpage[name=ex1,page=4]
\end{codeexample}
|\begin{sseqdata}[name=ex1,degree={#1}{1-#1}]| starts the declaration of the data of a spectral sequence named |ex1| whose page r differentials go r to the right and down r-1 (this is cohomological Serre grading). Then we specify four classes and one page 3 differential, and we ask |sseqpages| to print the third and fourth pages of the spectral sequence. Note that on the fourth page, the source and target of the differential have disappeared.

\section{The Environments}
\begin{environment}{{sseqdata}|[|\meta{options}|]|}
The |sseqdata| environment is for storing a spectral sequence to be printed later. This environment is intended for circumstances where you want to print multiple pages of the same spectral sequence. When using the |sseqdata| environment, you must use the |name| option to tell |sseqpages| where to store the spectral sequence so that you can access it later.
\end{environment}

\begin{environment}{{sseqpage}\oarg{options}}
This environment is used for printing a page of existing spectral sequence that was already specified using the |sseqdata| environment. The body of the environment adds local changes -- classes, differentials, structure lines, and arbitrary tikz options that are by default only printed on this particular page. The |sseqpage| environment can also be used to print a standalone page of a spectral sequence -- that is, if you only want to print a single page of the spectral sequence, you can skip using the |sseqdata| environment.
\end{environment}

\begin{command}{\printpage[\meta{options}]}
This command prints a single page of an existing spectral sequence as-is. This is equivalent to a |sseqpage| environment with an empty body.
\end{command}


\section{The main commands}
\begin{command}{\class\oarg{options}\meta{coordinate}}
This places a class at \meta{coordinate}=(\meta{xcoord},\meta{ycoord}) where \meta{xcoord} and \meta{ycoord} are integers. If multiple classes occur at the same position, |sseqpages| will automatically arrange them in a pre-specified pattern:
\begin{codeexample}[code only]
\begin{sseqpage}[no axes,ymirror]
\class(0,0)
\class(1,0)\class(1,0)
\class(0,1)\class(0,1)\class(0,1)
\class(1,1)\class(1,1)\class(1,1)\class(1,1)
\class(0,2)\class(0,2)\class(0,2)\class(0,2)\class(0,2)
\class(1,2)\class(1,2)\class(1,2)\class(1,2)\class(1,2)\class(1,2)
\end{sseqpage}
\end{codeexample}
The effect of the |\class| command is to print a \tikzname\ node on a range of pages. Any option that would work for a \tikzname\ |\node| command will also work in the same way for the |\class|, |\replaceclass|, and |\classoptions| commands.

If a class is the source or the target of a differential on a certain page, then the page of the class is set to that page, and the class is only rendered on pages up to that number:
\begin{codeexample}[]
\begin{sseqdata}[name=class example,Adams grading]
\class(1,0)
\class(0,2)
\class(0,3)
\d2(1,0)
\end{sseqdata}
\printpage[name=class example,page=2]
\printpage[name=class example,page=3]
\end{codeexample}

See the \pgfmanualpdfref{class options}{class options} section for a list of the sort of options available for classes.
\end{command}

\begin{command}{\replaceclass\oarg{options}\meta{coordinate}}
After a class is the source or target of a differential, it disappears on the next page. However, some differentials are not injective or not surjective. Using the command |\replaceclass| causes a new symbol to appear on the page after a class supported or accepted a differential (or both).
\begin{codeexample}[]
\begin{sseqdata}[name=replace class example,Adams grading,classes={draw=none},math nodes]
\class["\mathbb{Z}"](0,3)
\class["\mathbb{Z}"](1,1)
\class["\mathbb{Z}"](1,0)
\d["\cdot 2"]2(1,1)
\replaceclass["\mathbb{Z}/2"](0,3)
\d[->>]3(1,0)
\replaceclass["2\mathbb{Z}"](1,0)
\end{sseqdata}
\printpage[name=replace class example, page=2]
\hskip1cm
\printpage[name=replace class example, page=3]
\hskip1cm
\printpage[name=replace class example, page=4]
\end{codeexample}
\end{command}

\begin{command}{\classoptions[\meta{options}]\meta{coordinate}}
This adds options to a class that already exists. This can be used in a |sseqpage| environment to modify the appearance of a class for just one drawing of the spectral sequence, for instance to highlight it for discussion purposes:
\begin{codeexample}[width=5cm]
\begin{sseqdata}[name=class options example,classes=fill]
\foreach \x in {0,...,2} \foreach \y in {0,1}{
    \class(\x,\y)
}
\end{sseqdata}
\begin{sseqpage}[name=class options example]
\classoptions[red](2,1) % Will only show up as red on this page!
\node[background,text width=10em] at (0.7,-2.2)
    {\textup{The red class is the source of our troubles}};
\end{sseqpage}
\end{codeexample}
Another reason to use this is to give a label to one instance of a class that shows up in a loop or a command defined using |\sseqnewgroup|:
\begin{codeexample}[width=6cm]
\sseqnewgroup\mygroup{
    \class(0,0)
    \class(0,1)
    \class(0,2)
    \class(1,1)
    \class(2,2)
    \structline(0,0)(0,1)
    \structline(0,1)(0,2)
    \structline(0,0)(1,1)
    \structline(1,1)(2,2)
}
\begin{sseqpage}[classes=fill,class labels={left=0.3em},math nodes]
\mygroup(0,0)
\mygroup(1,2)
\classoptions["2"](0,1)
\classoptions["\eta"](1,1)
\end{sseqpage}
\end{codeexample}
See the \pgfmanualpdfref{class options}{class options} section for a list of the sort of options available for classes.
\end{command}

\begin{command}{\d\oarg{options}\meta{page}\meta{source coordinate}}
This creates a differential starting at \meta{source coordinate} of length determined by the specified page. In order to use the |\d| command, you must first specify the |degree| of the differentials as an option to the |sseqdata| or |sseqpage| environment. The degree indicates how far to the right and how far up a page r differential will go as a function of r. If there is a page r differential, on page r+1, the source, target, and any |\structline|s connected to the source and target of the differential disappear.
\begin{codeexample}[width=7.5cm]
\begin{sseqdata}[name=d example,degree={-1}{#1},
                 struct lines=blue]
\class(0,2)
\class(1,2)
\class(1,1)
\class(1,0)
\structline(1,2)(0,2)
\structline(1,2)(1,1)
\structline(1,1)(1,0)
\d2(1,0)
\end{sseqdata}
\printpage[name=d example,page=2]
\hskip0.3cm
\printpage[name=d example,page=3]
\end{codeexample}
If there are multiple nodes in the source or target coordinate, then there is a funny syntax for indicating which one should be the source and target:
|\d|\meta{page}|(|\meta{x}|,|\meta{y}\opt{|,|\meta{source n}|,|\meta{target n}}|)|
\begin{codeexample}[width=6cm]
\begin{sseqpage}[Adams grading]
\class(1,0)\class(1,0)
\class(0,2)\class(0,2)
\d2(1,0,1,2)
\class(2,0)\class(2,0)
\class(1,2)
\d2(2,0,2)
\class(3,0)
\class(2,2)\class(2,2)
\d2(3,0,,2)
\end{sseqpage}
\end{codeexample}
Negative indices will count from the most recent class in the coordinate (so |-1| is the most recent, |-2| is the second most recent, etc):
\begin{codeexample}[]
\begin{sseqpage}[Adams grading]
\class(1,0)
\class(0,2)\class(0,2)
\d[blue]2(1,0,-1,-1)
\class(1,0)
\class(0,2)
\d[orange]2(1,0,-1,-1)
\class(1,0)
\d[red]2(1,0,-1,-2)
\end{sseqpage}
\end{codeexample}
\end{command}

\begin{command}{\doptions[\meta{options}]\meta{page}\meta{source coordinate}}

\end{command}

\begin{command}{\structline\oarg{options}\meta{source coordinate}\meta{target coordinate}}
This command creates a structure line from \meta{source coordinate} to \meta{target coordinate}. The source and target coordinates are of the form |(|\meta{x}|,|\meta{y}\opt{|,|\meta{n}}|)|. If there are multiple classes at (x,y), then \meta{n} specifies which of the classes at (x,y) the structline starts and ends at -- if n is positive, then it counts from the first class in that position, if n is negative, it counts backwards from the most recent.

If the source or target of a structure line is hit by a differential, then on subsequent pages, the structure line disappears.
\begin{codeexample}[width=9cm]
\sseqnewgroup\tower{
    \class(0,0)
    \class(0,2)
    \foreach \y in{1,...,5}{
        \class(0,\y)
        \structline(0,\y-1,-1)(0,\y,-1)
    }
    \structline(0,1,-1)(0,2,-2)
    \structline(0,2,-2)(0,3,-1)
}
\begin{sseqdata}[name=structline example,
                 classes={circle,fill},
                 Adams grading, no axes]
\class(1,1)\class(1,2)
\class(2,3)\class(2,3)\class(2,5)
\tower[classes=blue](0,0)
\tower[struct lines=dashed,orange](1,0)
\tower[struct lines=red](2,0)
\d2(1,1,2)
\end{sseqdata}
\printpage[name=structline example,page=2]
\hskip1cm
\printpage[name=structline example,page=3]
\end{codeexample}
\end{command}

\begin{command}{\structlineoptions[\meta{options}]\meta{source coordinate}\meta{target coordinate}}

\end{command}

\subsection{\tikzname\space Primitives}
Any code that would work in a |tikzpicture| environment will also work unchanged in a |sseqdata| or |sseqpage| environment, with a couple minor differences. This is a very flexible way to add arbitrary background or foreground features to the spectral sequence:
\begin{codeexample}[]
\begin{sseqdata}[name=tikz example,Adams grading,x range={0}{2}, x axis extend end=2em]
\class(0,0)
\class(1,0)
\class(0,2)
\d2(1,0)
\end{sseqdata}
%
\begin{sseqpage}[name=tikz example]
\begin{scope}[blue,font=\tiny]
\node[name path=myellipse, draw, ellipse, inner sep=4pt, scale=0.7, rotate fit=26.5,
      fit=(sseq{1,0,1}) (sseq{0,2,1})] {}; % Internally, the classes are named (sseq{x,y,n})
\path[name path=myline](1.2,1.2)--(0.6,1);
\draw[->,name intersections={of=myellipse and myline}] (1.2,1.2)--(intersection-1);
\node[right,text width=1.6cm] at (1.2,1.2) {Consider this differential};
\end{scope}
\end{sseqpage}
%
\begin{sseqpage}[name=tikz example]
\begin{scope}[<-,blue,font=\tiny]
\draw[xshift=1](0,0) to (0.6,0.2) node[right,text width=1.1cm] {This is the source};
\draw[yshift=2](0,0) to (0.6,0.2) node[right,text width=1.1cm] {This is the target};
\end{scope}
\end{sseqpage}
%
\begin{sseqpage}[page=3,name=tikz example]
\node[draw,ellipse,blue,inner sep=4pt,scale=0.7,rotate fit=26.5,fit=(sseq{1,0,1}) (sseq{0,2,1})] {};
\node[right,blue,font=\tiny] at (1.2,1.2) {Now it's gone!};
\end{sseqpage}
\end{codeexample}

The following two keys are special to \tikzname\space primitives:
\begin{key}{background}
This key instructs |sseqpages| to put the current \tikzname\space primitive in the background. The way that the spectral sequence is printed is as follows:
\begin{itemize}
\item The axes and axes labels are printed (except when the |no axes| or |no axes labels| keys are used).

\item The \tikzname\space background paths are printed.

\item The clipping is inserted (unless the |no clip| key is used).

\item All foreground elements (classes, differentials, structlines, and normal \tikzname\space paths) are printed.
\end{itemize}

In particular, this means that foreground \tikzname\space paths can be clipped by the standard clipping, but background paths that are outside of the clipping expand the size of the Tikz picture:
\begin{codeexample}[]
\begin{sseqpage}[no axes labels]
\class(0,0)
\class(1,1)
\begin{scope}[on background layer]
\draw(0.1,0.1)--(1.1,1.1);
\end{scope}
\node[background] at (0.5,-1) {not clipped};
\node at (0.5,-0.35) {clipped};
\end{sseqpage}
\end{codeexample}
Here is an example where \tikzname\ labels with the |background| key are used to add labels and a grid:
\begin{codeexample}[]
\begin{sseqdata}[name=tikz background example, cohomological Serre grading, math nodes,
                 classes=fill]
\begin{scope}[background]
\node at (\xmax/2,\ymax+0.8) {\textup{Page \page{}}};
\node at (\xmax/2,-1.7) {H^*(B)};
\node[rotate=90] at (-1.5,\ymax/2) {H^*(F)};
\draw[step=1cm,gray,very thin] (\xmin-0.5,\ymin-0.5) grid (\xmax+0.4,\ymax+0.5);
\end{scope}
\class(0,0)
\class(3,0)
\class(0,2)
\class(3,2)
\d3(0,2)
\end{sseqdata}
\printpage[name=tikz background example, page=2]
\printpage[name=tikz background example, page=3]
\end{codeexample}
\end{key}

\begin{keylist}{page constraint=\meta{predicate}, page constraint or=\meta{predicate}}
This places a constraint on the pages in which the \tikzname\space primitive is printed. This predicate should look something like |(\page<=4)&&(\page>=3)|. The predicate is anded together with any previous predicates, so that you can use this as an option for a |scope| and again for the individual \tikzname\ primitive.

\begin{commandlist}{\isalive(\meta{coordinate}),\isalive\{(\meta{coordinate 1})$\cdots$(\meta{coordinate n})\}}
This command can only be used with |page constraint|. Saying 
$$|page contraint=||{\isalive(\meta{x},\meta{y},\meta{n})}|$$ 
will print the \tikzname\space primitive only on pages where the specified class is alive. Saying 
$$|page contraint=||{\isalive(|\meta{coordinate 1}|)|\,\cdots\,|(|\meta{coordinate n}|)}|$$ 
is equivalent to 
$$|page constraint=||{\isalive(\meta{coordinate 1}) &&|\,\cdots\,|&& \isalive(\meta{coordinate n})}|$$ 
Writing
$$|\draw[page constraint=||{\isalive(1,0)(2,2)}](1,0)--(2,2);|$$ 
has the same result as |\structline(1,0)(2,2)|, except that you can't later use |\structlineoptions| on it.
\end{commandlist}
\end{keylist}


\section{Options for the main commands}
\subsection{Universal options}
The following options work with all of the drawing commands in this package, including |\class|, |\d|, and |\structline|, their friends |\replaceclass|, |\classoptions|, |\doptions|, and |\structlines|, as well as with \tikzname\ primitives.
\begin{keylist}{xshift=\meta{integer},yshift=\meta{integer}}
Shifts by integer values are the only coordinate changes that are allowed to be applied to |\class|, |\d|, |\structline|, their relatives, or to a |scope| environment that contains any of these commands. These shift commands help with reusing code. For instance:
\begin{codeexample}[width=6cm]
\begin{sseqpage}[cohomological Serre grading]
\foreach \x in {0,1} \foreach \y in {0,1}{
    \begin{scope}[xshift=\x,yshift=\y]
    \class(2,0)
    \class(0,1)
    \d2(0,1)
    \end{scope}
}
\end{sseqpage}
\end{codeexample}
This code segment is very useful so |sseqpages| has the command |\sseqnewgroup| which to make code like this more convenient. The following code produces the same output as above:
\begin{codeexample}[code only]
\sseqnewgroup\examplegroup{
    \class(2,0)
    \class(0,1)
    \d2(0,1)
}
\begin{sseqpage}
\examplegroup(0,0)
\examplegroup(0,1)
\examplegroup(1,0)
\examplegroup(1,1)
\end{sseqpage}
\end{codeexample}


A word of warning: the behavior of |xshift| in |sseqpages| is incompatible with the normal behavior of xshift in \tikzname. For some reason, saying |xshift=1| in \tikzname\ does not shift the coordinate |(0,0)| to the coordinate |(1,0)| -- instead it shifts a tiny fraction of the distance. In |sseqpages|, saying |xshift=1| moves the coordinate |(0,0)| to the coordinate |(1,0)|. This includes \tikzname\ primitives: saying |\draw[xshift=1] (0,0) -- (1,0);| inside a |sseqdata| or |sseqpage| environment is the same as saying |\draw(1,0) -- (2,0);| despite the fact that this is not the case in the |tikzpicture| environment.
\end{keylist}

\begin{manualentry}{Colors}
These come from the \LaTeX\space |color| package, so see the |color| package documentation for more information.
\begin{codeexample}[]
\begin{sseqpage}[classes={fill,inner sep=0.4em}, no axes]
\class[red](0,0)
\class[blue](1,0)
\class[green](2,0)
\class[cyan](0,1)
\class[magenta](1,1)
\class[yellow](2,1)
\class[blue!50!red](0,2) % a 50-50 blend of blue and red
\class[green!30!yellow](1,2) % 70% green, 30% yellow
\class[blue!50!black](2,2)
\end{sseqpage}
\end{codeexample}
\end{manualentry}

\begin{manualentry}{\pgfmanualpdflabel{""quotes}{}|"|\meta{text}|"|\opt{\meta{options}}}
Specify a label for a class, a differential, or a structure line. This uses the \tikzname\ quotes syntax. The options include anything you might pass as an option to a \tikzname\ node, including arbitrary coordinate transforms, colors, opacity options, shapes, fill, draw, etc. The behavior is a little different depending on whether you use it on a class or on a differential or struct line.

For a class, the \meta{text} is placed in the position |inside| the node by default -- in effect, the \meta{text} becomes the label text of the node (so saying |\class["label text"](0,0)| causes a similar effect to saying |\node at (0,0) {label text};|). There are other position options such as |left|, |above left|, etc which cause the label text to be placed in a separate node positioned appropriately. If the placement is above, left, etc, then any option that you may pass to a \tikzname\ node will also work for the label, including general coordinate transformations. If the placement is ``inside'', then the only relevant \opt{\meta{options}} are those that alter the appearance of text, such as opacity and color.
\begin{codeexample}[]
\begin{sseqpage}[no axes,classes={minimum width=width("a")+0.5em}]
\class["a"](0,0)
\class["a",red](1,0)
\class["a" black,red](2,0)
\class["b" above](0,1)
\class["b" {below right,yshift=0.1cm}](1,1)
\class["a" {above right={1em}}](2,1)
\end{sseqpage}
\end{codeexample}
You can adjust the default behavior of class labels using the |labels|, |class labels|, |inner class labels| or |outer class labels| style options.
Note that it is also possible to give a label to a |\node| this way, although the behavior is slightly different. In particular, the label defaults to the |above| position instead of going in the |\node| text by default. Also, this won't respect the various label style options like |labels|, etc.
\begin{codeexample}[]
\begin{sseqpage}[no axes]
\class(0,0)
\class(2,0)
\node[circle,fill,"a"] at (1,0) {};
\end{sseqpage}
\end{codeexample}

For either a |\structline| or a |\class| the label normally goes on the right side of the edge. The special |'| option makes it go in the opposite position from the default. I copied the code to handle this from the |tikzcd| package, so if you use |tikzcd|, this should be familiar.
\begin{codeexample}[]
\begin{sseqpage}[Adams grading, math nodes]
\class(0,0)
\class(0,1)
\class(0,2)
\structline["a"' blue](0,0)(0,1)
\class(1,0)
\class(1,1)
\structline["b"](1,0)(1,1)
\d["\cdot 2"{pos=0.8}]2(1,0)
\end{sseqpage}
\end{codeexample}
You can use the style options |labels|, |edge labels|, |differential labels|, and |struct line labels| to adjust the styling of edge labels. For instance, if you would prefer for the labels to default to the left hand side of the edge rather than the right hand side, you could say |edge labels={auto=left}|.
You can also use quotes to label edges drawn with \tikzname\ primitives:
\begin{codeexample}[]
\begin{sseqpage}
\class(0,0) \class(1,1)
\draw (1,0) to["hi"'{yshift=0.7em}] (0,1);
\end{sseqpage}
\end{codeexample}
The special option ``description,'' stolen from |tikzcd|, places the label on top of the edge. In order to make this option work correctly, if the background color is not the default white, you must inform sseqpages about this using the key |background color=|\meta{color}. In this document, the background color is called \textit{graphicbackground}.
\begin{codeexample}[]
\begin{sseqpage}[no axes,background color=graphicbackground]
\foreach\x in {0,1,2} \foreach\y in {0,1}{
    \class(\x,\y)
}
\structline["a" red](0,0)(0,1)
\structline["a'"'blue,"b"{yshift=1em}](1,0)(1,1)
\structline["c" description](2,0)(2,1)
\end{sseqpage}
\end{codeexample}
\end{manualentry}



\subsection{Options for \sectionstring\class}\pgfmanualpdflabel{class options}{}
Because the main job of the |\class| command is to print a \tikzname\ |\node| on the appropriate pages of the spectral sequence, most options that would work for a \tikzname\ node also work for the commands |\class|, |\replaceclass|, and |\classoptions|. Here are a few that you might care about:
\begin{manualentry}{A \tikzname\ shape}
If you give the name of a \tikzname\ shape, the class node will be of that shape. The standard \tikzname\ shapes are |circle| and |rectangle|, but there are many more \tikzname\ shapes in the shapes library, which you can load using the command |\usetikzlibrary{shapes}|. The following are some examples:
\begin{codeexample}[]
\begin{sseqpage}[no axes,classes={inner sep=0.4em},
                 class placement transform={scale=2}]
\class(0,0)
\class[rectangle](1,0)
\class[diamond](0,1)
\class[semicircle](1,1)
\class[regular polygon, regular polygon sides=5](2,2)
\class[regular polygon, regular polygon sides=6](2,2)
\class[regular polygon, regular polygon sides=7](2,2)
\class[regular polygon, regular polygon sides=8](2,2)
\end{sseqpage}
\end{codeexample}
See the PGF manual section on the shape library for more information.
\end{manualentry}

\begin{keylist}{minimum width=\meta{dimension}, minimum height=\meta{dimension}, minimum size=\meta{dimension}, inner sep=\meta{dimension}, outer sep=\meta{dimension}}
These options control the size of a node. This is typically useful to make the size of nodes consistent independent of the size of their label text.  For instance:
\begin{codeexample}[]
\begin{sseqdata}[no axes,name=minimum width example]
\class["ab"](0,0)
\class["a"](0,1)
\class(0,2)
\end{sseqdata}
\printpage[name=minimum width example]
\printpage[name=minimum width example,
           change classes={blue,minimum width=width("ab")+0.5em}]
\end{codeexample}
\end{keylist}



\subsection{Options for \sectionstring\d\ and \sectionstring\structline}
Because the main job of the |\d| and |\structline| commands is to print an edge on the appropriate pages of the spectral sequence, most \tikzname\ options that you could apply to a \tikzname\ ``to'' operator (as in |\draw (x1,y1) to (x2,y2)|) can be applied to both |\d| and |\structline|. Some such options are as follows:

\begin{keylist}{source anchor=\meta{anchor}, target anchor=\meta{anchor}}
Because you can't use the normal \tikzname\ mechanism for specifying the source and target anchors, |sseqpages| has these two keys for |\d| and |\structline|:
\begin{codeexample}[]
\begin{sseqpage}[no axes]
\foreach\x in {0,1} \foreach\y in {0,1}{
    \class(\x,\y)
}
\structline(0,0)(0,1)
\structline[source anchor=north west,target anchor=-30](1,0)(1,1)
\end{sseqpage}
\end{codeexample}
\end{keylist}

\begin{manualentry}{Dash patterns:}
\begin{codeexample}[]
\begin{sseqpage}[no axes]
\foreach\x in {0,1,2} \foreach\y in {0,1}{
    \class(\x,\y)
}
\structline[densely dotted](0,0)(0,1)
\structline[dashed,red, "a"](1,0)(1,1)
\structline[dash dot,red, "a" black](2,0)(2,1)
\end{sseqpage}
\end{codeexample}
%
\end{manualentry}

%TODO: appearance here is a little inconsistent. Something to do with the stars.
\begin{keylist}{bend left=\meta{angle}, bend right=\meta{angle}, *in=\meta{anchor}, *out=\meta{anchor}}
\begin{codeexample}[]
\begin{sseqpage}[no axes]
\foreach\x in {0,1,2} \foreach\y in {0,1}{
    \class(\x,\y)
}
\structline[bend left=20](0,0)(0,1)
\structline[bend right=20](1,0)(1,1)
\structline[in=20,out=north](2,0)(2,1)
\end{sseqpage}
\end{codeexample}
\end{keylist}


\section{Commands}
\begin{command}{\sseqset\marg{keys}}
|\sseqset| is for adjusting the global options for all spectral sequences in the current scope. For instance, if most of the spectral sequences in the current document are going to be Adams graded, you can say |\sseqset{Adams grading}| and all future spectal sequences in the current scope will have Adams grading (unless you specify a different grading explicitly). As another example, |\sseqset{no axes}| will suppress axes from spectral sequences in the current scope.

For options that only apply to pages, such as |keep changes|, you should say instead |\sseqset{pages={keep changes}}|.
\end{command}

\begin{command}{\foreach}
This command is from \tikzname\space and works in pretty much the same way in |sseqpages|. The |\foreach| command is very flexible and has a lot of variants. See the \tikzname\space manual for more details.
%TODO fill me in
\end{command}

\begin{command}{\sseqnewcmd\opt{\lower3pt\hbox{*}}\meta{macro}\opt{(\meta{x variable macro},\meta{y variable macro})}\oarg{num args}\marg{body}}
This command makes a new command with syntax similar to |\class|. By default it takes three arguments: |\mycommand|\oarg{options}|(|\meta{x}|,|\meta{y}|)|. To access the \meta{options} argument in the body of the command, use the macro |\options|. Likewise to access \meta{x}, use |\x|, and to access \meta{y} use |\y|:
\begin{codeexample}[]
\sseqnewcmd\featuregroup{
    \class[\options](\x,\y)
    \class[\options](\x,\y+1)
    \structline(\x,\y)(\x,\y+1)
}
\begin{sseqpage}
\featuregroup[orange](0,0)
\featuregroup[red](1,0)
\end{sseqpage}
\end{codeexample}
The unstarred version will throw an error if the command to be defined already exists. The starred variant will quietly overwrite the existing command. Note that the command is always defined globally.

Sometimes it's inconvenient to use |\x| and |\y| as arguments, for instance if you want to use code that already uses them as iterators. In this case,
you can specify other macros to use for the arguments:
\begin{codeexample}[width=6cm]
\sseqnewcmd\test(\a,\b){
    \foreach \x in {0,...,2} \foreach \y in {0,...,1}{
        \class[\options](\a+\x,\b+\y)
    }
}
\begin{sseqpage}
\test(0,0)
\test[red,fill](1,1)
\end{sseqpage}
\end{codeexample}

The command you create with |\sseqnewcmd| can take up to six arguments in addition to |\options|, |\x|, and |\y|. These extra arguments are mandatory and are delimited by braces.
\begin{codeexample}[]
\sseqnewcmd*\tower[1]{
    \begin{scope}[\options]
    \class(\x,\y)
    \foreach \n in {1,...,#1}{
        \class(\x,\y+\n)
        \structline(\x,\y+\n-1)(\x,\y+\n)
    }
    \end{scope}
}
\begin{sseqpage}
\tower[orange](0,0){4}
\tower[red](1,1){2}
\end{sseqpage}
\end{codeexample}
\end{command}

\begin{command}{\sseqnewgroup\opt{\lower3pt\hbox{*}}\oarg{num args}\marg{body}}
This is more or less a shorthand for
\begin{codeexample}[code only, code=white]
\sseqnewcmd\opt{*}\cscolor{(\obscurexname,\obscureyname)}\oarg{num args}{
    \begin{scope}[xshift=\obscurexname,yshift=\obscureyname,\options]
    \meta{body}
    \end{scope}
}
\end{codeexample}
So that calling |\mygroup(x,y)| prints the whole group shifted to start at |(x,y)| instead of |(0,0)|. For instance:
\begin{codeexample}[]
\sseqnewgroup*\tower[1]{
    \class(0,0)
    \foreach \n in {1,...,#1}{
        \class(0,\n)
        \structline(0,\n-1)(0,\n)
    }
    \end{scope}
}
\begin{sseqpage}
\tower[orange](0,0){4}
\tower[red](1,1){2}
\end{sseqpage}
\end{codeexample}
\end{command}

\section{Global options}
\begin{key}{name=\meta{sseq name}}
\end{key}

\begin{key}{page=\meta{page number} (initially 0)}
This key is for |sseqpage| and |\printpage|. It specifies which page of the spectral sequence is to be printed. On page r, all |\class|es that are not hit by differentials on pages less than r will be printed, as well as all |\structline|s whose source and target classes are both printed on page r, and all differentials of length exactly r. The special value |page=0| prints all classes, differentials, and structure lines.
\end{key}

\begin{keylist}{degree=\marg{x degree}\marg{y degree},cohomological Serre grading, homological Serre grading, Adams grading}
Specifies the degree of differentials. The \meta{x degree} and \meta{y degree} should both be mathematical expressions in one variable |#1| that evaluate to integers on any input. They specify the x and y displacement of a page |#1| differential. In practice, they will usually be linear expressions with |#1| coefficient 1, -1, or 0.

The |degree| option must be given before placing any differentials. It can be specified at the beginning of the |sseqdata| environment, at the beginning of the |sseqpage| environment if it is being used as a standalone page, or as a default by saying |\sseqset{degree=|\marg{x degree}\marg{y degree}|}| or |\sseqset{Adams grading}| outside of the |sseqdata| and |sseqpages| environments.

You can make a named grading convention by saying |\sseqset{my grading/.sseq grading=|\marg{x degree}\marg{y degree}. Then later passing |my grading| to a spectral sequence is equivalent to saying |degree=|\marg{x degree}\marg{y degree}. The following grading conventions exist by default:
\begin{codeexample}[]
\begin{sseqpage}[cohomological Serre grading]% equivalent to degree={#1}{1-#1}
\class(0,1)
\class(2,0)
\d2(0,1)
\end{sseqpage}
\end{codeexample}
\begin{codeexample}[]
\begin{sseqpage}[homological Serre grading]% equivalent to degree={-#1}{#1-1}
\class(0,1)
\class(2,0)
\d2(2,0)
\end{sseqpage}
\end{codeexample}
\begin{codeexample}[]
\begin{sseqpage}[Adams grading]% equivalent to degree={-1}{#1-1}
\class(0,2)
\class(1,0)
\d2(1,0)
\end{sseqpage}
\end{codeexample}
\end{keylist}

\begin{keylist}{x range={\meta{x min}}{\meta{x max}},y range={\meta{y min}}{\meta{y max}}}
These options force the x and y range to be a specific interval. By default, if no range is specified then the range is chosen to fit all the classes. If an x range is specified but no y range, then the y range is chosen to fit all the classes that lie inside the specified x range, and vice versa.
\end{keylist}

\begin{key}{update existing}
This key is only for the |sseqdata| environment. It specifies that the current |sseqdata| environment is adding data to an existing spectral sequence. If you don't pass this key, then giving a |sseqdata| environment the same |name| as a different |sseqdata| environment will cause an error. This is intended to help you avoid accidentally reusing the same name.
\end{key}


\begin{key}{keep changes=\meta{boolean} (default true)(initially false)}
This option is only for the |sseqpage| environment, and only works when a |name| is provided.
This option specifies that all of the commands in the current |sseqpage| environment should be carried forward to future pages of the same named spectral sequence. For example:
\begin{codeexample}[]
\begin{sseqdata}[name=keep changes example,Adams grading,y range={0}{3}]
\class(0,0)
\class(1,0)
\end{sseqdata}

\begin{sseqpage}[name=keep changes example,paths=orange]
\class(0,2)
\class(1,2)
\classoptions[orange](1,0)
\d2(1,0)
\end{sseqpage}
%
\hskip1cm
%
\begin{sseqpage}[name=keep changes example,paths=blue,keep changes]
\class(0,3)
\class(1,3)
\classoptions[blue](1,0)
\d3(1,0)
\end{sseqpage}
%
\hskip1cm
%
\printpage[name=keep changes example,page=3]
\end{codeexample}
Note that the orange classes and differential do not persist because the |keep changes| option is not set in the first |sseqpage| environment, but the blue classes and differential do, since the |keep changes| option is set in the second |sseqpage| environment.
\end{key}

\begin{keylist}{no differentials,draw differentials}
The option |no differentials| suppresses all of the differentials on the current page, whereas |draw differentials| causes the page appropriate differentials to be drawn. This is useful for explaining how the computation of the spectral sequence goes:
%\begin{codeexample}[]
%TODO: build example
%\end{codeexample}
\end{keylist}

\begin{keylist}{no struct lines,draw struct lines}
The option |no struct lines| suppresses all of the differentials on the current page, whereas the option |draw struct lines| causes the page appropriate differentials to be drawn.
\end{keylist}

\begin{keylist}{no orphan edges,draw orphan edges=\meta{boolean} (default true)(initially true)}
An edge is an ``orphan'' if both its source and target lie off the page. By default these are drawn, but with the option |no orphan edges| they are not. If the option |no orphan edges| has been set, |draw orphan edges| undoes it.
\begin{codeexample}[]
\begin{sseqdata}[name=orphan edges example,cohomological Serre grading,
                x range={0}{3}, y range={0}{3}]
\class(1,4)\class(4,2)
\d3(1,4)
\class(3,1)\class(5,0)
\d2(3,1)
\end{sseqdata}
\printpage[name=orphan edges example]
\hskip1cm
\printpage[name=orphan edges example,no orphan edges]
\end{codeexample}
\end{keylist}


\begin{key}{class placement transform=\marg{transform keys}}
The |sseqpages| option |class placement transform| allows the user to specify a Tikz coordinate transform to adjust the relative position of multiple nodes in the same (x,y) position. This coordinate transform can only involve rotation and scaling, no translation. Specifying a scaling factor helps if the nodes are too large and overlap. In some cases a rotation makes it easier to see which class is the target of a differential.
\begin{codeexample}[width=5cm]
\begin{sseqpage}[classes={draw=none},class placement transform={xscale=3}, math nodes,
                 xscale=2, x axis extend end=0.7cm]
\class["\mathbb{Z}"](0,0)
\class["\mathbb{Z}/2"](1,1)
\class["\mathbb{Z}/3"](1,1)
\end{sseqpage}
\end{codeexample}
\begin{codeexample}[width=5cm]
\begin{sseqpage}[classes=fill,class placement transform={rotate=40},
                 cohomological Serre grading,differentials=blue,scale=0.7]
\class(0,0)
\class(0,2)\class(0,2)
\class[red](3,0)\class[green](3,0)\class[blue](3,0)

\d3(0,2,1,2)
\d3(0,2,-1,-1)
\draw[->,red](3,0,1)--(0,0);
\end{sseqpage}
\end{codeexample}
\end{key}

\subsection{Styles}
The |sseqpages| package has a large number of ``styles'' which control the appearance of specific components (classes, differentials, or structlines) of a spectral sequence. These are named so that each command has a plural variant (e.g., |classes|) and a ``style'' variant (e.g., |class style|). The difference between these is always that |classes=\marg{keys}| adds the keys to the list of options used to style every class, whereas |class style=\marg{keys}| overwrites the list of options. It's important to be aware when using the style variants that some of the styles are not empty when |sseqpages| is loaded, so for instance saying |class style={}| will change the appearance of the diagram. Generally, the plural versions are more useful, but in very large diagrams it can be noticeably faster to use the style variants.

In cases where the same drawing feature is affected by multiple of these styles, the more specific style takes precedence.

Throughout, ``class'' and ``cycle'' are synonyms.
\begin{keylist}{sseqs=\marg{keys}, sseq style=\marg{keys}}
This passes global options to all future spectral sequences in the current scope. It is only useful to use this command with |\sseqset|. This is only really important for \tikzname\ options, because for most options from |sseqpages| you can set a default directly by saying |\sseqset{|key=\marg{value}|}|.
\begin{codeexample}[]
\sseqset{sseqs={scale=0.5}}% Applies to both of the two following sseqs
\begin{sseqpage}
\foreach \x in {0,1} \foreach \y in {0,1,2}{
    \class(\x,\y)
}
\end{sseqpage}
\hskip1cm
\begin{sseqpage}[Adams grading,classes={fill,blue}]
\foreach \x in {0,1,2} \foreach \y in {0,1,2}{
    \class(\x,\y)
}
\d2(1,0)
\d2(2,0)
\end{sseqpage}
\end{codeexample}
\end{keylist}

\begin{keylist}{classes=\marg{keys}, cycles=\marg{keys}, class style=\marg{keys}, cycle style=\marg{keys}}
The keys |classes| and |cycles| are synonyms as are |class style| and |cycle style|. These options change the appearance of all classes. The options |classes| and |cycles| append whatever keys you give to the list of class style options, whereas |class style| and |cycle style| overwrite the list of styles.
\begin{codeexample}[]
\begin{sseqpage}[classes={blue,fill,minimum width=0.5em}]
\class(0,0)
\class(2,2)
\end{sseqpage}
\end{codeexample}
\end{keylist}


\begin{keylist}{permanent classes=\marg{keys}, permanent cycles=\marg{keys}, permanent class style=\marg{keys}, permanent cycle style=\marg{keys}}
These options change the appearance of all permanent cycles (e.g., those classes which never support or are hit by a differential). For instance, we can circle the permanent cycles automatically. Note that because |permanent cycles| is more specific than |classes|, the |permanent cycles={draw}| command wins out over the |class={draw=none}| command to insure that the permanent cycle nodes are drawn.
\begin{codeexample}[]
\begin{sseqpage}[cohomological Serre grading, math nodes,
                 classes={draw=none},permanent cycles={draw}]
\foreach \x in {0,2} \foreach \y in {0,1}{
    \class["\mathbb{Z}"](\x,\y)
}
\d2(0,1)
\end{sseqpage}
\end{codeexample}
\end{keylist}

\begin{keylist}{transient classes=\marg{keys}, transient cycles=\marg{keys}, transient class style=\marg{keys}, transient cycle style=\marg{keys}}
These options change the appearance of all transient cycles (e.g., those classes which eventually support or are hit by a differential). Again, this takes precedence over the |classes| option.
\begin{codeexample}[]
\begin{sseqpage}[cohomological Serre grading, math nodes,
                 classes={draw=none}, transient cycles=red]
\foreach \x in {0,2} \foreach \y in {0,1}{
    \class["\mathbb{Z}"](\x,\y)
}
\d2(0,1)
\end{sseqpage}
\end{codeexample}
\end{keylist}

\begin{keylist}{this page classes=\marg{keys}, this page cycles=\marg{keys}, this page class style=\marg{keys}, this page cycle style=\marg{keys}}
These options change the appearance of all cycles which support or are hit by a differential on this page. Any class that is hit on the current page is also a transient cycle, and so |this page classes| takes precedence over |transient cycles|
\begin{codeexample}[width=6cm]
\begin{sseqdata}[name=this page cycles example,Adams grading,
                 transient cycles={red,fill},this page cycles={blue}]
\class(0,0)
\class(0,2)\class(1,0)
\class(1,3)\class(2,0)
\d2(1,0)\d3(2,0)
\end{sseqdata}
\printpage[name=this page cycles example,page=2]
\hskip1cm
\printpage[name=this page cycles example,page=3]
\end{codeexample}
\end{keylist}

\begin{keylist}{edges=\marg{keys}, edge style=\marg{keys}}
This style applies to both differentials and structure lines. The |differentials| and |struct lines| keys both take precedence over |edges|.
\end{keylist}

\begin{keylist}{differentials=\marg{keys}, differential style=\marg{keys}}

\end{keylist}

\begin{keylist}{struct lines=\marg{keys}, struct line style=\marg{keys}}

\end{keylist}

\begin{keylist}{this page struct lines=\marg{keys}, this page struct line style=\marg{keys}}
This style applies to structure lines whose source or target is hit on the current page. It takes precedence over |struct lines|.
\end{keylist}

\begin{keylist}{labels,label style}

\end{keylist}

\begin{keylist}{class labels,class label style}

\end{keylist}

\begin{keylist}{inner class labels,inner class label style}

\end{keylist}

\begin{keylist}{outer class labels,outer class label style}

\end{keylist}


\begin{keylist}{edge labels,edge label style}

\end{keylist}

\begin{keylist}{differential labels,differential label style}

\end{keylist}

\begin{keylist}{struct line labels,struct line label style}

\end{keylist}

\subsection{Global Coordinate Transformations}
Of the normal \tikzname\ coordinate transformations, only the following can be applied to a sseq diagram:
\begin{keylist}{scale=\meta{factor},xscale=\meta{factor}, yscale=\meta{factor}, xmirror, ymirror}
Scale the diagram by \meta{factor}. Under normal circumstances, you can tell \tikzname\ to mirror a diagram by saying, for instance, |xscale=-1|, but |sseqpages| needs to be aware that the diagram has been mirrored in order to draw the axes correctly. Thus, if you want to mirror a spectral sequence, use the |xmirror| and |ymirror| options as appropriate.
\end{keylist}

\begin{key}{rotate=\meta{angle}}
It probably won't look great if you pick an angle that isn't a multiple of 90 degrees.
\end{key}

\subsection{Layout}
\begin{key}{custom clip=\meta{clip path}}

\end{key}

\begin{key}{clip=\meta{boolean} (default true)(initially true)}

\end{key}

\begin{keylist}{x axis gap=\meta{dimension} (initially 0.5cm),y axis gap=\meta{dimension} (initially 0.5cm), axes gap=\meta{dimension} (initially 0.5cm)}

\end{keylist}


\begin{keylist}{x label gap=\meta{dimension} (initially 0.5cm),y label gap=\meta{dimension} (initially 0.5cm)}

\end{keylist}

\begin{keylist}{x axis start extend=\meta{dimension} (initially 0.5cm), y axis start extend=\meta{dimension} (initially 0.5cm),
                x axis end extend=\meta{dimension} (initially 0.9cm), y axis end extend=\meta{dimension} (initially 0.9cm)}

\end{keylist}

\begin{keylist}{x clip axis padding=\meta{dimension} (initially 0.1cm), y clip axis padding=\meta{dimension} (initially 0.1cm)}

\end{keylist}

\begin{keylist}{right clip padding=\meta{dimension} (initially 0.1cm), left clip padding=\meta{dimension} (initially 0.4cm),
                top clip padding=\meta{dimension} (initially 0.1cm), bottom clip padding=\meta{dimension} (initially 0.4cm)}

\end{keylist}


\subsection{Axes Style}

\begin{keylist}{x axis style=a (initially border), y axis style=a (initially border),axes style= (initially border)}

\end{keylist}

\begin{keylist}{x axis origin= (initially 0), y axis origin= (initially 0)}

\end{keylist}

\begin{keylist}{no x axis, no y axis, no axes, draw x axis, draw y axis, draw axes}

\end{keylist}

\begin{keylist}{no x axis labels, no y axis labels, no axes labels, draw x axis labels, draw y axis labels, draw axes labels}

\end{keylist}

\begin{keylist}{x label step= (initially 1),y label step= (initially 1),label step= (initially 1)}

\end{keylist}

\begin{key}{rotate labels=\meta{boolean} (default true)(initially false)}

\end{key}
\end{document}



\begin{command}{\addtocontext\marg{code}}
This command evaluates \meta{code} now, but also stores it and evaluates it at the same point when drawing the spectral sequence.
This is sometimes necessary because |sseqpages| uses a two-pass algorithm -- inside the |sseqdata| and |sseqpage| environments, |sseqpages| is only storing the input. The actual drawing all happens at |\end{sseqpage}|. This creates some counterintuitive behavior.

For instance, the following is an error:
\begin{codeexample}[code only]
\begin{sseqdata}[name=addtocontext example,class labels=left]
\def\x{1}\def\y{2}
\class(\x,\y) % This line is actually okay
\class["\y"](0,0) % this line causes an error
\draw (0,0)--(\x,\y); % this line also causes an error
\end{sseqdata}
\printpage[name=addtocontext example] % Gives error: "Undefined control sequence \x"
\end{codeexample}
The problem is that the definitions of |\x| and |\y| go out of scope when the |sseqdata| environment ends, but the |\x| in the |\class| label and |\draw| command coordinate have been stored to be evaluated later. When they actually are evaluated, |\x| has become undefined again and throws an error.
The fix for this is the |\addtocontext| command:
\begin{codeexample}[]
\begin{sseqdata}[name=addtocontext example 1, class labels=left]
\def\x{1}\def\y{2} % Tell sseqpages about the definitions
\class(\x,\y) % so \x and \y have the proper value now
\class["\y"](0,0) % and when these commands are printed.
\draw (0,0)--(\x,\y);
\end{sseqdata}
\printpage[name=addtocontext example 1]
\end{codeexample}
Setting the value of |\x| and |\y| outside the environment would work, but this is a bad idea if they might change:
\begin{codeexample}[]
\def\x{1}\def\y{2}
\begin{sseqdata}[name=addtocontext example 2,class labels=left]
\class(\x,\y) % \x -> {1}, \y -> {2}
\class["\y"](0,0) % surprise! \y -> 3
\draw (0,0)--(\x,\y); % surprise! \y -> 3
\end{sseqdata}
\def\y{3} % because it changed here
\printpage[name=addtocontext example 2]
\end{codeexample}
So when in doubt you should protect yourself with the |\addtocontext| command.

If you used a variable in the options to |\class|, don't use |\classoptions| on the same class when the same variable has a different value -- it will cause unexpected behavior. This caveat also applies to variables that are used for the |\foreach| command.
\begin{codeexample}[]
% Left diagram
\def\y{3}
\begin{sseqpage}[name=addtocontext example 1,class labels=right]
% We used \addtocontext{\def\x{1}\def\y{2}} in the sseqdata environment,
% so the original \y's are all correct
\node at (1,0) {\sectionstring\y=\y};
% Uh-oh, using \classoptions on classes that were defined with different values of \y.
\classoptions["\y"](0,0) % This \y is a 2 because it was a 2 when \class(0,0) was used =(
\classoptions["\y"](1,2) % and so is this one.
\end{sseqpage}
\end{codeexample}
Using |\addtocontext| doesn't work either:
\begin{codeexample}[]
\begin{sseqpage}[name=addtocontext example 1,class labels=right]
\addtocontext{\def\y{3}}
\node at (1,0) {\sectionstring\y=\y}; % All of these \y's are 3.
% Uh-oh, using \classoptions on classes that were defined with different values of \y.
\classoptions["\y"](0,0) % This call turns the old label into a 3!! =(
\classoptions["\y"](1,2)
\end{sseqpage}
\end{codeexample}
Note that the position of the |\class| is decided immediately, so there are no such problems with using the same variable in the position. But make sure that if a variable is used in the options twice that it has the same value both times.
\end{command} 